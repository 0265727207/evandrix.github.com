<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="8.html">jmt.engine.NodeSections</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Queue.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Queue.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/787)</TD><TD CLASS="h">0%   (0/168)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Queue</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/787)</TD><TD CLASS="h">0%   (0/168)</TD></TR><TR><TD CLASS="f"><A HREF="#1">Queue (Integer, Boolean, QueueGetStrategy, QueuePutStrategy []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">Queue (Integer, Boolean, QueueGetStrategy, QueuePutStrategy [], BlockingRegio...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#3">Queue (Integer, String [], QueueGetStrategy, QueuePutStrategy []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">Queue (int, boolean, QueueGetStrategy, QueuePutStrategy []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/61)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#5">Queue (int, boolean, QueueGetStrategy, QueuePutStrategy [], BlockingRegion): ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">forward (Job): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7">getDroppedJobPerClass (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">getDroppedJobs (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9">getDroppedJobsPerClass (): int []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">getIntSectionProperty (int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getIntSectionProperty (int, JobClass): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">getObject (int): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#d">hasInfiniteQueue (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">isEnabled (int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#f">isRedirectionON (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">nodeLinked (NetNode): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/112)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR><TD CLASS="f"><A HREF="#11">preloadJobs (int []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">process (NetMessage): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/311)</TD><TD CLASS="h">0%   (0/50)</TD></TR><TR><TD CLASS="f"><A HREF="#13">redirectionTurnOFF (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">redirectionTurnON (BlockingRegion): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/**    </TD></TR><TR><TD CLASS="l">2</TD><TD>  * Copyright (C) 2009, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano</TD></TR><TR><TD CLASS="l">3</TD><TD> </TD></TR><TR><TD CLASS="l">4</TD><TD>  * This program is free software; you can redistribute it and/or modify</TD></TR><TR><TD CLASS="l">5</TD><TD>  * it under the terms of the GNU General Public License as published by</TD></TR><TR><TD CLASS="l">6</TD><TD>  * the Free Software Foundation; either version 2 of the License, or</TD></TR><TR><TD CLASS="l">7</TD><TD>  * (at your option) any later version.</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>  * This program is distributed in the hope that it will be useful,</TD></TR><TR><TD CLASS="l">10</TD><TD>  * but WITHOUT ANY WARRANTY; without even the implied warranty of</TD></TR><TR><TD CLASS="l">11</TD><TD>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</TD></TR><TR><TD CLASS="l">12</TD><TD>  * GNU General Public License for more details.</TD></TR><TR><TD CLASS="l">13</TD><TD> </TD></TR><TR><TD CLASS="l">14</TD><TD>  * You should have received a copy of the GNU General Public License</TD></TR><TR><TD CLASS="l">15</TD><TD>  * along with this program; if not, write to the Free Software</TD></TR><TR><TD CLASS="l">16</TD><TD>  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</TD></TR><TR><TD CLASS="l">17</TD><TD>  */</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>package jmt.engine.NodeSections;</TD></TR><TR><TD CLASS="l">20</TD><TD> </TD></TR><TR><TD CLASS="l">21</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">22</TD><TD> </TD></TR><TR><TD CLASS="l">23</TD><TD>import jmt.common.exception.NetException;</TD></TR><TR><TD CLASS="l">24</TD><TD>import jmt.engine.NetStrategies.QueueGetStrategy;</TD></TR><TR><TD CLASS="l">25</TD><TD>import jmt.engine.NetStrategies.QueuePutStrategy;</TD></TR><TR><TD CLASS="l">26</TD><TD>import jmt.engine.NetStrategies.QueueGetStrategies.FCFSstrategy;</TD></TR><TR><TD CLASS="l">27</TD><TD>import jmt.engine.NetStrategies.QueuePutStrategies.TailStrategy;</TD></TR><TR><TD CLASS="l">28</TD><TD>import jmt.engine.QueueNet.BlockingRegion;</TD></TR><TR><TD CLASS="l">29</TD><TD>import jmt.engine.QueueNet.Job;</TD></TR><TR><TD CLASS="l">30</TD><TD>import jmt.engine.QueueNet.JobClass;</TD></TR><TR><TD CLASS="l">31</TD><TD>import jmt.engine.QueueNet.JobClassList;</TD></TR><TR><TD CLASS="l">32</TD><TD>import jmt.engine.QueueNet.JobInfo;</TD></TR><TR><TD CLASS="l">33</TD><TD>import jmt.engine.QueueNet.JobInfoList;</TD></TR><TR><TD CLASS="l">34</TD><TD>import jmt.engine.QueueNet.LinkedJobInfoList;</TD></TR><TR><TD CLASS="l">35</TD><TD>import jmt.engine.QueueNet.NetEvent;</TD></TR><TR><TD CLASS="l">36</TD><TD>import jmt.engine.QueueNet.NetMessage;</TD></TR><TR><TD CLASS="l">37</TD><TD>import jmt.engine.QueueNet.NetNode;</TD></TR><TR><TD CLASS="l">38</TD><TD>import jmt.engine.QueueNet.NodeSection;</TD></TR><TR><TD CLASS="l">39</TD><TD>import jmt.engine.QueueNet.PSJobInfoList;</TD></TR><TR><TD CLASS="l">40</TD><TD>import jmt.engine.QueueNet.WaitingRequest;</TD></TR><TR><TD CLASS="l">41</TD><TD>import jmt.engine.random.engine.RandomEngine;</TD></TR><TR><TD CLASS="l">42</TD><TD> </TD></TR><TR><TD CLASS="l">43</TD><TD>/**</TD></TR><TR><TD CLASS="l">44</TD><TD> * This class implements a generic finite/infinite queue. In finite queue, if</TD></TR><TR><TD CLASS="l">45</TD><TD> * the queue is full, new jobs could be dropped or not. It could implement</TD></TR><TR><TD CLASS="l">46</TD><TD> * different job strategy and/or waiting requests strategy.</TD></TR><TR><TD CLASS="l">47</TD><TD> *</TD></TR><TR><TD CLASS="l">48</TD><TD> * &lt;br&gt;&lt;br&gt;</TD></TR><TR><TD CLASS="l">49</TD><TD> * It can also define the queue of a station which is inside a blocking region.</TD></TR><TR><TD CLASS="l">50</TD><TD> * When a job arrives at this node section, the source node of the message is found out.</TD></TR><TR><TD CLASS="l">51</TD><TD> * If the source node is inside the same region, there are no problems and the message</TD></TR><TR><TD CLASS="l">52</TD><TD> * is processed as usual.</TD></TR><TR><TD CLASS="l">53</TD><TD> * Otherwise, if the source node is outside the blocking region, this message is not</TD></TR><TR><TD CLASS="l">54</TD><TD> * processed but redirected to the fictitious station (called &#34;region input station&#34;)</TD></TR><TR><TD CLASS="l">55</TD><TD> * which controls the access to the blocking region.</TD></TR><TR><TD CLASS="l">56</TD><TD> * &lt;br&gt;&lt;br&gt;</TD></TR><TR><TD CLASS="l">57</TD><TD> *</TD></TR><TR><TD CLASS="l">58</TD><TD> * The class has different constructors to create a generic queue or a redirecting queue.</TD></TR><TR><TD CLASS="l">59</TD><TD> * &lt;br&gt;</TD></TR><TR><TD CLASS="l">60</TD><TD> * However it's also possible to create a generic queue and then to turn on/off the</TD></TR><TR><TD CLASS="l">61</TD><TD> * &#34;redirecting queue&#34; behaviour using the &lt;tt&gt;redirectionTurnON(..)&lt;/tt&gt; and</TD></TR><TR><TD CLASS="l">62</TD><TD> * &lt;tt&gt;redirectionTurnOFF()&lt;/tt&gt; methods.</TD></TR><TR><TD CLASS="l">63</TD><TD> *</TD></TR><TR><TD CLASS="l">64</TD><TD> * @author Francesco Radaelli, Stefano Omini, Bertoli Marco</TD></TR><TR><TD CLASS="l">65</TD><TD> * </TD></TR><TR><TD CLASS="l">66</TD><TD> * Modified by Ashanka (Oct 2009) for FCR Bug fix: Events are created with job instead of null for EVENT_JOB_OUT_OF_REGION</TD></TR><TR><TD CLASS="l">67</TD><TD> */</TD></TR><TR><TD CLASS="l">68</TD><TD>/**</TD></TR><TR><TD CLASS="l">69</TD><TD> * &lt;p&gt;&lt;b&gt;Name:&lt;/b&gt; Queue&lt;/p&gt; </TD></TR><TR><TD CLASS="l">70</TD><TD> * &lt;p&gt;&lt;b&gt;Description:&lt;/b&gt; </TD></TR><TR><TD CLASS="l">71</TD><TD> * </TD></TR><TR><TD CLASS="l">72</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">73</TD><TD> * &lt;p&gt;&lt;b&gt;Date:&lt;/b&gt; 15/nov/2009</TD></TR><TR><TD CLASS="l">74</TD><TD> * &lt;b&gt;Time:&lt;/b&gt; 23.08.16&lt;/p&gt;</TD></TR><TR><TD CLASS="l">75</TD><TD> * @author Bertoli Marco [marco.bertoli@neptuny.com]</TD></TR><TR><TD CLASS="l">76</TD><TD> * @version 3.0</TD></TR><TR><TD CLASS="l">77</TD><TD> */</TD></TR><TR><TD CLASS="l">78</TD><TD>public class Queue extends InputSection {</TD></TR><TR><TD CLASS="l">79</TD><TD> </TD></TR><TR><TD CLASS="l">80</TD><TD>        /** Property Identifier: infinite. */</TD></TR><TR><TD CLASS="l">81</TD><TD>        public static final int PROPERTY_ID_INFINITE = 0x0101;</TD></TR><TR><TD CLASS="l">82</TD><TD>        /** Property Identifier: drop.*/</TD></TR><TR><TD CLASS="l">83</TD><TD>        public static final int PROPERTY_ID_DROP = 0x0102;</TD></TR><TR><TD CLASS="l">84</TD><TD>        /** Property Identifier: size.*/</TD></TR><TR><TD CLASS="l">85</TD><TD>        public static final int PROPERTY_ID_SIZE = 0x0103;</TD></TR><TR><TD CLASS="l">86</TD><TD>        /** Property Identifier: Waiting request.*/</TD></TR><TR><TD CLASS="l">87</TD><TD>        public static final int PROPERTY_ID_WAITING_REQUESTS = 0x0104;</TD></TR><TR><TD CLASS="l">88</TD><TD>        /** Property Identifier: Queue get strategy.*/</TD></TR><TR><TD CLASS="l">89</TD><TD>        public static final int PROPERTY_ID_GET_STRATEGY = 0x0105;</TD></TR><TR><TD CLASS="l">90</TD><TD>        /** Property Identifier: Queue put strategy.*/</TD></TR><TR><TD CLASS="l">91</TD><TD>        public static final int PROPERTY_ID_PUT_STRATEGY = 0x0106;</TD></TR><TR><TD CLASS="l">92</TD><TD>        /** Property Identifier: Dropped jobs.*/</TD></TR><TR><TD CLASS="l">93</TD><TD>        public static final int PROPERTY_ID_DROPPED_JOBS = 0x0107;</TD></TR><TR><TD CLASS="l">94</TD><TD> </TD></TR><TR><TD CLASS="l">95</TD><TD>        public static final String FINITE_DROP = &#34;drop&#34;;</TD></TR><TR><TD CLASS="l">96</TD><TD>        public static final String FINITE_BLOCK = &#34;BAS blocking&#34;;</TD></TR><TR><TD CLASS="l">97</TD><TD>        public static final String FINITE_WAITING = &#34;waiting queue&#34;;</TD></TR><TR><TD CLASS="l">98</TD><TD> </TD></TR><TR><TD CLASS="l">99</TD><TD>        private int size;</TD></TR><TR><TD CLASS="l">100</TD><TD> </TD></TR><TR><TD CLASS="l">101</TD><TD>        //coolStart is true if there are no waiting jobs when the queue is started</TD></TR><TR><TD CLASS="l">102</TD><TD>        private boolean coolStart, infinite;</TD></TR><TR><TD CLASS="l">103</TD><TD> </TD></TR><TR><TD CLASS="l">104</TD><TD>        private boolean[] drop, block;</TD></TR><TR><TD CLASS="l">105</TD><TD> </TD></TR><TR><TD CLASS="l">106</TD><TD>        //the JobInfoList of the owner NetNode (use to control the number of jobs in</TD></TR><TR><TD CLASS="l">107</TD><TD>        //case of finite queue)</TD></TR><TR><TD CLASS="l">108</TD><TD>        private JobInfoList nodeJobsList;</TD></TR><TR><TD CLASS="l">109</TD><TD> </TD></TR><TR><TD CLASS="l">110</TD><TD>        /** This jobinfolist should be used instead of jobsList to support Processor Sharing */</TD></TR><TR><TD CLASS="l">111</TD><TD>        private JobInfoList queueJobInfoList;</TD></TR><TR><TD CLASS="l">112</TD><TD> </TD></TR><TR><TD CLASS="l">113</TD><TD>        //number of dropped jobs</TD></TR><TR><TD CLASS="l">114</TD><TD>        private int droppedJobs;</TD></TR><TR><TD CLASS="l">115</TD><TD>        private int[] droppedJobsPerClass;</TD></TR><TR><TD CLASS="l">116</TD><TD> </TD></TR><TR><TD CLASS="l">117</TD><TD>        private JobInfoList waitingRequests;</TD></TR><TR><TD CLASS="l">118</TD><TD> </TD></TR><TR><TD CLASS="l">119</TD><TD>        private QueueGetStrategy getStrategy;</TD></TR><TR><TD CLASS="l">120</TD><TD> </TD></TR><TR><TD CLASS="l">121</TD><TD>        private QueuePutStrategy putStrategy[];</TD></TR><TR><TD CLASS="l">122</TD><TD> </TD></TR><TR><TD CLASS="l">123</TD><TD>        //-------------------BLOCKING REGION PROPERTIES----------------------------//</TD></TR><TR><TD CLASS="l">124</TD><TD>        //@author Stefano Omini</TD></TR><TR><TD CLASS="l">125</TD><TD> </TD></TR><TR><TD CLASS="l">126</TD><TD>        //true if the queue belongs to a blocking region and has to redirect the jobs</TD></TR><TR><TD CLASS="l">127</TD><TD>        //arriving from the outside of the region</TD></TR><TR><TD CLASS="l">128</TD><TD>        private boolean redirectionON;</TD></TR><TR><TD CLASS="l">129</TD><TD>        //the blocking region the node belongs to</TD></TR><TR><TD CLASS="l">130</TD><TD>        private BlockingRegion myRegion;</TD></TR><TR><TD CLASS="l">131</TD><TD>        //the input station of the blocking region</TD></TR><TR><TD CLASS="l">132</TD><TD>        private NetNode regionInputStation;</TD></TR><TR><TD CLASS="l">133</TD><TD> </TD></TR><TR><TD CLASS="l">134</TD><TD>        //-------------------end BLOCKING REGION PROPERTIES----------------------------//</TD></TR><TR><TD CLASS="l">135</TD><TD> </TD></TR><TR><TD CLASS="l">136</TD><TD>        /**</TD></TR><TR><TD CLASS="l">137</TD><TD>         * Creates a new instance of finite Queue.</TD></TR><TR><TD CLASS="l">138</TD><TD>         * @param size Queue size (-1 = infinite queue).</TD></TR><TR><TD CLASS="l">139</TD><TD>         * @param getStrategy Queue get strategy: if null FCFS strategy is used.</TD></TR><TR><TD CLASS="l">140</TD><TD>         * @param putStrategy Queue put strategy: if null Tail strategy is used.</TD></TR><TR><TD CLASS="l">141</TD><TD>         * @param drop True if the queue should rejects new jobs when it's full,</TD></TR><TR><TD CLASS="l">142</TD><TD>         * false otherwise.</TD></TR><TR><TD CLASS="l">143</TD><TD>         */</TD></TR><TR><TD CLASS="l">144</TD><TD>        public Queue(int size, boolean drop, QueueGetStrategy getStrategy, QueuePutStrategy putStrategy[]) {</TD></TR><TR><TD CLASS="l">145</TD><TD> </TD></TR><TR><TD CLASS="l">146</TD><TD>                //OLD</TD></TR><TR><TD CLASS="l">147</TD><TD>                //super();</TD></TR><TR><TD CLASS="l">148</TD><TD> </TD></TR><TR><TD CLASS="l">149</TD><TD>                //NEW</TD></TR><TR><TD CLASS="l"><A NAME="0">150</A></TD><TD>                //auto = false, otherwise when a JOB message is received,</TD></TR><TR><TD CLASS="l">151</TD><TD>                //the corresponding Job object is automatically added to</TD></TR><TR><TD CLASS="l">152</TD><TD>                //JobInfoList</TD></TR><TR><TD CLASS="l">153</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>                super(false);</TD></TR><TR><TD CLASS="l">155</TD><TD>                //end NEW</TD></TR><TR><TD CLASS="l">156</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>                if (size == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">158</TD><TD>                        infinite = true;</TD></TR><TR><TD CLASS="l">159</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>                        this.size = size;</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                        infinite = false;</TD></TR><TR><TD CLASS="l">162</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                if (getStrategy == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>                        this.getStrategy = new FCFSstrategy();</TD></TR><TR><TD CLASS="l">165</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>                        this.getStrategy = getStrategy;</TD></TR><TR><TD CLASS="l">167</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">168</TD><TD>                this.putStrategy = putStrategy;</TD></TR><TR><TD CLASS="l">169</TD><TD>                // Uses putstrategy.length to extimate number of classes. It's a bit unclean but we are forced for compatibility.</TD></TR><TR CLASS="z"><TD CLASS="l">170</TD><TD>                this.drop = new boolean[putStrategy.length];</TD></TR><TR CLASS="z"><TD CLASS="l">171</TD><TD>                this.block = new boolean[putStrategy.length];</TD></TR><TR CLASS="z"><TD CLASS="l">172</TD><TD>                Arrays.fill(this.drop, drop);</TD></TR><TR CLASS="z"><TD CLASS="l">173</TD><TD>                Arrays.fill(this.block, false);</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                coolStart = true;</TD></TR><TR><TD CLASS="l">175</TD><TD> </TD></TR><TR><TD CLASS="l">176</TD><TD>                //this node doesn't belong to any blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                redirectionON = false;</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                myRegion = null;</TD></TR><TR CLASS="z"><TD CLASS="l">179</TD><TD>                regionInputStation = null;</TD></TR><TR><TD CLASS="l">180</TD><TD> </TD></TR><TR><TD CLASS="l">181</TD><TD>                //NEW</TD></TR><TR><TD CLASS="l">182</TD><TD>                //@author Stefano Omini</TD></TR><TR><TD CLASS="l">183</TD><TD>                //log = NetSystem.getLog();</TD></TR><TR><TD CLASS="l">184</TD><TD>                //end NEW</TD></TR><TR CLASS="z"><TD CLASS="l">185</TD><TD>        }</TD></TR><TR><TD CLASS="l">186</TD><TD> </TD></TR><TR><TD CLASS="l">187</TD><TD>        /**</TD></TR><TR><TD CLASS="l">188</TD><TD>         * Creates a new instance of finite Queue.</TD></TR><TR><TD CLASS="l">189</TD><TD>         * @param size Queue size (-1 = infinite queue).</TD></TR><TR><TD CLASS="l">190</TD><TD>         * @param getStrategy Queue get strategy: if null FCFS strategy is used.</TD></TR><TR><TD CLASS="l">191</TD><TD>         * @param putStrategy Queue put strategy: if null Tail strategy is used.</TD></TR><TR><TD CLASS="l"><A NAME="1">192</A></TD><TD>         * @param drop True if the queue should rejects new jobs when it's full,</TD></TR><TR><TD CLASS="l">193</TD><TD>         * false otherwise.</TD></TR><TR><TD CLASS="l">194</TD><TD>         */</TD></TR><TR><TD CLASS="l">195</TD><TD>        public Queue(Integer size, Boolean drop, QueueGetStrategy getStrategy, QueuePutStrategy putStrategy[]) {</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>                this(size.intValue(), drop.booleanValue(), getStrategy, putStrategy);</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>        }</TD></TR><TR><TD CLASS="l">198</TD><TD> </TD></TR><TR><TD CLASS="l">199</TD><TD>        /** Creates a new instance of finite redirecting Queue.</TD></TR><TR><TD CLASS="l">200</TD><TD>         * @param size Queue size (-1 = infinite queue).</TD></TR><TR><TD CLASS="l">201</TD><TD>         * @param getStrategy Queue get strategy: if null FCFS strategy is used.</TD></TR><TR><TD CLASS="l">202</TD><TD>         * @param putStrategy Queue put strategy: if null Tail strategy is used.</TD></TR><TR><TD CLASS="l">203</TD><TD>         * @param drop True if the queue should rejects new jobs when it's full,</TD></TR><TR><TD CLASS="l">204</TD><TD>         * false otherwise.</TD></TR><TR><TD CLASS="l"><A NAME="5">205</A></TD><TD>         * @param myReg the blocking region to which the owner node of this queue belongs</TD></TR><TR><TD CLASS="l">206</TD><TD>         */</TD></TR><TR><TD CLASS="l">207</TD><TD>        public Queue(int size, boolean drop, QueueGetStrategy getStrategy, QueuePutStrategy putStrategy[], BlockingRegion myReg) {</TD></TR><TR><TD CLASS="l">208</TD><TD>                //uses constructor for generic queue</TD></TR><TR CLASS="z"><TD CLASS="l">209</TD><TD>                this(size, drop, getStrategy, putStrategy);</TD></TR><TR><TD CLASS="l">210</TD><TD> </TD></TR><TR><TD CLASS="l">211</TD><TD>                //sets blocking region properties</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                redirectionON = true;</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                myRegion = myReg;</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>                regionInputStation = myRegion.getInputStation();</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>        }</TD></TR><TR><TD CLASS="l">216</TD><TD> </TD></TR><TR><TD CLASS="l">217</TD><TD>        /** Creates a new instance of finite redirecting Queue.</TD></TR><TR><TD CLASS="l">218</TD><TD>         * @param size Queue size (-1 = infinite queue).</TD></TR><TR><TD CLASS="l">219</TD><TD>         * @param getStrategy Queue get strategy: if null FCFS strategy is used.</TD></TR><TR><TD CLASS="l">220</TD><TD>         * @param putStrategy Queue put strategy: if null Tail strategy is used.</TD></TR><TR><TD CLASS="l">221</TD><TD>         * @param drop True if the queue should rejects new jobs when it's full,</TD></TR><TR><TD CLASS="l"><A NAME="2">222</A></TD><TD>         * false otherwise.</TD></TR><TR><TD CLASS="l">223</TD><TD>         * @param myReg the blocking region to which the owner node of this queue belongs</TD></TR><TR><TD CLASS="l">224</TD><TD>         */</TD></TR><TR><TD CLASS="l">225</TD><TD>        public Queue(Integer size, Boolean drop, QueueGetStrategy getStrategy, QueuePutStrategy putStrategy[], BlockingRegion myReg) {</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>                this(size.intValue(), drop.booleanValue(), getStrategy, putStrategy, myReg);</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>        }</TD></TR><TR><TD CLASS="l">228</TD><TD> </TD></TR><TR><TD CLASS="l">229</TD><TD>        /**</TD></TR><TR><TD CLASS="l">230</TD><TD>         * Creates a new instance of finite Queue. This is the newwst constructor that supports</TD></TR><TR><TD CLASS="l">231</TD><TD>         * differend drop strategies. Other constructors are left for compatibility.</TD></TR><TR><TD CLASS="l">232</TD><TD>         * @param size Queue size (-1 = infinite queue).</TD></TR><TR><TD CLASS="l">233</TD><TD>         * @param getStrategy Queue get strategy: if null FCFS strategy is used.</TD></TR><TR><TD CLASS="l"><A NAME="3">234</A></TD><TD>         * @param putStrategy Queue put strategy: if null Tail strategy is used.</TD></TR><TR><TD CLASS="l">235</TD><TD>         * @param dropStrategies  </TD></TR><TR><TD CLASS="l">236</TD><TD>         */</TD></TR><TR><TD CLASS="l">237</TD><TD>        public Queue(Integer size, String[] dropStrategies, QueueGetStrategy getStrategy, QueuePutStrategy putStrategy[]) {</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>                this(size.intValue(), false, getStrategy, putStrategy);</TD></TR><TR><TD CLASS="l">239</TD><TD>                // Decodes drop strategies</TD></TR><TR CLASS="z"><TD CLASS="l">240</TD><TD>                for (int i = 0; i &lt; dropStrategies.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                        if (dropStrategies[i].equals(FINITE_DROP)) {</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>                                drop[i] = true;</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>                                block[i] = false;</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>                        } else if (dropStrategies[i].equals(FINITE_BLOCK)) {</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                                drop[i] = false;</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                                block[i] = true;</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>                        } else if (dropStrategies[i].equals(FINITE_WAITING)) {</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                                drop[i] = false;</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                                block[i] = false;</TD></TR><TR><TD CLASS="l">250</TD><TD>                        }</TD></TR><TR><TD CLASS="l">251</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>        }</TD></TR><TR><TD CLASS="l">253</TD><TD> </TD></TR><TR><TD CLASS="l">254</TD><TD>        /**</TD></TR><TR><TD CLASS="l">255</TD><TD>         * Turns on the &#34;redirecting queue&#34; behaviour.</TD></TR><TR><TD CLASS="l">256</TD><TD>         * @param region the blocking region to which the owner node</TD></TR><TR><TD CLASS="l"><A NAME="14">257</A></TD><TD>         * of this queue belongs</TD></TR><TR><TD CLASS="l">258</TD><TD>         */</TD></TR><TR><TD CLASS="l">259</TD><TD>        public void redirectionTurnON(BlockingRegion region) {</TD></TR><TR><TD CLASS="l">260</TD><TD>                //sets blocking region properties</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>                redirectionON = true;</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                myRegion = region;</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                regionInputStation = myRegion.getInputStation();</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>        }</TD></TR><TR><TD CLASS="l">265</TD><TD> </TD></TR><TR><TD CLASS="l">266</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="13">267</A></TD><TD>         * Turns off the &#34;redirecting queue&#34; behaviour.</TD></TR><TR><TD CLASS="l">268</TD><TD>         */</TD></TR><TR><TD CLASS="l">269</TD><TD>        public void redirectionTurnOFF() {</TD></TR><TR><TD CLASS="l">270</TD><TD>                //sets blocking region properties</TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>                redirectionON = false;</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                myRegion = null;</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                regionInputStation = null;</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>        }</TD></TR><TR><TD CLASS="l">275</TD><TD> </TD></TR><TR><TD CLASS="l">276</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="f">277</A></TD><TD>         * Tells whether the &#34;redirecting queue&#34; behaviour has been turned on.</TD></TR><TR><TD CLASS="l">278</TD><TD>         * @return true, if the &#34;redirecting queue&#34; behaviour is on; false otherwise.</TD></TR><TR><TD CLASS="l">279</TD><TD>         */</TD></TR><TR><TD CLASS="l">280</TD><TD>        public boolean isRedirectionON() {</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                return redirectionON;</TD></TR><TR><TD CLASS="l">282</TD><TD>        }</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="e">284</A></TD><TD>        //end NEW</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR><TD CLASS="l">286</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">287</TD><TD>        public boolean isEnabled(int id) throws jmt.common.exception.NetException {</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>                switch (id) {</TD></TR><TR><TD CLASS="l">289</TD><TD>                        case PROPERTY_ID_INFINITE:</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>                                return infinite;</TD></TR><TR><TD CLASS="l">291</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                                return super.isEnabled(id);</TD></TR><TR><TD CLASS="l">293</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="a">294</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">295</TD><TD> </TD></TR><TR><TD CLASS="l">296</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">297</TD><TD>        public int getIntSectionProperty(int id) throws jmt.common.exception.NetException {</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                switch (id) {</TD></TR><TR><TD CLASS="l">299</TD><TD>                        case PROPERTY_ID_SIZE:</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>                                return size;</TD></TR><TR><TD CLASS="l">301</TD><TD>                        case PROPERTY_ID_WAITING_REQUESTS:</TD></TR><TR CLASS="z"><TD CLASS="l">302</TD><TD>                                return waitingRequests.size();</TD></TR><TR><TD CLASS="l">303</TD><TD>                                //NEW</TD></TR><TR><TD CLASS="l">304</TD><TD>                                //@author Stefano Omini</TD></TR><TR><TD CLASS="l">305</TD><TD>                        case PROPERTY_ID_DROPPED_JOBS:</TD></TR><TR CLASS="z"><TD CLASS="l">306</TD><TD>                                return droppedJobs;</TD></TR><TR><TD CLASS="l">307</TD><TD>                                //end NEW</TD></TR><TR><TD CLASS="l">308</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">309</TD><TD>                                return super.getIntSectionProperty(id);</TD></TR><TR><TD CLASS="l">310</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="b">311</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">312</TD><TD> </TD></TR><TR><TD CLASS="l">313</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">314</TD><TD>        public int getIntSectionProperty(int id, JobClass jobClass) throws jmt.common.exception.NetException {</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                switch (id) {</TD></TR><TR><TD CLASS="l">316</TD><TD>                        case PROPERTY_ID_WAITING_REQUESTS:</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                                return waitingRequests.size(jobClass);</TD></TR><TR><TD CLASS="l">318</TD><TD>                                //NEW</TD></TR><TR><TD CLASS="l">319</TD><TD>                                //@author Stefano Omini</TD></TR><TR><TD CLASS="l">320</TD><TD>                        case PROPERTY_ID_DROPPED_JOBS:</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                                return droppedJobsPerClass[jobClass.getId()];</TD></TR><TR><TD CLASS="l">322</TD><TD>                                //end NEW</TD></TR><TR><TD CLASS="l">323</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                                return super.getIntSectionProperty(id, jobClass);</TD></TR><TR><TD CLASS="l">325</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="c">326</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">327</TD><TD> </TD></TR><TR><TD CLASS="l">328</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">329</TD><TD>        public Object getObject(int id) throws jmt.common.exception.NetException {</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                switch (id) {</TD></TR><TR><TD CLASS="l">331</TD><TD>                        case PROPERTY_ID_GET_STRATEGY:</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                                return getStrategy;</TD></TR><TR><TD CLASS="l">333</TD><TD>                        case PROPERTY_ID_PUT_STRATEGY:</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                                return putStrategy;</TD></TR><TR><TD CLASS="l">335</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                                return super.getObject(id);</TD></TR><TR><TD CLASS="l"><A NAME="d">337</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">338</TD><TD>        }</TD></TR><TR><TD CLASS="l">339</TD><TD> </TD></TR><TR><TD CLASS="l">340</TD><TD>        public boolean hasInfiniteQueue() {</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>                return infinite;</TD></TR><TR><TD CLASS="l">342</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="10">343</A></TD><TD> </TD></TR><TR><TD CLASS="l">344</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">345</TD><TD>        protected void nodeLinked(NetNode node) {</TD></TR><TR><TD CLASS="l">346</TD><TD>                // Sets netnode dependent properties</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                waitingRequests = new LinkedJobInfoList(getJobClasses().size(), true);</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                if (putStrategy == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                        putStrategy = new QueuePutStrategy[getJobClasses().size()];</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                        for (int i = 0; i &lt; getJobClasses().size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                                putStrategy[i] = new TailStrategy();</TD></TR><TR><TD CLASS="l">352</TD><TD>                        }</TD></TR><TR><TD CLASS="l">353</TD><TD>                }</TD></TR><TR><TD CLASS="l">354</TD><TD> </TD></TR><TR><TD CLASS="l">355</TD><TD>                // TODO the following line its not clean. The correct behavior should be implemented without this hack.</TD></TR><TR><TD CLASS="l">356</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>                        if (getOwnerNode().getSection(SERVICE) instanceof PSServer) {</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                                jobsList = new PSJobInfoList(getJobClasses().size(), true);</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>                                queueJobInfoList = ((PSJobInfoList) jobsList).getInternalList();</TD></TR><TR><TD CLASS="l">360</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                } catch (NetException ex) {</TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>                        logger.error(ex);</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>                if (jobsList == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                        jobsList = new LinkedJobInfoList(getJobClasses().size(), true);</TD></TR><TR><TD CLASS="l">366</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>                if (queueJobInfoList == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                        queueJobInfoList = jobsList;</TD></TR><TR><TD CLASS="l">369</TD><TD>                }</TD></TR><TR><TD CLASS="l">370</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                if (!infinite) {</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                        droppedJobs = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">373</TD><TD>                        droppedJobsPerClass = new int[getJobClasses().size()];</TD></TR><TR CLASS="z"><TD CLASS="l">374</TD><TD>                        for (int i = 0; i &lt; droppedJobsPerClass.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                                droppedJobsPerClass[i] = 0;</TD></TR><TR><TD CLASS="l">376</TD><TD>                        }</TD></TR><TR><TD CLASS="l">377</TD><TD>                }</TD></TR><TR><TD CLASS="l">378</TD><TD> </TD></TR><TR><TD CLASS="l">379</TD><TD>                //retrieves the job info list of the owner node</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                nodeJobsList = getOwnerNode().getJobInfoList();</TD></TR><TR><TD CLASS="l">381</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>        }</TD></TR><TR><TD CLASS="l">383</TD><TD> </TD></TR><TR><TD CLASS="l">384</TD><TD>        /** This method implements a generic finite/infinite queue</TD></TR><TR><TD CLASS="l">385</TD><TD>         * @param message message to be processed.</TD></TR><TR><TD CLASS="l">386</TD><TD>         * @throws jmt.common.exception.NetException</TD></TR><TR><TD CLASS="l"><A NAME="12">387</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">388</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">389</TD><TD>        protected int process(NetMessage message) throws jmt.common.exception.NetException {</TD></TR><TR><TD CLASS="l">390</TD><TD>                Job job;</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                switch (message.getEvent()) {</TD></TR><TR><TD CLASS="l">392</TD><TD> </TD></TR><TR><TD CLASS="l">393</TD><TD>                        case NetEvent.EVENT_START:</TD></TR><TR><TD CLASS="l">394</TD><TD> </TD></TR><TR><TD CLASS="l">395</TD><TD>                                //EVENT_START</TD></TR><TR><TD CLASS="l">396</TD><TD>                                //If there are jobs in queue, the first (chosen using the specified</TD></TR><TR><TD CLASS="l">397</TD><TD>                                //get strategy) is forwarded and coolStart becomes false.</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">399</TD><TD>                                if (queueJobInfoList.size() &gt; 0) {</TD></TR><TR><TD CLASS="l">400</TD><TD>                                        //the first job is forwarded to service section</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                                        forward(getStrategy.get(queueJobInfoList));</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>                                        coolStart = false;</TD></TR><TR><TD CLASS="l">403</TD><TD>                                }</TD></TR><TR><TD CLASS="l">404</TD><TD> </TD></TR><TR><TD CLASS="l">405</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR><TD CLASS="l">407</TD><TD>                        case NetEvent.EVENT_ACK:</TD></TR><TR><TD CLASS="l">408</TD><TD> </TD></TR><TR><TD CLASS="l">409</TD><TD>                                //EVENT_ACK</TD></TR><TR><TD CLASS="l">410</TD><TD>                                //If there are waiting requests, the first is taken (if the source node of this request</TD></TR><TR><TD CLASS="l">411</TD><TD>                                //is the owner node of this section, an ack message is sent).</TD></TR><TR><TD CLASS="l">412</TD><TD>                                //The job contained is put into the queue using the specified put strategy.</TD></TR><TR><TD CLASS="l">413</TD><TD>                                //</TD></TR><TR><TD CLASS="l">414</TD><TD>                                //At this point, if there are jobs in queue, the first is taken (using the</TD></TR><TR><TD CLASS="l">415</TD><TD>                                //specified get strategy) and forwarded. Otherwise, if there are no jobs, coolStart</TD></TR><TR><TD CLASS="l">416</TD><TD>                                //is set true.</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR><TD CLASS="l">418</TD><TD>                                // if there is a waiting request send ack to the first node</TD></TR><TR><TD CLASS="l">419</TD><TD>                                //(note that with infinite queue there are no waitinq requests)</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>                                if (waitingRequests.size() != 0) {</TD></TR><TR><TD CLASS="l">421</TD><TD>                                        WaitingRequest wr;</TD></TR><TR CLASS="z"><TD CLASS="l">422</TD><TD>                                        wr = (WaitingRequest) waitingRequests.removeFirst();</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR><TD CLASS="l">424</TD><TD>                                        // If the source is not the owner node sends ack if blocking is enabled. Otherwise </TD></TR><TR><TD CLASS="l">425</TD><TD>                                        // ack was already sent.</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                                        if (!isMyOwnerNode(wr.getNode()) &amp;&amp; block[wr.getJob().getJobClass().getId()]) {</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>                                                send(NetEvent.EVENT_ACK, wr.getJob(), 0.0, wr.getSection(), wr.getNode());</TD></TR><TR><TD CLASS="l">428</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">429</TD><TD> </TD></TR><TR><TD CLASS="l">430</TD><TD>                                        //the class ID of this job</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                                        int c = wr.getJob().getJobClass().getId();</TD></TR><TR><TD CLASS="l">432</TD><TD>                                        //the job is put into the queue according to its own class put strategy</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                                        putStrategy[c].put(wr.getJob(), queueJobInfoList, message.getSourceSection(), message.getSource(), this);</TD></TR><TR><TD CLASS="l">434</TD><TD>                                }</TD></TR><TR><TD CLASS="l">435</TD><TD> </TD></TR><TR><TD CLASS="l">436</TD><TD>                                // if there is at least one job, sends it</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                                if (queueJobInfoList.size() &gt; 0) {</TD></TR><TR><TD CLASS="l">438</TD><TD>                                        // Gets job using a specific strategy and sends job</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                                        Job jobSent = getStrategy.get(queueJobInfoList);</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                                        forward(jobSent);</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">442</TD><TD>                                        // else set coolStart to true</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>                                        coolStart = true;</TD></TR><TR><TD CLASS="l">444</TD><TD> </TD></TR><TR><TD CLASS="l">445</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">447</TD><TD> </TD></TR><TR><TD CLASS="l">448</TD><TD>                        case NetEvent.EVENT_JOB:</TD></TR><TR><TD CLASS="l">449</TD><TD> </TD></TR><TR><TD CLASS="l">450</TD><TD>                                //EVENT_JOB</TD></TR><TR><TD CLASS="l">451</TD><TD>                                //If the queue is a redirecting queue, jobs arriving from the outside of</TD></TR><TR><TD CLASS="l">452</TD><TD>                                //the blocking region must be redirected to the region input station</TD></TR><TR><TD CLASS="l">453</TD><TD>                                //</TD></TR><TR><TD CLASS="l">454</TD><TD>                                //Otherwise the job is processed as usual.</TD></TR><TR><TD CLASS="l">455</TD><TD>                                //</TD></TR><TR><TD CLASS="l">456</TD><TD>                                //If coolStart is true, the queue is empty, so the job is added to the job list</TD></TR><TR><TD CLASS="l">457</TD><TD>                                //and immediately forwarded to the next section. An ack is sent and coolStart is</TD></TR><TR><TD CLASS="l">458</TD><TD>                                //set to false.</TD></TR><TR><TD CLASS="l">459</TD><TD>                                //</TD></TR><TR><TD CLASS="l">460</TD><TD>                                //If the queue is not empty, it should be distinguished between finite/infinite queue.</TD></TR><TR><TD CLASS="l">461</TD><TD>                                //</TD></TR><TR><TD CLASS="l">462</TD><TD>                                //If the queue is finite, checks the size: if it's not full the job is put into the</TD></TR><TR><TD CLASS="l">463</TD><TD>                                //queue and an ack is sent. Else, if it's full, checks the owner node: if the</TD></TR><TR><TD CLASS="l">464</TD><TD>                                //source node is the owner node of this section, an ack is sent and a waiting</TD></TR><TR><TD CLASS="l">465</TD><TD>                                //request is created. If the source is another node the waiting request is created</TD></TR><TR><TD CLASS="l">466</TD><TD>                                //only if drop is false, otherwise an ack is sent but the job is rejected.</TD></TR><TR><TD CLASS="l">467</TD><TD>                                //</TD></TR><TR><TD CLASS="l">468</TD><TD>                                //If the queue is infinite, the job is put into the queue and an ack is sent</TD></TR><TR><TD CLASS="l">469</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>                                job = message.getJob();</TD></TR><TR><TD CLASS="l">471</TD><TD> </TD></TR><TR><TD CLASS="l">472</TD><TD>                                //----REDIRECTION BEHAVIOUR----------//</TD></TR><TR CLASS="z"><TD CLASS="l">473</TD><TD>                                if (isRedirectionON()) {</TD></TR><TR><TD CLASS="l">474</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>                                        NetNode source = message.getSource();</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                                        boolean fromTheInside = myRegion.belongsToRegion(source);</TD></TR><TR><TD CLASS="l">477</TD><TD> </TD></TR><TR><TD CLASS="l">478</TD><TD>                                        //the first time input station isn't known yet</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>                                        if (regionInputStation == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">480</TD><TD>                                                regionInputStation = myRegion.getInputStation();</TD></TR><TR><TD CLASS="l">481</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">482</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                                        if (!fromTheInside) {</TD></TR><TR><TD CLASS="l">484</TD><TD>                                                //this message has arrived from the outside of the blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                                                if ((source != regionInputStation)) {</TD></TR><TR><TD CLASS="l">486</TD><TD>                                                        //the external source is not the input station</TD></TR><TR><TD CLASS="l">487</TD><TD>                                                        //the message must be redirected to the input station,</TD></TR><TR><TD CLASS="l">488</TD><TD>                                                        //without processing it</TD></TR><TR><TD CLASS="l">489</TD><TD> </TD></TR><TR><TD CLASS="l">490</TD><TD>                                                        //redirects the message to the inputStation</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                                                        redirect(NetEvent.EVENT_JOB, job, 0.0, NodeSection.INPUT, regionInputStation);</TD></TR><TR><TD CLASS="l">492</TD><TD>                                                        //send a ack to the source</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                                                        send(NetEvent.EVENT_ACK, job, 0.0, message.getSourceSection(), message.getSource());</TD></TR><TR><TD CLASS="l">494</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                                                        return MSG_PROCESSED;</TD></TR><TR><TD CLASS="l">496</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">497</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">498</TD><TD>                                }</TD></TR><TR><TD CLASS="l">499</TD><TD>                                //----END REDIRECTION BEHAVIOUR-------//</TD></TR><TR><TD CLASS="l">500</TD><TD> </TD></TR><TR><TD CLASS="l">501</TD><TD>                                //</TD></TR><TR><TD CLASS="l">502</TD><TD>                                //two possible cases:</TD></TR><TR><TD CLASS="l">503</TD><TD>                                //1 - the queue is a generic queue (redirectionOn == false)</TD></TR><TR><TD CLASS="l">504</TD><TD>                                //2 - the queue is a redirecting queue, but the message has arrived</TD></TR><TR><TD CLASS="l">505</TD><TD>                                //from the inside of the region or from the inputStation:</TD></TR><TR><TD CLASS="l">506</TD><TD>                                //in this case the redirecting queue acts as a normal queue</TD></TR><TR><TD CLASS="l">507</TD><TD>                                //</TD></TR><TR><TD CLASS="l">508</TD><TD>                                //therefore in both cases the behaviour is the same</TD></TR><TR><TD CLASS="l">509</TD><TD>                                //</TD></TR><TR><TD CLASS="l">510</TD><TD> </TD></TR><TR><TD CLASS="l">511</TD><TD>                                // Check if there is still capacity.</TD></TR><TR><TD CLASS="l">512</TD><TD>                                // &lt;= size because the arrived job hasn't been inserted in Queue</TD></TR><TR><TD CLASS="l">513</TD><TD>                                // job list but has been inserted in NetNode job list !!</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>                                if (infinite || nodeJobsList.size() &lt;= size) {</TD></TR><TR><TD CLASS="l">515</TD><TD>                                        // Queue is not full. Okay.</TD></TR><TR><TD CLASS="l">516</TD><TD> </TD></TR><TR><TD CLASS="l">517</TD><TD>                                        // If coolStart is true, this is the first job received or the</TD></TR><TR><TD CLASS="l">518</TD><TD>                                        // queue was empty: this job is sent immediately to the next</TD></TR><TR><TD CLASS="l">519</TD><TD>                                        // section and coolStart set to false.</TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>                                        if (coolStart) {</TD></TR><TR><TD CLASS="l">521</TD><TD>                                                // No jobs in queue: Refresh jobsList and sends job (don't use put strategy, because queue is empty)</TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>                                                queueJobInfoList.add(new JobInfo(job));</TD></TR><TR><TD CLASS="l">523</TD><TD>                                                //forward without any delay</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>                                                forward(queueJobInfoList.removeFirst().getJob());</TD></TR><TR><TD CLASS="l">525</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>                                                coolStart = false;</TD></TR><TR><TD CLASS="l">527</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">528</TD><TD>                                                putStrategy[job.getJobClass().getId()].put(job, queueJobInfoList, message.getSourceSection(), message.getSource(), this);</TD></TR><TR><TD CLASS="l">529</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">530</TD><TD>                                        //sends an ACK backward</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>                                        send(NetEvent.EVENT_ACK, job, 0.0, message.getSourceSection(), message.getSource());</TD></TR><TR><TD CLASS="l">532</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">533</TD><TD>                                        // Queue is full. Now we use an additional queue or drop.</TD></TR><TR><TD CLASS="l">534</TD><TD> </TD></TR><TR><TD CLASS="l">535</TD><TD>                                        // if the job has been sent by the owner node of this queue section</TD></TR><TR CLASS="z"><TD CLASS="l">536</TD><TD>                                        if (isMyOwnerNode(message.getSource())) {</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>                                                send(NetEvent.EVENT_ACK, job, 0.0, message.getSourceSection(), message.getSource());</TD></TR><TR><TD CLASS="l">538</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">539</TD><TD>                                                waitingRequests.add(new WaitingRequest(message.getSource(), message.getSourceSection(), job));</TD></TR><TR><TD CLASS="l">540</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">541</TD><TD>                                        // otherwise if job has been sent by another node</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                                        else if (!drop[job.getJobClass().getId()]) {</TD></TR><TR><TD CLASS="l">543</TD><TD>                                                // if drop is true reject the job, else add the job to waitingRequests</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>                                                waitingRequests.add(new WaitingRequest(message.getSource(), message.getSourceSection(), job));</TD></TR><TR><TD CLASS="l">545</TD><TD>                                                //if blocking is disabled, sends ack otherwise router of the previous node remains busy</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                                                if (!block[job.getJobClass().getId()]) {</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>                                                        send(NetEvent.EVENT_ACK, job, 0.0, message.getSourceSection(), message.getSource());</TD></TR><TR><TD CLASS="l">548</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">549</TD><TD>                                        } else {</TD></TR><TR><TD CLASS="l">550</TD><TD>                                                // if drop, send ack event to source</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>                                                droppedJobs++;</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                                                droppedJobsPerClass[job.getJobClass().getId()]++;</TD></TR><TR><TD CLASS="l">553</TD><TD> </TD></TR><TR><TD CLASS="l">554</TD><TD>                                                // Removes job from global jobInfoList - Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                                                getOwnerNode().getQueueNet().getJobInfoList().dropJob(job);</TD></TR><TR><TD CLASS="l">556</TD><TD> </TD></TR><TR><TD CLASS="l">557</TD><TD>                                                //after arriving to this section, the job has been inserted in the job</TD></TR><TR><TD CLASS="l">558</TD><TD>                                                //lists of both node section and node.</TD></TR><TR><TD CLASS="l">559</TD><TD>                                                //If drop = true, the job must be removed if the queue is full.</TD></TR><TR><TD CLASS="l">560</TD><TD>                                                //Using the &#34;general&#34; send method, however, the dropped job wasn't removed</TD></TR><TR><TD CLASS="l">561</TD><TD>                                                //from the job info list of node section and of node, then it was</TD></TR><TR><TD CLASS="l">562</TD><TD>                                                //sent later, after receiving one or more ack.</TD></TR><TR><TD CLASS="l">563</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>                                                sendAckAfterDrop(job, 0.0, message.getSourceSection(), message.getSource());</TD></TR><TR><TD CLASS="l">565</TD><TD> </TD></TR><TR><TD CLASS="l">566</TD><TD>                                                //if the queue is inside a blocking region, the jobs</TD></TR><TR><TD CLASS="l">567</TD><TD>                                                //counter must be decreased</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>                                                if (isRedirectionON()) {</TD></TR><TR><TD CLASS="l">569</TD><TD>                                                        //decrease the number of jobs</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>                                                        myRegion.decreaseOccupation(job.getJobClass());</TD></TR><TR><TD CLASS="l">571</TD><TD>                                                        //sends an event to the input station (which may be blocked)</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>                                                        send(NetEvent.EVENT_JOB_OUT_OF_REGION, job, 0.0, NodeSection.INPUT, regionInputStation);</TD></TR><TR><TD CLASS="l">573</TD><TD>                                                        //Since now for blocking regions the job dropping is handles manually at node </TD></TR><TR><TD CLASS="l">574</TD><TD>                                                        //level hence need to create events with Jobs ..Modified for FCR Bug Fix</TD></TR><TR><TD CLASS="l">575</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">576</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">577</TD><TD>                                }</TD></TR><TR><TD CLASS="l">578</TD><TD> </TD></TR><TR><TD CLASS="l">579</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">580</TD><TD> </TD></TR><TR><TD CLASS="l">581</TD><TD>                        default:</TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>                                return MSG_NOT_PROCESSED;</TD></TR><TR><TD CLASS="l">583</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="6">584</A></TD><TD>                return MSG_PROCESSED;</TD></TR><TR><TD CLASS="l">585</TD><TD>        }</TD></TR><TR><TD CLASS="l">586</TD><TD> </TD></TR><TR><TD CLASS="l">587</TD><TD>        private void forward(Job job) throws jmt.common.exception.NetException {</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>                sendForward(job, 0.0);</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>        }</TD></TR><TR><TD CLASS="l">590</TD><TD> </TD></TR><TR><TD CLASS="l">591</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="8">592</A></TD><TD>         * Gets the total number of dropped jobs</TD></TR><TR><TD CLASS="l">593</TD><TD>         * @return the total number of dropped jobs, -1 otherwise</TD></TR><TR><TD CLASS="l">594</TD><TD>         */</TD></TR><TR><TD CLASS="l">595</TD><TD>        public int getDroppedJobs() {</TD></TR><TR CLASS="z"><TD CLASS="l">596</TD><TD>                if (!infinite) {</TD></TR><TR CLASS="z"><TD CLASS="l">597</TD><TD>                        return droppedJobs;</TD></TR><TR><TD CLASS="l">598</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>                        return -1;</TD></TR><TR><TD CLASS="l">600</TD><TD>                }</TD></TR><TR><TD CLASS="l">601</TD><TD>        }</TD></TR><TR><TD CLASS="l">602</TD><TD> </TD></TR><TR><TD CLASS="l">603</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="9">604</A></TD><TD>         * Gets the numbers of dropped jobs for each class</TD></TR><TR><TD CLASS="l">605</TD><TD>         * @return the numbers of dropped jobs for each class, null otherwise</TD></TR><TR><TD CLASS="l">606</TD><TD>         */</TD></TR><TR><TD CLASS="l">607</TD><TD>        public int[] getDroppedJobsPerClass() {</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                if (!infinite) {</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>                        return droppedJobsPerClass;</TD></TR><TR><TD CLASS="l">610</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">612</TD><TD>                }</TD></TR><TR><TD CLASS="l">613</TD><TD> </TD></TR><TR><TD CLASS="l">614</TD><TD>        }</TD></TR><TR><TD CLASS="l">615</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="7">616</A></TD><TD>        /**         * Gets the number of dropped jobs for the specified class</TD></TR><TR><TD CLASS="l">617</TD><TD>         * @return the number of dropped jobs for the specified class, -1 otherwise</TD></TR><TR><TD CLASS="l">618</TD><TD>         */</TD></TR><TR><TD CLASS="l">619</TD><TD>        public int getDroppedJobPerClass(int jobClass) {</TD></TR><TR CLASS="z"><TD CLASS="l">620</TD><TD>                if (!infinite) {</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>                        return droppedJobsPerClass[jobClass];</TD></TR><TR><TD CLASS="l">622</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>                        return -1;</TD></TR><TR><TD CLASS="l">624</TD><TD>                }</TD></TR><TR><TD CLASS="l">625</TD><TD> </TD></TR><TR><TD CLASS="l">626</TD><TD>        }</TD></TR><TR><TD CLASS="l">627</TD><TD> </TD></TR><TR><TD CLASS="l">628</TD><TD>        /**</TD></TR><TR><TD CLASS="l">629</TD><TD>         * Adds the specified numbers of jobs for each class</TD></TR><TR><TD CLASS="l">630</TD><TD>         * @param preload_jobPerClass the numbers of jobs for each class</TD></TR><TR><TD CLASS="l"><A NAME="11">631</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">632</TD><TD>        public void preloadJobs(int[] preload_jobPerClass) {</TD></TR><TR><TD CLASS="l">633</TD><TD> </TD></TR><TR><TD CLASS="l">634</TD><TD>                //total jobs</TD></TR><TR CLASS="z"><TD CLASS="l">635</TD><TD>                int totJobs = 0;</TD></TR><TR><TD CLASS="l">636</TD><TD> </TD></TR><TR><TD CLASS="l">637</TD><TD>                //number of classes</TD></TR><TR CLASS="z"><TD CLASS="l">638</TD><TD>                int classNumber = preload_jobPerClass.length;</TD></TR><TR><TD CLASS="l">639</TD><TD> </TD></TR><TR><TD CLASS="l">640</TD><TD>                //jobs that haven't been inserted yet</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>                int[] residualClassJobs = new int[classNumber];</TD></TR><TR><TD CLASS="l">642</TD><TD> </TD></TR><TR><TD CLASS="l">643</TD><TD>                //first of all computes the total number of jobs to be added</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>                for (int c = 0; c &lt; classNumber; c++) {</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                        totJobs += preload_jobPerClass[c];</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                        residualClassJobs[c] = preload_jobPerClass[c];</TD></TR><TR><TD CLASS="l">647</TD><TD>                }</TD></TR><TR><TD CLASS="l">648</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>                RandomEngine randomEng = RandomEngine.makeDefault();</TD></TR><TR><TD CLASS="l">650</TD><TD>                int randomClassIndex;</TD></TR><TR><TD CLASS="l">651</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>                JobClassList jobClasses = getJobClasses();</TD></TR><TR><TD CLASS="l">653</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">654</TD><TD>                while (totJobs &gt; 0) {</TD></TR><TR><TD CLASS="l">655</TD><TD>                        //jobs of different classes must be mixed.. use random numbers</TD></TR><TR><TD CLASS="l">656</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">657</TD><TD>                        randomClassIndex = (int) Math.floor((randomEng.raw()) * classNumber);</TD></TR><TR><TD CLASS="l">658</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                        if (residualClassJobs[randomClassIndex] &gt; 0) {</TD></TR><TR><TD CLASS="l">660</TD><TD>                                //other jobs to be added</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>                                Job newJob = new Job(jobClasses.get(randomClassIndex));</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                                JobInfo newJobInfo = new JobInfo(newJob);</TD></TR><TR><TD CLASS="l">663</TD><TD>                                </TD></TR><TR><TD CLASS="l">664</TD><TD>                                // Signals to node jobInfoList otherwise measures and Load dependent code are wrong</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>                                this.getOwnerNode().getJobInfoList().add(newJobInfo);</TD></TR><TR><TD CLASS="l">666</TD><TD>                                // Adds this job to the queue jobinfolist</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                                queueJobInfoList.add(newJobInfo);</TD></TR><TR><TD CLASS="l">668</TD><TD> </TD></TR><TR><TD CLASS="l">669</TD><TD>                                //job has been added: decrease class e total counters</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                                residualClassJobs[randomClassIndex]--;</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>                                totJobs--;</TD></TR><TR><TD CLASS="l">672</TD><TD>                                </TD></TR><TR><TD CLASS="l">673</TD><TD>                                // Signals to global jobInfoList new added job - Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                                this.getOwnerNode().getQueueNet().getJobInfoList().addJob(newJob);</TD></TR><TR><TD CLASS="l">675</TD><TD>                                </TD></TR><TR><TD CLASS="l">676</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">677</TD><TD>                        }</TD></TR><TR><TD CLASS="l">678</TD><TD> </TD></TR><TR><TD CLASS="l">679</TD><TD>                        //else no other jobs of this class must be added</TD></TR><TR><TD CLASS="l">680</TD><TD> </TD></TR><TR><TD CLASS="l">681</TD><TD>                        //continue</TD></TR><TR><TD CLASS="l">682</TD><TD> </TD></TR><TR><TD CLASS="l">683</TD><TD>                }</TD></TR><TR><TD CLASS="l">684</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>        }</TD></TR><TR><TD CLASS="l">686</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="8.html">jmt.engine.NodeSections</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>