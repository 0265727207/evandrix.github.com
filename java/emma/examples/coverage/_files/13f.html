<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1f.html">jmt.engine.math</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Probability.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Probability.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/1118)</TD><TD CLASS="h">0%   (0/168)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Probability</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/1118)</TD><TD CLASS="h">0%   (0/168)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/207)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">Probability (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#3">beta (double, double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">betaComplemented (double, double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5">binomial (int, int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">binomialComplemented (int, int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#7">chiSquare (double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">chiSquareComplemented (double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9">errorFunction (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">errorFunctionComplemented (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/220)</TD><TD CLASS="h">0%   (0/28)</TD></TR><TR><TD CLASS="f"><A HREF="#b">gamma (double, double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">gammaComplemented (double, double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#d">negativeBinomial (int, int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">negativeBinomialComplemented (int, int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#f">normal (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">normal (double, double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#11">normalInverse (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/124)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">poisson (int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#13">poissonComplemented (int, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">studentT (double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#15">studentTInverse (double, int): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/131)</TD><TD CLASS="h">0%   (0/31)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/*</TD></TR><TR><TD CLASS="l">2</TD><TD>Copyright © 1999 CERN - European Organization for Nuclear Research.</TD></TR><TR><TD CLASS="l">3</TD><TD>Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose</TD></TR><TR><TD CLASS="l">4</TD><TD>is hereby granted without fee, provided that the above copyright notice appear in all copies and</TD></TR><TR><TD CLASS="l">5</TD><TD>that both that copyright notice and this permission notice appear in supporting documentation.</TD></TR><TR><TD CLASS="l">6</TD><TD>CERN makes no representations about the suitability of this software for any purpose.</TD></TR><TR><TD CLASS="l">7</TD><TD>It is provided &#34;as is&#34; without expressed or implied warranty.</TD></TR><TR><TD CLASS="l">8</TD><TD>*/</TD></TR><TR><TD CLASS="l">9</TD><TD>package jmt.engine.math;</TD></TR><TR><TD CLASS="l">10</TD><TD> </TD></TR><TR><TD CLASS="l">11</TD><TD>/**</TD></TR><TR><TD CLASS="l">12</TD><TD> * Custom tailored numerical integration of certain probability distributions.</TD></TR><TR><TD CLASS="l">13</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">14</TD><TD> * &lt;b&gt;Implementation:&lt;/b&gt;</TD></TR><TR><TD CLASS="l">15</TD><TD> * &lt;dt&gt;</TD></TR><TR><TD CLASS="l">16</TD><TD> * Some code taken and adapted from the &lt;A HREF=&#34;http://www.sci.usq.edu.au/staff/leighb/graph/Top.html&#34;&gt;Java 2D Graph Package 2.4&lt;/A&gt;,</TD></TR><TR><TD CLASS="l">17</TD><TD> * which in turn is a port from the &lt;A HREF=&#34;http://people.ne.mediaone.net/moshier/index.html#Cephes&#34;&gt;Cephes 2.2&lt;/A&gt; Math Library (C).</TD></TR><TR><TD CLASS="l">18</TD><TD> * Most Cephes code (missing from the 2D Graph Package) directly ported.</TD></TR><TR><TD CLASS="l">19</TD><TD> *</TD></TR><TR><TD CLASS="l">20</TD><TD> * @author peter.gedeck@pharma.Novartis.com</TD></TR><TR><TD CLASS="l">21</TD><TD> * @author wolfgang.hoschek@cern.ch</TD></TR><TR><TD CLASS="l">22</TD><TD> * @version 0.91, 08-Dec-99</TD></TR><TR><TD CLASS="l">23</TD><TD> */</TD></TR><TR><TD CLASS="l">24</TD><TD>public class Probability extends Constants {</TD></TR><TR><TD CLASS="l"><A NAME="0">25</A></TD><TD>        /*************************************************</TD></TR><TR><TD CLASS="l">26</TD><TD>         *    COEFFICIENTS FOR METHOD  normalInverse()   *</TD></TR><TR><TD CLASS="l">27</TD><TD>         *************************************************/</TD></TR><TR><TD CLASS="l">28</TD><TD>        /* approximation for 0 &lt;= |y - 0.5| &lt;= 3/8 */</TD></TR><TR CLASS="z"><TD CLASS="l">29</TD><TD>        protected static final double P0[] = { -5.99633501014107895267E1, 9.80010754185999661536E1, -5.66762857469070293439E1, 1.39312609387279679503E1,</TD></TR><TR><TD CLASS="l">30</TD><TD>                        -1.23916583867381258016E0, };</TD></TR><TR CLASS="z"><TD CLASS="l">31</TD><TD>        protected static final double Q0[] = {/* 1.00000000000000000000E0,*/</TD></TR><TR><TD CLASS="l">32</TD><TD>        1.95448858338141759834E0, 4.67627912898881538453E0, 8.63602421390890590575E1, -2.25462687854119370527E2, 2.00260212380060660359E2,</TD></TR><TR><TD CLASS="l">33</TD><TD>                        -8.20372256168333339912E1, 1.59056225126211695515E1, -1.18331621121330003142E0, };</TD></TR><TR><TD CLASS="l">34</TD><TD> </TD></TR><TR><TD CLASS="l">35</TD><TD>        /* Approximation for interval z = sqrt(-2 getLog y ) between 2 and 8</TD></TR><TR><TD CLASS="l">36</TD><TD>         * i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.</TD></TR><TR><TD CLASS="l">37</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">38</TD><TD>        protected static final double P1[] = { 4.05544892305962419923E0, 3.15251094599893866154E1, 5.71628192246421288162E1, 4.40805073893200834700E1,</TD></TR><TR><TD CLASS="l">39</TD><TD>                        1.46849561928858024014E1, 2.18663306850790267539E0, -1.40256079171354495875E-1, -3.50424626827848203418E-2, -8.57456785154685413611E-4, };</TD></TR><TR CLASS="z"><TD CLASS="l">40</TD><TD>        protected static final double Q1[] = {/*  1.00000000000000000000E0,*/</TD></TR><TR><TD CLASS="l">41</TD><TD>        1.57799883256466749731E1, 4.53907635128879210584E1, 4.13172038254672030440E1, 1.50425385692907503408E1, 2.50464946208309415979E0,</TD></TR><TR><TD CLASS="l">42</TD><TD>                        -1.42182922854787788574E-1, -3.80806407691578277194E-2, -9.33259480895457427372E-4, };</TD></TR><TR><TD CLASS="l">43</TD><TD> </TD></TR><TR><TD CLASS="l">44</TD><TD>        /* Approximation for interval z = sqrt(-2 getLog y ) between 8 and 64</TD></TR><TR><TD CLASS="l">45</TD><TD>         * i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.</TD></TR><TR><TD CLASS="l">46</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">47</TD><TD>        protected static final double P2[] = { 3.23774891776946035970E0, 6.91522889068984211695E0, 3.93881025292474443415E0, 1.33303460815807542389E0,</TD></TR><TR><TD CLASS="l">48</TD><TD>                        2.01485389549179081538E-1, 1.23716634817820021358E-2, 3.01581553508235416007E-4, 2.65806974686737550832E-6, 6.23974539184983293730E-9, };</TD></TR><TR CLASS="z"><TD CLASS="l">49</TD><TD>        protected static final double Q2[] = {/*  1.00000000000000000000E0,*/</TD></TR><TR><TD CLASS="l">50</TD><TD>        6.02427039364742014255E0, 3.67983563856160859403E0, 1.37702099489081330271E0, 2.16236993594496635890E-1, 1.34204006088543189037E-2,</TD></TR><TR><TD CLASS="l">51</TD><TD>                        3.28014464682127739104E-4, 2.89247864745380683936E-6, 6.79019408009981274425E-9, };</TD></TR><TR><TD CLASS="l"><A NAME="2">52</A></TD><TD> </TD></TR><TR><TD CLASS="l">53</TD><TD>        /**</TD></TR><TR><TD CLASS="l">54</TD><TD>         * Makes this class non instantiable, but still let's others inherit from it.</TD></TR><TR><TD CLASS="l">55</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">56</TD><TD>        protected Probability() {</TD></TR><TR CLASS="z"><TD CLASS="l">57</TD><TD>        }</TD></TR><TR><TD CLASS="l">58</TD><TD> </TD></TR><TR><TD CLASS="l">59</TD><TD>        /**</TD></TR><TR><TD CLASS="l">60</TD><TD>         * Returns the area from zero to &lt;tt&gt;x&lt;/tt&gt; under the beta density</TD></TR><TR><TD CLASS="l">61</TD><TD>         * function.</TD></TR><TR><TD CLASS="l">62</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">63</TD><TD>         *                          x</TD></TR><TR><TD CLASS="l">64</TD><TD>         *            -             -</TD></TR><TR><TD CLASS="l">65</TD><TD>         *           | (a+b)       | |  a-1      b-1</TD></TR><TR><TD CLASS="l">66</TD><TD>         * P(x)  =  ----------     |   t    (1-t)    dt</TD></TR><TR><TD CLASS="l">67</TD><TD>         *           -     -     | |</TD></TR><TR><TD CLASS="l">68</TD><TD>         *          | (a) | (b)   -</TD></TR><TR><TD CLASS="l">69</TD><TD>         *                         0</TD></TR><TR><TD CLASS="l">70</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">71</TD><TD>         * This function is identical to the incomplete beta</TD></TR><TR><TD CLASS="l">72</TD><TD>         * integral function &lt;tt&gt;Gamma.incompleteBeta(a, b, x)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">73</TD><TD>         *</TD></TR><TR><TD CLASS="l">74</TD><TD>         * The complemented function is</TD></TR><TR><TD CLASS="l">75</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="3">76</A></TD><TD>         * &lt;tt&gt;1 - P(1-x)  =  Gamma.incompleteBeta( b, a, x )&lt;/tt&gt;;</TD></TR><TR><TD CLASS="l">77</TD><TD>         *</TD></TR><TR><TD CLASS="l">78</TD><TD>         */</TD></TR><TR><TD CLASS="l">79</TD><TD>        static public double beta(double a, double b, double x) {</TD></TR><TR CLASS="z"><TD CLASS="l">80</TD><TD>                return Gamma.incompleteBeta(a, b, x);</TD></TR><TR><TD CLASS="l">81</TD><TD>        }</TD></TR><TR><TD CLASS="l">82</TD><TD> </TD></TR><TR><TD CLASS="l">83</TD><TD>        /**</TD></TR><TR><TD CLASS="l">84</TD><TD>         * Returns the area under the right hand tail (from &lt;tt&gt;x&lt;/tt&gt; to</TD></TR><TR><TD CLASS="l">85</TD><TD>         * infinity) of the beta density function.</TD></TR><TR><TD CLASS="l">86</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="4">87</A></TD><TD>         * This function is identical to the incomplete beta</TD></TR><TR><TD CLASS="l">88</TD><TD>         * integral function &lt;tt&gt;Gamma.incompleteBeta(b, a, x)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">89</TD><TD>         */</TD></TR><TR><TD CLASS="l">90</TD><TD>        static public double betaComplemented(double a, double b, double x) {</TD></TR><TR CLASS="z"><TD CLASS="l">91</TD><TD>                return Gamma.incompleteBeta(b, a, x);</TD></TR><TR><TD CLASS="l">92</TD><TD>        }</TD></TR><TR><TD CLASS="l">93</TD><TD> </TD></TR><TR><TD CLASS="l">94</TD><TD>        /**</TD></TR><TR><TD CLASS="l">95</TD><TD>         * Returns the sum of the terms &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;k&lt;/tt&gt; of the Binomial</TD></TR><TR><TD CLASS="l">96</TD><TD>         * probability density.</TD></TR><TR><TD CLASS="l">97</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">98</TD><TD>         *   k</TD></TR><TR><TD CLASS="l">99</TD><TD>         *   --  ( n )   j      n-j</TD></TR><TR><TD CLASS="l">100</TD><TD>         *   &gt;   (   )  p  (1-p)</TD></TR><TR><TD CLASS="l">101</TD><TD>         *   --  ( j )</TD></TR><TR><TD CLASS="l">102</TD><TD>         *  j=0</TD></TR><TR><TD CLASS="l">103</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">104</TD><TD>         * The terms are not summed directly; instead the incomplete</TD></TR><TR><TD CLASS="l">105</TD><TD>         * beta integral is employed, according to the formula</TD></TR><TR><TD CLASS="l">106</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">107</TD><TD>         * &lt;tt&gt;y = binomial( k, n, p ) = Gamma.incompleteBeta( n-k, k+1, 1-p )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">108</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">109</TD><TD>         * All arguments must be positive,</TD></TR><TR><TD CLASS="l">110</TD><TD>         * @param k end term.</TD></TR><TR><TD CLASS="l"><A NAME="5">111</A></TD><TD>         * @param n the number of trials.</TD></TR><TR><TD CLASS="l">112</TD><TD>         * @param p the probability of success (must be in &lt;tt&gt;(0.0,1.0)&lt;/tt&gt;).</TD></TR><TR><TD CLASS="l">113</TD><TD>         */</TD></TR><TR><TD CLASS="l">114</TD><TD>        static public double binomial(int k, int n, double p) {</TD></TR><TR CLASS="z"><TD CLASS="l">115</TD><TD>                if ((p &lt; 0.0) || (p &gt; 1.0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">117</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>                if ((k &lt; 0) || (n &lt; k)) {</TD></TR><TR CLASS="z"><TD CLASS="l">119</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">120</TD><TD>                }</TD></TR><TR><TD CLASS="l">121</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">122</TD><TD>                if (k == n) {</TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>                        return (1.0);</TD></TR><TR><TD CLASS="l">124</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">125</TD><TD>                if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>                        return Math.pow(1.0 - p, n - k);</TD></TR><TR><TD CLASS="l">127</TD><TD>                }</TD></TR><TR><TD CLASS="l">128</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">129</TD><TD>                return Gamma.incompleteBeta(n - k, k + 1, 1.0 - p);</TD></TR><TR><TD CLASS="l">130</TD><TD>        }</TD></TR><TR><TD CLASS="l">131</TD><TD> </TD></TR><TR><TD CLASS="l">132</TD><TD>        /**</TD></TR><TR><TD CLASS="l">133</TD><TD>         * Returns the sum of the terms &lt;tt&gt;k+1&lt;/tt&gt; through &lt;tt&gt;n&lt;/tt&gt; of the Binomial</TD></TR><TR><TD CLASS="l">134</TD><TD>         * probability density.</TD></TR><TR><TD CLASS="l">135</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">136</TD><TD>         *   n</TD></TR><TR><TD CLASS="l">137</TD><TD>         *   --  ( n )   j      n-j</TD></TR><TR><TD CLASS="l">138</TD><TD>         *   &gt;   (   )  p  (1-p)</TD></TR><TR><TD CLASS="l">139</TD><TD>         *   --  ( j )</TD></TR><TR><TD CLASS="l">140</TD><TD>         *  j=k+1</TD></TR><TR><TD CLASS="l">141</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">142</TD><TD>         * The terms are not summed directly; instead the incomplete</TD></TR><TR><TD CLASS="l">143</TD><TD>         * beta integral is employed, according to the formula</TD></TR><TR><TD CLASS="l">144</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">145</TD><TD>         * &lt;tt&gt;y = binomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n-k, p )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">146</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">147</TD><TD>         * All arguments must be positive,</TD></TR><TR><TD CLASS="l">148</TD><TD>         * @param k end term.</TD></TR><TR><TD CLASS="l"><A NAME="6">149</A></TD><TD>         * @param n the number of trials.</TD></TR><TR><TD CLASS="l">150</TD><TD>         * @param p the probability of success (must be in &lt;tt&gt;(0.0,1.0)&lt;/tt&gt;).</TD></TR><TR><TD CLASS="l">151</TD><TD>         */</TD></TR><TR><TD CLASS="l">152</TD><TD>        static public double binomialComplemented(int k, int n, double p) {</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                if ((p &lt; 0.0) || (p &gt; 1.0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">155</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                if ((k &lt; 0) || (n &lt; k)) {</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">158</TD><TD>                }</TD></TR><TR><TD CLASS="l">159</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>                if (k == n) {</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                        return (0.0);</TD></TR><TR><TD CLASS="l">162</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>                        return 1.0 - Math.pow(1.0 - p, n - k);</TD></TR><TR><TD CLASS="l">165</TD><TD>                }</TD></TR><TR><TD CLASS="l">166</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>                return Gamma.incompleteBeta(k + 1, n - k, p);</TD></TR><TR><TD CLASS="l">168</TD><TD>        }</TD></TR><TR><TD CLASS="l">169</TD><TD> </TD></TR><TR><TD CLASS="l">170</TD><TD>        /**</TD></TR><TR><TD CLASS="l">171</TD><TD>         * Returns the area under the left hand tail (from 0 to &lt;tt&gt;x&lt;/tt&gt;)</TD></TR><TR><TD CLASS="l">172</TD><TD>         * of the Chi square probability density function with</TD></TR><TR><TD CLASS="l">173</TD><TD>         * &lt;tt&gt;v&lt;/tt&gt; degrees of freedom.</TD></TR><TR><TD CLASS="l">174</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">175</TD><TD>         *                                  inf.</TD></TR><TR><TD CLASS="l">176</TD><TD>         *                                    -</TD></TR><TR><TD CLASS="l">177</TD><TD>         *                        1          | |  v/2-1  -t/2</TD></TR><TR><TD CLASS="l">178</TD><TD>         *  P( x | v )   =   -----------     |   t      e     dt</TD></TR><TR><TD CLASS="l">179</TD><TD>         *                    v/2  -       | |</TD></TR><TR><TD CLASS="l">180</TD><TD>         *                   2    | (v/2)   -</TD></TR><TR><TD CLASS="l">181</TD><TD>         *                                   x</TD></TR><TR><TD CLASS="l">182</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">183</TD><TD>         * where &lt;tt&gt;x&lt;/tt&gt; is the Chi-square variable.</TD></TR><TR><TD CLASS="l">184</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">185</TD><TD>         * The incomplete gamma integral is used, according to the</TD></TR><TR><TD CLASS="l">186</TD><TD>         * formula</TD></TR><TR><TD CLASS="l">187</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">188</TD><TD>         * &lt;tt&gt;y = chiSquare( v, x ) = incompleteGamma( v/2.0, x/2.0 )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">189</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">190</TD><TD>         * The arguments must both be positive.</TD></TR><TR><TD CLASS="l">191</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="7">192</A></TD><TD>         * @param v degrees of freedom.</TD></TR><TR><TD CLASS="l">193</TD><TD>         * @param x integration end point.</TD></TR><TR><TD CLASS="l">194</TD><TD>         */</TD></TR><TR><TD CLASS="l">195</TD><TD>        static public double chiSquare(double v, double x) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>                if (x &lt; 0.0 || v &lt; 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">198</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">199</TD><TD>                return Gamma.incompleteGamma(v / 2.0, x / 2.0);</TD></TR><TR><TD CLASS="l">200</TD><TD>        }</TD></TR><TR><TD CLASS="l">201</TD><TD> </TD></TR><TR><TD CLASS="l">202</TD><TD>        /**</TD></TR><TR><TD CLASS="l">203</TD><TD>         * Returns the area under the right hand tail (from &lt;tt&gt;x&lt;/tt&gt; to</TD></TR><TR><TD CLASS="l">204</TD><TD>         * infinity) of the Chi square probability density function</TD></TR><TR><TD CLASS="l">205</TD><TD>         * with &lt;tt&gt;v&lt;/tt&gt; degrees of freedom.</TD></TR><TR><TD CLASS="l">206</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">207</TD><TD>         *                                  inf.</TD></TR><TR><TD CLASS="l">208</TD><TD>         *                                    -</TD></TR><TR><TD CLASS="l">209</TD><TD>         *                        1          | |  v/2-1  -t/2</TD></TR><TR><TD CLASS="l">210</TD><TD>         *  P( x | v )   =   -----------     |   t      e     dt</TD></TR><TR><TD CLASS="l">211</TD><TD>         *                    v/2  -       | |</TD></TR><TR><TD CLASS="l">212</TD><TD>         *                   2    | (v/2)   -</TD></TR><TR><TD CLASS="l">213</TD><TD>         *                                   x</TD></TR><TR><TD CLASS="l">214</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">215</TD><TD>         * where &lt;tt&gt;x&lt;/tt&gt; is the Chi-square variable.</TD></TR><TR><TD CLASS="l">216</TD><TD>         *</TD></TR><TR><TD CLASS="l">217</TD><TD>         * The incomplete gamma integral is used, according to the</TD></TR><TR><TD CLASS="l">218</TD><TD>         * formula</TD></TR><TR><TD CLASS="l">219</TD><TD>         *</TD></TR><TR><TD CLASS="l">220</TD><TD>         * &lt;tt&gt;y = chiSquareComplemented( v, x ) = incompleteGammaComplement( v/2.0, x/2.0 )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">221</TD><TD>         *</TD></TR><TR><TD CLASS="l">222</TD><TD>         *</TD></TR><TR><TD CLASS="l">223</TD><TD>         * The arguments must both be positive.</TD></TR><TR><TD CLASS="l"><A NAME="8">224</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">225</TD><TD>         * @param v degrees of freedom.</TD></TR><TR><TD CLASS="l">226</TD><TD>         */</TD></TR><TR><TD CLASS="l">227</TD><TD>        static public double chiSquareComplemented(double v, double x) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">228</TD><TD>                if (x &lt; 0.0 || v &lt; 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">230</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">231</TD><TD>                return Gamma.incompleteGammaComplement(v / 2.0, x / 2.0);</TD></TR><TR><TD CLASS="l">232</TD><TD>        }</TD></TR><TR><TD CLASS="l">233</TD><TD> </TD></TR><TR><TD CLASS="l">234</TD><TD>        /**</TD></TR><TR><TD CLASS="l">235</TD><TD>         * Returns the error function of the normal distribution; formerly named &lt;tt&gt;erf&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">236</TD><TD>         * The integral is</TD></TR><TR><TD CLASS="l">237</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">238</TD><TD>         *                           x</TD></TR><TR><TD CLASS="l">239</TD><TD>         *                            -</TD></TR><TR><TD CLASS="l">240</TD><TD>         *                 2         | |          2</TD></TR><TR><TD CLASS="l">241</TD><TD>         *   erf(x)  =  --------     |    exp( - t  ) dt.</TD></TR><TR><TD CLASS="l">242</TD><TD>         *              sqrt(pi)   | |</TD></TR><TR><TD CLASS="l">243</TD><TD>         *                          -</TD></TR><TR><TD CLASS="l">244</TD><TD>         *                           0</TD></TR><TR><TD CLASS="l">245</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">246</TD><TD>         * &lt;b&gt;Implementation:&lt;/b&gt;</TD></TR><TR><TD CLASS="l">247</TD><TD>         * For &lt;tt&gt;0 &lt;= |x| &lt; 1, erf(x) = x * P4(x**2)/Q5(x**2)&lt;/tt&gt;; otherwise</TD></TR><TR><TD CLASS="l">248</TD><TD>         * &lt;tt&gt;erf(x) = 1 - erfc(x)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">249</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">250</TD><TD>         * Code adapted from the &lt;A HREF=&#34;http://www.sci.usq.edu.au/staff/leighb/graph/Top.html&#34;&gt;Java 2D Graph Package 2.4&lt;/A&gt;,</TD></TR><TR><TD CLASS="l">251</TD><TD>         * which in turn is a port from the &lt;A HREF=&#34;http://people.ne.mediaone.net/moshier/index.html#Cephes&#34;&gt;Cephes 2.2&lt;/A&gt; Math Library (C).</TD></TR><TR><TD CLASS="l">252</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="9">253</A></TD><TD>         * @param a the argument to the function.</TD></TR><TR><TD CLASS="l">254</TD><TD>         */</TD></TR><TR><TD CLASS="l">255</TD><TD>        static public double errorFunction(double x) throws ArithmeticException {</TD></TR><TR><TD CLASS="l">256</TD><TD>                double y, z;</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                final double T[] = { 9.60497373987051638749E0, 9.00260197203842689217E1, 2.23200534594684319226E3, 7.00332514112805075473E3,</TD></TR><TR><TD CLASS="l">258</TD><TD>                                5.55923013010394962768E4 };</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                final double U[] = {//1.00000000000000000000E0,</TD></TR><TR><TD CLASS="l">260</TD><TD>                3.35617141647503099647E1, 5.21357949780152679795E2, 4.59432382970980127987E3, 2.26290000613890934246E4, 4.92673942608635921086E4 };</TD></TR><TR><TD CLASS="l">261</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                if (Math.abs(x) &gt; 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                        return (1.0 - errorFunctionComplemented(x));</TD></TR><TR><TD CLASS="l">264</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>                z = x * x;</TD></TR><TR CLASS="z"><TD CLASS="l">266</TD><TD>                y = x * Polynomial.polevl(z, T, 4) / Polynomial.p1evl(z, U, 5);</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                return y;</TD></TR><TR><TD CLASS="l">268</TD><TD>        }</TD></TR><TR><TD CLASS="l">269</TD><TD> </TD></TR><TR><TD CLASS="l">270</TD><TD>        /**</TD></TR><TR><TD CLASS="l">271</TD><TD>         * Returns the complementary Error function of the normal distribution; formerly named &lt;tt&gt;erfc&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">272</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">273</TD><TD>         *  1 - erf(x) =</TD></TR><TR><TD CLASS="l">274</TD><TD>         *</TD></TR><TR><TD CLASS="l">275</TD><TD>         *                           inf.</TD></TR><TR><TD CLASS="l">276</TD><TD>         *                             -</TD></TR><TR><TD CLASS="l">277</TD><TD>         *                  2         | |          2</TD></TR><TR><TD CLASS="l">278</TD><TD>         *   erfc(x)  =  --------     |    exp( - t  ) dt</TD></TR><TR><TD CLASS="l">279</TD><TD>         *               sqrt(pi)   | |</TD></TR><TR><TD CLASS="l">280</TD><TD>         *                           -</TD></TR><TR><TD CLASS="l">281</TD><TD>         *                            x</TD></TR><TR><TD CLASS="l">282</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">283</TD><TD>         * &lt;b&gt;Implementation:&lt;/b&gt;</TD></TR><TR><TD CLASS="l">284</TD><TD>         * For small x, &lt;tt&gt;erfc(x) = 1 - erf(x)&lt;/tt&gt;; otherwise rational</TD></TR><TR><TD CLASS="l">285</TD><TD>         * approximations are computed.</TD></TR><TR><TD CLASS="l">286</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">287</TD><TD>         * Code adapted from the &lt;A HREF=&#34;http://www.sci.usq.edu.au/staff/leighb/graph/Top.html&#34;&gt;Java 2D Graph Package 2.4&lt;/A&gt;,</TD></TR><TR><TD CLASS="l">288</TD><TD>         * which in turn is a port from the &lt;A HREF=&#34;http://people.ne.mediaone.net/moshier/index.html#Cephes&#34;&gt;Cephes 2.2&lt;/A&gt; Math Library (C).</TD></TR><TR><TD CLASS="l">289</TD><TD>         *</TD></TR><TR><TD CLASS="l">290</TD><TD>         * @param a the argument to the function.</TD></TR><TR><TD CLASS="l"><A NAME="a">291</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">292</TD><TD>        static public double errorFunctionComplemented(double a) throws ArithmeticException {</TD></TR><TR><TD CLASS="l">293</TD><TD>                double x, y, z, p, q;</TD></TR><TR><TD CLASS="l">294</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                double P[] = { 2.46196981473530512524E-10, 5.64189564831068821977E-1, 7.46321056442269912687E0, 4.86371970985681366614E1,</TD></TR><TR><TD CLASS="l">296</TD><TD>                                1.96520832956077098242E2, 5.26445194995477358631E2, 9.34528527171957607540E2, 1.02755188689515710272E3, 5.57535335369399327526E2 };</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                double Q[] = {//1.0</TD></TR><TR><TD CLASS="l">298</TD><TD>                1.32281951154744992508E1, 8.67072140885989742329E1, 3.54937778887819891062E2, 9.75708501743205489753E2, 1.82390916687909736289E3,</TD></TR><TR><TD CLASS="l">299</TD><TD>                                2.24633760818710981792E3, 1.65666309194161350182E3, 5.57535340817727675546E2 };</TD></TR><TR><TD CLASS="l">300</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>                double R[] = { 5.64189583547755073984E-1, 1.27536670759978104416E0, 5.01905042251180477414E0, 6.16021097993053585195E0,</TD></TR><TR><TD CLASS="l">302</TD><TD>                                7.40974269950448939160E0, 2.97886665372100240670E0 };</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                double S[] = {//1.00000000000000000000E0,</TD></TR><TR><TD CLASS="l">304</TD><TD>                2.26052863220117276590E0, 9.39603524938001434673E0, 1.20489539808096656605E1, 1.70814450747565897222E1, 9.60896809063285878198E0,</TD></TR><TR><TD CLASS="l">305</TD><TD>                                3.36907645100081516050E0 };</TD></TR><TR><TD CLASS="l">306</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>                if (a &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>                        x = -a;</TD></TR><TR><TD CLASS="l">309</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>                        x = a;</TD></TR><TR><TD CLASS="l">311</TD><TD>                }</TD></TR><TR><TD CLASS="l">312</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                if (x &lt; 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                        return 1.0 - errorFunction(a);</TD></TR><TR><TD CLASS="l">315</TD><TD>                }</TD></TR><TR><TD CLASS="l">316</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                z = -a * a;</TD></TR><TR><TD CLASS="l">318</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                if (z &lt; -MAXLOG) {</TD></TR><TR CLASS="z"><TD CLASS="l">320</TD><TD>                        if (a &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                                return (2.0);</TD></TR><TR><TD CLASS="l">322</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                                return (0.0);</TD></TR><TR><TD CLASS="l">324</TD><TD>                        }</TD></TR><TR><TD CLASS="l">325</TD><TD>                }</TD></TR><TR><TD CLASS="l">326</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                z = Math.exp(z);</TD></TR><TR><TD CLASS="l">328</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                if (x &lt; 8.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                        p = Polynomial.polevl(x, P, 8);</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                        q = Polynomial.p1evl(x, Q, 8);</TD></TR><TR><TD CLASS="l">332</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                        p = Polynomial.polevl(x, R, 5);</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                        q = Polynomial.p1evl(x, S, 6);</TD></TR><TR><TD CLASS="l">335</TD><TD>                }</TD></TR><TR><TD CLASS="l">336</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                y = (z * p) / q;</TD></TR><TR><TD CLASS="l">338</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>                if (a &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                        y = 2.0 - y;</TD></TR><TR><TD CLASS="l">341</TD><TD>                }</TD></TR><TR><TD CLASS="l">342</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                if (y == 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                        if (a &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                                return 2.0;</TD></TR><TR><TD CLASS="l">346</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                                return (0.0);</TD></TR><TR><TD CLASS="l">348</TD><TD>                        }</TD></TR><TR><TD CLASS="l">349</TD><TD>                }</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                return y;</TD></TR><TR><TD CLASS="l">352</TD><TD>        }</TD></TR><TR><TD CLASS="l">353</TD><TD> </TD></TR><TR><TD CLASS="l">354</TD><TD>        /**</TD></TR><TR><TD CLASS="l">355</TD><TD>         * Returns the integral from zero to &lt;tt&gt;x&lt;/tt&gt; of the gamma probability</TD></TR><TR><TD CLASS="l">356</TD><TD>         * density function.</TD></TR><TR><TD CLASS="l">357</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">358</TD><TD>         *                x</TD></TR><TR><TD CLASS="l">359</TD><TD>         *        b       -</TD></TR><TR><TD CLASS="l">360</TD><TD>         *       a       | |   b-1  -at</TD></TR><TR><TD CLASS="l">361</TD><TD>         * y =  -----    |    t    e    dt</TD></TR><TR><TD CLASS="l">362</TD><TD>         *       -     | |</TD></TR><TR><TD CLASS="l">363</TD><TD>         *      | (b)   -</TD></TR><TR><TD CLASS="l">364</TD><TD>         *               0</TD></TR><TR><TD CLASS="l">365</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">366</TD><TD>         * The incomplete gamma integral is used, according to the</TD></TR><TR><TD CLASS="l">367</TD><TD>         * relation</TD></TR><TR><TD CLASS="l">368</TD><TD>         *</TD></TR><TR><TD CLASS="l">369</TD><TD>         * &lt;tt&gt;y = Gamma.incompleteGamma( b, a*x )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">370</TD><TD>         *</TD></TR><TR><TD CLASS="l">371</TD><TD>         * @param a the paramater a (alpha) of the gamma distribution.</TD></TR><TR><TD CLASS="l"><A NAME="b">372</A></TD><TD>         * @param b the paramater b (beta, lambda) of the gamma distribution.</TD></TR><TR><TD CLASS="l">373</TD><TD>         * @param x integration end point.</TD></TR><TR><TD CLASS="l">374</TD><TD>         */</TD></TR><TR><TD CLASS="l">375</TD><TD>        static public double gamma(double a, double b, double x) {</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                if (x &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">378</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                return Gamma.incompleteGamma(b, a * x);</TD></TR><TR><TD CLASS="l">380</TD><TD>        }</TD></TR><TR><TD CLASS="l">381</TD><TD> </TD></TR><TR><TD CLASS="l">382</TD><TD>        /**</TD></TR><TR><TD CLASS="l">383</TD><TD>         * Returns the integral from &lt;tt&gt;x&lt;/tt&gt; to infinity of the gamma</TD></TR><TR><TD CLASS="l">384</TD><TD>         * probability density function:</TD></TR><TR><TD CLASS="l">385</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">386</TD><TD>         *               inf.</TD></TR><TR><TD CLASS="l">387</TD><TD>         *        b       -</TD></TR><TR><TD CLASS="l">388</TD><TD>         *       a       | |   b-1  -at</TD></TR><TR><TD CLASS="l">389</TD><TD>         * y =  -----    |    t    e    dt</TD></TR><TR><TD CLASS="l">390</TD><TD>         *       -     | |</TD></TR><TR><TD CLASS="l">391</TD><TD>         *      | (b)   -</TD></TR><TR><TD CLASS="l">392</TD><TD>         *               x</TD></TR><TR><TD CLASS="l">393</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">394</TD><TD>         * The incomplete gamma integral is used, according to the</TD></TR><TR><TD CLASS="l">395</TD><TD>         * relation</TD></TR><TR><TD CLASS="l">396</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">397</TD><TD>         * y = Gamma.incompleteGammaComplement( b, a*x ).</TD></TR><TR><TD CLASS="l">398</TD><TD>         *</TD></TR><TR><TD CLASS="l">399</TD><TD>         * @param a the paramater a (alpha) of the gamma distribution.</TD></TR><TR><TD CLASS="l"><A NAME="c">400</A></TD><TD>         * @param b the paramater b (beta, lambda) of the gamma distribution.</TD></TR><TR><TD CLASS="l">401</TD><TD>         * @param x integration end point.</TD></TR><TR><TD CLASS="l">402</TD><TD>         */</TD></TR><TR><TD CLASS="l">403</TD><TD>        static public double gammaComplemented(double a, double b, double x) {</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>                if (x &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">405</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">406</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">407</TD><TD>                return Gamma.incompleteGammaComplement(b, a * x);</TD></TR><TR><TD CLASS="l">408</TD><TD>        }</TD></TR><TR><TD CLASS="l">409</TD><TD> </TD></TR><TR><TD CLASS="l">410</TD><TD>        /**</TD></TR><TR><TD CLASS="l">411</TD><TD>         * Returns the sum of the terms &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;k&lt;/tt&gt; of the Negative Binomial Distribution.</TD></TR><TR><TD CLASS="l">412</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">413</TD><TD>         *   k</TD></TR><TR><TD CLASS="l">414</TD><TD>         *   --  ( n+j-1 )   n      j</TD></TR><TR><TD CLASS="l">415</TD><TD>         *   &gt;   (       )  p  (1-p)</TD></TR><TR><TD CLASS="l">416</TD><TD>         *   --  (   j   )</TD></TR><TR><TD CLASS="l">417</TD><TD>         *  j=0</TD></TR><TR><TD CLASS="l">418</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">419</TD><TD>         * In a sequence of Bernoulli trials, this is the probability</TD></TR><TR><TD CLASS="l">420</TD><TD>         * that &lt;tt&gt;k&lt;/tt&gt; or fewer failures precede the &lt;tt&gt;n&lt;/tt&gt;-th success.</TD></TR><TR><TD CLASS="l">421</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">422</TD><TD>         * The terms are not computed individually; instead the incomplete</TD></TR><TR><TD CLASS="l">423</TD><TD>         * beta integral is employed, according to the formula</TD></TR><TR><TD CLASS="l">424</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">425</TD><TD>         * &lt;tt&gt;y = negativeBinomial( k, n, p ) = Gamma.incompleteBeta( n, k+1, p )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">426</TD><TD>         *</TD></TR><TR><TD CLASS="l">427</TD><TD>         * All arguments must be positive,</TD></TR><TR><TD CLASS="l">428</TD><TD>         * @param k end term.</TD></TR><TR><TD CLASS="l"><A NAME="d">429</A></TD><TD>         * @param n the number of trials.</TD></TR><TR><TD CLASS="l">430</TD><TD>         * @param p the probability of success (must be in &lt;tt&gt;(0.0,1.0)&lt;/tt&gt;).</TD></TR><TR><TD CLASS="l">431</TD><TD>         */</TD></TR><TR><TD CLASS="l">432</TD><TD>        static public double negativeBinomial(int k, int n, double p) {</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                if ((p &lt; 0.0) || (p &gt; 1.0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">435</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>                if (k &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">438</TD><TD>                }</TD></TR><TR><TD CLASS="l">439</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                return Gamma.incompleteBeta(n, k + 1, p);</TD></TR><TR><TD CLASS="l">441</TD><TD>        }</TD></TR><TR><TD CLASS="l">442</TD><TD> </TD></TR><TR><TD CLASS="l">443</TD><TD>        /**</TD></TR><TR><TD CLASS="l">444</TD><TD>         * Returns the sum of the terms &lt;tt&gt;k+1&lt;/tt&gt; to infinity of the Negative</TD></TR><TR><TD CLASS="l">445</TD><TD>         * Binomial distribution.</TD></TR><TR><TD CLASS="l">446</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">447</TD><TD>         *   inf</TD></TR><TR><TD CLASS="l">448</TD><TD>         *   --  ( n+j-1 )   n      j</TD></TR><TR><TD CLASS="l">449</TD><TD>         *   &gt;   (       )  p  (1-p)</TD></TR><TR><TD CLASS="l">450</TD><TD>         *   --  (   j   )</TD></TR><TR><TD CLASS="l">451</TD><TD>         *  j=k+1</TD></TR><TR><TD CLASS="l">452</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">453</TD><TD>         * The terms are not computed individually; instead the incomplete</TD></TR><TR><TD CLASS="l">454</TD><TD>         * beta integral is employed, according to the formula</TD></TR><TR><TD CLASS="l">455</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">456</TD><TD>         * y = negativeBinomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n, 1-p ).</TD></TR><TR><TD CLASS="l">457</TD><TD>         *</TD></TR><TR><TD CLASS="l">458</TD><TD>         * All arguments must be positive,</TD></TR><TR><TD CLASS="l">459</TD><TD>         * @param k end term.</TD></TR><TR><TD CLASS="l"><A NAME="e">460</A></TD><TD>         * @param n the number of trials.</TD></TR><TR><TD CLASS="l">461</TD><TD>         * @param p the probability of success (must be in &lt;tt&gt;(0.0,1.0)&lt;/tt&gt;).</TD></TR><TR><TD CLASS="l">462</TD><TD>         */</TD></TR><TR><TD CLASS="l">463</TD><TD>        static public double negativeBinomialComplemented(int k, int n, double p) {</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                if ((p &lt; 0.0) || (p &gt; 1.0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">465</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">466</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>                if (k &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">469</TD><TD>                }</TD></TR><TR><TD CLASS="l">470</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">471</TD><TD>                return Gamma.incompleteBeta(k + 1, n, 1.0 - p);</TD></TR><TR><TD CLASS="l">472</TD><TD>        }</TD></TR><TR><TD CLASS="l">473</TD><TD> </TD></TR><TR><TD CLASS="l">474</TD><TD>        /**</TD></TR><TR><TD CLASS="l">475</TD><TD>         * Returns the area under the Normal (Gaussian) probability density</TD></TR><TR><TD CLASS="l">476</TD><TD>         * function, integrated from minus infinity to &lt;tt&gt;x&lt;/tt&gt; (assumes mean is zero, variance is one).</TD></TR><TR><TD CLASS="l">477</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">478</TD><TD>         *                            x</TD></TR><TR><TD CLASS="l">479</TD><TD>         *                             -</TD></TR><TR><TD CLASS="l">480</TD><TD>         *                   1        | |          2</TD></TR><TR><TD CLASS="l">481</TD><TD>         *  normal(x)  = ---------    |    exp( - t /2 ) dt</TD></TR><TR><TD CLASS="l">482</TD><TD>         *               sqrt(2pi)  | |</TD></TR><TR><TD CLASS="l">483</TD><TD>         *                           -</TD></TR><TR><TD CLASS="l">484</TD><TD>         *                          -inf.</TD></TR><TR><TD CLASS="l">485</TD><TD>         *</TD></TR><TR><TD CLASS="l">486</TD><TD>         *             =  ( 1 + erf(z) ) / 2</TD></TR><TR><TD CLASS="l">487</TD><TD>         *             =  erfc(z) / 2</TD></TR><TR><TD CLASS="l">488</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">489</TD><TD>         * where &lt;tt&gt;z = x/sqrt(2)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">490</TD><TD>         * Computation is via the functions &lt;tt&gt;errorFunction&lt;/tt&gt; and &lt;tt&gt;errorFunctionComplement&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l"><A NAME="f">491</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">492</TD><TD>        static public double normal(double a) throws ArithmeticException {</TD></TR><TR><TD CLASS="l">493</TD><TD>                double x, y, z;</TD></TR><TR><TD CLASS="l">494</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                x = a * SQRTH;</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                z = Math.abs(x);</TD></TR><TR><TD CLASS="l">497</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>                if (z &lt; SQRTH) {</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>                        y = 0.5 + 0.5 * errorFunction(x);</TD></TR><TR><TD CLASS="l">500</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>                        y = 0.5 * errorFunctionComplemented(z);</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>                        if (x &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                                y = 1.0 - y;</TD></TR><TR><TD CLASS="l">504</TD><TD>                        }</TD></TR><TR><TD CLASS="l">505</TD><TD>                }</TD></TR><TR><TD CLASS="l">506</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                return y;</TD></TR><TR><TD CLASS="l">508</TD><TD>        }</TD></TR><TR><TD CLASS="l">509</TD><TD> </TD></TR><TR><TD CLASS="l">510</TD><TD>        /**</TD></TR><TR><TD CLASS="l">511</TD><TD>         * Returns the area under the Normal (Gaussian) probability density</TD></TR><TR><TD CLASS="l">512</TD><TD>         * function, integrated from minus infinity to &lt;tt&gt;x&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">513</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">514</TD><TD>         *                            x</TD></TR><TR><TD CLASS="l">515</TD><TD>         *                             -</TD></TR><TR><TD CLASS="l">516</TD><TD>         *                   1        | |                 2</TD></TR><TR><TD CLASS="l">517</TD><TD>         *  normal(x)  = ---------    |    exp( - (t-mean) / 2v ) dt</TD></TR><TR><TD CLASS="l">518</TD><TD>         *               sqrt(2pi*v)| |</TD></TR><TR><TD CLASS="l">519</TD><TD>         *                           -</TD></TR><TR><TD CLASS="l">520</TD><TD>         *                          -inf.</TD></TR><TR><TD CLASS="l">521</TD><TD>         *</TD></TR><TR><TD CLASS="l">522</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">523</TD><TD>         * where &lt;tt&gt;v = variance&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">524</TD><TD>         * Computation is via the functions &lt;tt&gt;errorFunction&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">525</TD><TD>         *</TD></TR><TR><TD CLASS="l">526</TD><TD>         * @param mean the mean of the normal distribution.</TD></TR><TR><TD CLASS="l"><A NAME="10">527</A></TD><TD>         * @param variance the variance of the normal distribution.</TD></TR><TR><TD CLASS="l">528</TD><TD>         * @param x the integration limit.</TD></TR><TR><TD CLASS="l">529</TD><TD>         */</TD></TR><TR><TD CLASS="l">530</TD><TD>        static public double normal(double mean, double variance, double x) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>                if (x &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                        return 0.5 + 0.5 * errorFunction((x - mean) / Math.sqrt(2.0 * variance));</TD></TR><TR><TD CLASS="l">533</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>                        return 0.5 - 0.5 * errorFunction((-(x - mean)) / Math.sqrt(2.0 * variance));</TD></TR><TR><TD CLASS="l">535</TD><TD>                }</TD></TR><TR><TD CLASS="l">536</TD><TD>        }</TD></TR><TR><TD CLASS="l">537</TD><TD> </TD></TR><TR><TD CLASS="l">538</TD><TD>        /**</TD></TR><TR><TD CLASS="l">539</TD><TD>         * Returns the value, &lt;tt&gt;x&lt;/tt&gt;, for which the area under the</TD></TR><TR><TD CLASS="l">540</TD><TD>         * Normal (Gaussian) probability density function (integrated from</TD></TR><TR><TD CLASS="l">541</TD><TD>         * minus infinity to &lt;tt&gt;x&lt;/tt&gt;) is equal to the argument &lt;tt&gt;y&lt;/tt&gt; (assumes mean is zero, variance is one); formerly named &lt;tt&gt;ndtri&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">542</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">543</TD><TD>         * For small arguments &lt;tt&gt;0 &lt; y &lt; exp(-2)&lt;/tt&gt;, the program computes</TD></TR><TR><TD CLASS="l">544</TD><TD>         * &lt;tt&gt;z = sqrt( -2.0 * getLog(y) )&lt;/tt&gt;;  then the approximation is</TD></TR><TR><TD CLASS="l">545</TD><TD>         * &lt;tt&gt;x = z - getLog(z)/z  - (1/z) P(1/z) / Q(1/z)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">546</TD><TD>         * There are two rational functions P/Q, one for &lt;tt&gt;0 &lt; y &lt; exp(-32)&lt;/tt&gt;</TD></TR><TR><TD CLASS="l">547</TD><TD>         * and the other for &lt;tt&gt;y&lt;/tt&gt; up to &lt;tt&gt;exp(-2)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">548</TD><TD>         * For larger arguments,</TD></TR><TR><TD CLASS="l">549</TD><TD>         * &lt;tt&gt;w = y - 0.5&lt;/tt&gt;, and  &lt;tt&gt;x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2))&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">550</TD><TD>         *</TD></TR><TR><TD CLASS="l">551</TD><TD>         */</TD></TR><TR><TD CLASS="l"><A NAME="11">552</A></TD><TD>        static public double normalInverse(double y0) throws ArithmeticException {</TD></TR><TR><TD CLASS="l">553</TD><TD>                double x, y, z, y2, x0, x1;</TD></TR><TR><TD CLASS="l">554</TD><TD>                int code;</TD></TR><TR><TD CLASS="l">555</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                final double s2pi = Math.sqrt(2.0 * Math.PI);</TD></TR><TR><TD CLASS="l">557</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>                if (y0 &lt;= 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">560</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">561</TD><TD>                if (y0 &gt;= 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">563</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>                code = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>                y = y0;</TD></TR><TR CLASS="z"><TD CLASS="l">566</TD><TD>                if (y &gt; (1.0 - 0.13533528323661269189)) { /* 0.135... = exp(-2) */</TD></TR><TR CLASS="z"><TD CLASS="l">567</TD><TD>                        y = 1.0 - y;</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>                        code = 0;</TD></TR><TR><TD CLASS="l">569</TD><TD>                }</TD></TR><TR><TD CLASS="l">570</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>                if (y &gt; 0.13533528323661269189) {</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>                        y = y - 0.5;</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>                        y2 = y * y;</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>                        x = y + y * (y2 * Polynomial.polevl(y2, P0, 4) / Polynomial.p1evl(y2, Q0, 8));</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>                        x = x * s2pi;</TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>                        return (x);</TD></TR><TR><TD CLASS="l">577</TD><TD>                }</TD></TR><TR><TD CLASS="l">578</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>                x = Math.sqrt(-2.0 * Math.log(y));</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>                x0 = x - Math.log(x) / x;</TD></TR><TR><TD CLASS="l">581</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>                z = 1.0 / x;</TD></TR><TR CLASS="z"><TD CLASS="l">583</TD><TD>                if (x &lt; 8.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>                        x1 = z * Polynomial.polevl(z, P1, 8) / Polynomial.p1evl(z, Q1, 8);</TD></TR><TR><TD CLASS="l">585</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>                        x1 = z * Polynomial.polevl(z, P2, 8) / Polynomial.p1evl(z, Q2, 8);</TD></TR><TR><TD CLASS="l">587</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>                x = x0 - x1;</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>                if (code != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>                        x = -x;</TD></TR><TR><TD CLASS="l">591</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">592</TD><TD>                return (x);</TD></TR><TR><TD CLASS="l">593</TD><TD>        }</TD></TR><TR><TD CLASS="l">594</TD><TD> </TD></TR><TR><TD CLASS="l">595</TD><TD>        /**</TD></TR><TR><TD CLASS="l">596</TD><TD>         * Returns the sum of the first &lt;tt&gt;k&lt;/tt&gt; terms of the Poisson distribution.</TD></TR><TR><TD CLASS="l">597</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">598</TD><TD>         *   k         j</TD></TR><TR><TD CLASS="l">599</TD><TD>         *   --   -m  m</TD></TR><TR><TD CLASS="l">600</TD><TD>         *   &gt;   e    --</TD></TR><TR><TD CLASS="l">601</TD><TD>         *   --       j!</TD></TR><TR><TD CLASS="l">602</TD><TD>         *  j=0</TD></TR><TR><TD CLASS="l">603</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">604</TD><TD>         * The terms are not summed directly; instead the incomplete</TD></TR><TR><TD CLASS="l">605</TD><TD>         * gamma integral is employed, according to the relation</TD></TR><TR><TD CLASS="l">606</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">607</TD><TD>         * &lt;tt&gt;y = poisson( k, m ) = Gamma.incompleteGammaComplement( k+1, m )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">608</TD><TD>         *</TD></TR><TR><TD CLASS="l">609</TD><TD>         * The arguments must both be positive.</TD></TR><TR><TD CLASS="l">610</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="12">611</A></TD><TD>         * @param k number of terms.</TD></TR><TR><TD CLASS="l">612</TD><TD>         * @param mean the mean of the poisson distribution.</TD></TR><TR><TD CLASS="l">613</TD><TD>         */</TD></TR><TR><TD CLASS="l">614</TD><TD>        static public double poisson(int k, double mean) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>                if (mean &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">616</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">617</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>                if (k &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">620</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>                return Gamma.incompleteGammaComplement((k + 1), mean);</TD></TR><TR><TD CLASS="l">622</TD><TD>        }</TD></TR><TR><TD CLASS="l">623</TD><TD> </TD></TR><TR><TD CLASS="l">624</TD><TD>        /**</TD></TR><TR><TD CLASS="l">625</TD><TD>         * Returns the sum of the terms &lt;tt&gt;k+1&lt;/tt&gt; to &lt;tt&gt;Infinity&lt;/tt&gt; of the Poisson distribution.</TD></TR><TR><TD CLASS="l">626</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">627</TD><TD>         *  inf.       j</TD></TR><TR><TD CLASS="l">628</TD><TD>         *   --   -m  m</TD></TR><TR><TD CLASS="l">629</TD><TD>         *   &gt;   e    --</TD></TR><TR><TD CLASS="l">630</TD><TD>         *   --       j!</TD></TR><TR><TD CLASS="l">631</TD><TD>         *  j=k+1</TD></TR><TR><TD CLASS="l">632</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">633</TD><TD>         * The terms are not summed directly; instead the incomplete</TD></TR><TR><TD CLASS="l">634</TD><TD>         * gamma integral is employed, according to the formula</TD></TR><TR><TD CLASS="l">635</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">636</TD><TD>         * &lt;tt&gt;y = poissonComplemented( k, m ) = Gamma.incompleteGamma( k+1, m )&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">637</TD><TD>         *</TD></TR><TR><TD CLASS="l">638</TD><TD>         * The arguments must both be positive.</TD></TR><TR><TD CLASS="l">639</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="13">640</A></TD><TD>         * @param k start term.</TD></TR><TR><TD CLASS="l">641</TD><TD>         * @param mean the mean of the poisson distribution.</TD></TR><TR><TD CLASS="l">642</TD><TD>         */</TD></TR><TR><TD CLASS="l">643</TD><TD>        static public double poissonComplemented(int k, double mean) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>                if (mean &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">646</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                if (k &lt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                        return 0.0;</TD></TR><TR><TD CLASS="l">649</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">650</TD><TD>                return Gamma.incompleteGamma((k + 1), mean);</TD></TR><TR><TD CLASS="l">651</TD><TD>        }</TD></TR><TR><TD CLASS="l">652</TD><TD> </TD></TR><TR><TD CLASS="l">653</TD><TD>        /**</TD></TR><TR><TD CLASS="l">654</TD><TD>         * Returns the integral from minus infinity to &lt;tt&gt;t&lt;/tt&gt; of the Student-t</TD></TR><TR><TD CLASS="l">655</TD><TD>         * distribution with &lt;tt&gt;k &amp;gt; 0&lt;/tt&gt; degrees of freedom.</TD></TR><TR><TD CLASS="l">656</TD><TD>         * &lt;pre&gt;</TD></TR><TR><TD CLASS="l">657</TD><TD>         *                                      t</TD></TR><TR><TD CLASS="l">658</TD><TD>         *                                      -</TD></TR><TR><TD CLASS="l">659</TD><TD>         *                                     | |</TD></TR><TR><TD CLASS="l">660</TD><TD>         *              -                      |         2   -(k+1)/2</TD></TR><TR><TD CLASS="l">661</TD><TD>         *             | ( (k+1)/2 )           |  (     x   )</TD></TR><TR><TD CLASS="l">662</TD><TD>         *       ----------------------        |  ( 1 + --- )        dx</TD></TR><TR><TD CLASS="l">663</TD><TD>         *                     -               |  (      k  )</TD></TR><TR><TD CLASS="l">664</TD><TD>         *       sqrt( k pi ) | ( k/2 )        |</TD></TR><TR><TD CLASS="l">665</TD><TD>         *                                   | |</TD></TR><TR><TD CLASS="l">666</TD><TD>         *                                    -</TD></TR><TR><TD CLASS="l">667</TD><TD>         *                                   -inf.</TD></TR><TR><TD CLASS="l">668</TD><TD>         * &lt;/pre&gt;</TD></TR><TR><TD CLASS="l">669</TD><TD>         * Relation to incomplete beta integral:</TD></TR><TR><TD CLASS="l">670</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">671</TD><TD>         * &lt;tt&gt;1 - studentT(k,t) = 0.5 * Gamma.incompleteBeta( k/2, 1/2, z )&lt;/tt&gt;</TD></TR><TR><TD CLASS="l">672</TD><TD>         * where &lt;tt&gt;z = k/(k + t**2)&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">673</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">674</TD><TD>         * Since the function is symmetric about &lt;tt&gt;t=0&lt;/tt&gt;, the area under the</TD></TR><TR><TD CLASS="l">675</TD><TD>         * right tail of the density is found by calling the function</TD></TR><TR><TD CLASS="l">676</TD><TD>         * with &lt;tt&gt;-t&lt;/tt&gt; instead of &lt;tt&gt;t&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">677</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="14">678</A></TD><TD>         * @param k degrees of freedom.</TD></TR><TR><TD CLASS="l">679</TD><TD>         * @param t integration end point.</TD></TR><TR><TD CLASS="l">680</TD><TD>         */</TD></TR><TR><TD CLASS="l">681</TD><TD>        static public double studentT(double k, double t) throws ArithmeticException {</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>                if (k &lt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>                        throw new IllegalArgumentException();</TD></TR><TR><TD CLASS="l">684</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>                if (t == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">686</TD><TD>                        return (0.5);</TD></TR><TR><TD CLASS="l">687</TD><TD>                }</TD></TR><TR><TD CLASS="l">688</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                return 1.0 - 0.5 * Gamma.incompleteBeta(0.5 * k, 0.5, k / (k + t * t));</TD></TR><TR><TD CLASS="l">690</TD><TD>        }</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR><TD CLASS="l">692</TD><TD>        /**</TD></TR><TR><TD CLASS="l">693</TD><TD>         * Returns the value, &lt;tt&gt;t&lt;/tt&gt;, for which the area under the</TD></TR><TR><TD CLASS="l">694</TD><TD>         * Student-t probability density function (integrated from</TD></TR><TR><TD CLASS="l">695</TD><TD>         * minus infinity to &lt;tt&gt;t&lt;/tt&gt;) is equal to &lt;tt&gt;1-alpha/2&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">696</TD><TD>         * The value returned corresponds to usual Student t-distribution lookup</TD></TR><TR><TD CLASS="l">697</TD><TD>         * table for &lt;tt&gt;t&lt;sub&gt;alpha[size]&lt;/sub&gt;&lt;/tt&gt;.</TD></TR><TR><TD CLASS="l">698</TD><TD>         * &lt;p&gt;</TD></TR><TR><TD CLASS="l">699</TD><TD>         * The function uses the studentT function to determine the return</TD></TR><TR><TD CLASS="l">700</TD><TD>         * value iteratively.</TD></TR><TR><TD CLASS="l">701</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="15">702</A></TD><TD>         * @param alpha probability</TD></TR><TR><TD CLASS="l">703</TD><TD>         * @param size size of data set</TD></TR><TR><TD CLASS="l">704</TD><TD>         */</TD></TR><TR><TD CLASS="l">705</TD><TD>        public static double studentTInverse(double alpha, int size) {</TD></TR><TR CLASS="z"><TD CLASS="l">706</TD><TD>                double cumProb = 1 - alpha / 2; // Cumulative probability</TD></TR><TR><TD CLASS="l">707</TD><TD>                double f1, f2, f3;</TD></TR><TR><TD CLASS="l">708</TD><TD>                double x1, x2, x3;</TD></TR><TR><TD CLASS="l">709</TD><TD>                double g, s12;</TD></TR><TR><TD CLASS="l">710</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                cumProb = 1 - alpha / 2; // Cumulative probability</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                x1 = normalInverse(cumProb);</TD></TR><TR><TD CLASS="l">713</TD><TD> </TD></TR><TR><TD CLASS="l">714</TD><TD>                // Return inverse of normal for large size</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                if (size &gt; 200) {</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                        return x1;</TD></TR><TR><TD CLASS="l">717</TD><TD>                }</TD></TR><TR><TD CLASS="l">718</TD><TD> </TD></TR><TR><TD CLASS="l">719</TD><TD>                // Find a pair of x1,x2 that braket zero</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>                f1 = studentT(size, x1) - cumProb;</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                x2 = x1;</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                f2 = f1;</TD></TR><TR><TD CLASS="l">723</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                        if (f1 &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">725</TD><TD>                                x2 = x2 / 2;</TD></TR><TR><TD CLASS="l">726</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">727</TD><TD>                                x2 = x2 + x1;</TD></TR><TR><TD CLASS="l">728</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>                        f2 = studentT(size, x2) - cumProb;</TD></TR><TR CLASS="z"><TD CLASS="l">730</TD><TD>                } while (f1 * f2 &gt; 0);</TD></TR><TR><TD CLASS="l">731</TD><TD> </TD></TR><TR><TD CLASS="l">732</TD><TD>                // Find better approximation</TD></TR><TR><TD CLASS="l">733</TD><TD>                // Pegasus-method</TD></TR><TR><TD CLASS="l">734</TD><TD>                do {</TD></TR><TR><TD CLASS="l">735</TD><TD>                        // Calculate slope of secant and t value for which it is 0.</TD></TR><TR CLASS="z"><TD CLASS="l">736</TD><TD>                        s12 = (f2 - f1) / (x2 - x1);</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>                        x3 = x2 - f2 / s12;</TD></TR><TR><TD CLASS="l">738</TD><TD> </TD></TR><TR><TD CLASS="l">739</TD><TD>                        // Calculate function value at x3</TD></TR><TR CLASS="z"><TD CLASS="l">740</TD><TD>                        f3 = studentT(size, x3) - cumProb;</TD></TR><TR CLASS="z"><TD CLASS="l">741</TD><TD>                        if (Math.abs(f3) &lt; 1e-8) { // This criteria needs to be very tight!</TD></TR><TR><TD CLASS="l">742</TD><TD>                                // We found a perfect value -&gt; return</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>                                return x3;</TD></TR><TR><TD CLASS="l">744</TD><TD>                        }</TD></TR><TR><TD CLASS="l">745</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                        if (f3 * f2 &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>                                x1 = x2;</TD></TR><TR CLASS="z"><TD CLASS="l">748</TD><TD>                                f1 = f2;</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>                                x2 = x3;</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>                                f2 = f3;</TD></TR><TR><TD CLASS="l">751</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">752</TD><TD>                                g = f2 / (f2 + f3);</TD></TR><TR CLASS="z"><TD CLASS="l">753</TD><TD>                                f1 = g * f1;</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>                                x2 = x3;</TD></TR><TR CLASS="z"><TD CLASS="l">755</TD><TD>                                f2 = f3;</TD></TR><TR><TD CLASS="l">756</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>                } while (Math.abs(x2 - x1) &gt; 0.001);</TD></TR><TR><TD CLASS="l">758</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>                if (Math.abs(f2) &lt;= Math.abs(f1)) {</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>                        return x2;</TD></TR><TR><TD CLASS="l">761</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">762</TD><TD>                        return x1;</TD></TR><TR><TD CLASS="l">763</TD><TD>                }</TD></TR><TR><TD CLASS="l">764</TD><TD>        }</TD></TR><TR><TD CLASS="l">765</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1f.html">jmt.engine.math</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>