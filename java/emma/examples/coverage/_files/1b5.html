<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="34.html">jmt.gui.common.definitions</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">ModelConverter.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>ModelConverter.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1477)</TD><TD CLASS="h">0%   (0/256)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">ModelConverter</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1477)</TD><TD CLASS="h">0%   (0/256)</TD></TR><TR><TD CLASS="f"><A HREF="#0">ModelConverter (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">buildProbabilityMatrix (List, CommonModel, Object, List): double [][]</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3">convertJMVAtoJSIM (ExactModel, CommonModel): List</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/562)</TD><TD CLASS="h">0%   (0/96)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">convertJSIMtoJMVA (CommonModel, ExactModel): List</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/732)</TD><TD CLASS="h">0%   (0/128)</TD></TR><TR><TD CLASS="f"><A HREF="#5">getRoutingProbability (Object, Object, CommonModel, List, List): double []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/146)</TD><TD CLASS="h">0%   (0/26)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/**</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (C) 2006, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano</TD></TR><TR><TD CLASS="l">3</TD><TD> </TD></TR><TR><TD CLASS="l">4</TD><TD> * This program is free software; you can redistribute it and/or modify</TD></TR><TR><TD CLASS="l">5</TD><TD> * it under the terms of the GNU General Public License as published by</TD></TR><TR><TD CLASS="l">6</TD><TD> * the Free Software Foundation; either version 2 of the License, or</TD></TR><TR><TD CLASS="l">7</TD><TD> * (at your option) any later version.</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD> * This program is distributed in the hope that it will be useful,</TD></TR><TR><TD CLASS="l">10</TD><TD> * but WITHOUT ANY WARRANTY; without even the implied warranty of</TD></TR><TR><TD CLASS="l">11</TD><TD> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</TD></TR><TR><TD CLASS="l">12</TD><TD> * GNU General Public License for more details.</TD></TR><TR><TD CLASS="l">13</TD><TD> </TD></TR><TR><TD CLASS="l">14</TD><TD> * You should have received a copy of the GNU General Public License</TD></TR><TR><TD CLASS="l">15</TD><TD> * along with this program; if not, write to the Free Software</TD></TR><TR><TD CLASS="l">16</TD><TD> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</TD></TR><TR><TD CLASS="l">17</TD><TD> */</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>package jmt.gui.common.definitions;</TD></TR><TR><TD CLASS="l">20</TD><TD> </TD></TR><TR><TD CLASS="l">21</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.util.Vector;</TD></TR><TR><TD CLASS="l">26</TD><TD> </TD></TR><TR><TD CLASS="l">27</TD><TD>import jmt.gui.common.CommonConstants;</TD></TR><TR><TD CLASS="l">28</TD><TD>import jmt.gui.common.Defaults;</TD></TR><TR><TD CLASS="l">29</TD><TD>import jmt.gui.common.distributions.Distribution;</TD></TR><TR><TD CLASS="l">30</TD><TD>import jmt.gui.common.distributions.Exponential;</TD></TR><TR><TD CLASS="l">31</TD><TD>import jmt.gui.common.routingStrategies.ProbabilityRouting;</TD></TR><TR><TD CLASS="l">32</TD><TD>import jmt.gui.common.routingStrategies.RandomRouting;</TD></TR><TR><TD CLASS="l">33</TD><TD>import jmt.gui.common.routingStrategies.RoutingStrategy;</TD></TR><TR><TD CLASS="l">34</TD><TD>import jmt.gui.common.serviceStrategies.LDStrategy;</TD></TR><TR><TD CLASS="l">35</TD><TD>import jmt.gui.common.serviceStrategies.ZeroStrategy;</TD></TR><TR><TD CLASS="l">36</TD><TD>import jmt.gui.exact.ExactConstants;</TD></TR><TR><TD CLASS="l">37</TD><TD>import jmt.gui.exact.ExactModel;</TD></TR><TR><TD CLASS="l">38</TD><TD>import Jama.Matrix;</TD></TR><TR><TD CLASS="l">39</TD><TD> </TD></TR><TR><TD CLASS="l">40</TD><TD>/**</TD></TR><TR><TD CLASS="l">41</TD><TD> * &lt;p&gt;Title: Model Converter&lt;/p&gt;</TD></TR><TR><TD CLASS="l">42</TD><TD> * &lt;p&gt;Description: This class provides methods to convert models between JMODEL, JSIM,</TD></TR><TR><TD CLASS="l">43</TD><TD> * JMVA and JABA.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">44</TD><TD> *</TD></TR><TR><TD CLASS="l"><A NAME="0">45</A></TD><TD> * @author Bertoli Marco</TD></TR><TR><TD CLASS="l">46</TD><TD> *         Date: 20-feb-2006</TD></TR><TR><TD CLASS="l">47</TD><TD> *         Time: 12.23.12</TD></TR><TR><TD CLASS="l">48</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">49</TD><TD>public class ModelConverter {</TD></TR><TR><TD CLASS="l">50</TD><TD>        // --- Methods for conversion JMVA --&gt; JSIM -----------------------------------------------</TD></TR><TR><TD CLASS="l">51</TD><TD>        /**</TD></TR><TR><TD CLASS="l">52</TD><TD>         * Converts a JMVA model to JSIM. Conversion is performed by equalling service times in every</TD></TR><TR><TD CLASS="l">53</TD><TD>         * LI station (adjusting visits) and creating FCFS queues with exponential service time distribution.</TD></TR><TR><TD CLASS="l">54</TD><TD>         * &lt;br&gt;</TD></TR><TR><TD CLASS="l">55</TD><TD>         * Visits are converted with routing probability, to mantain correctness of computated response time values</TD></TR><TR><TD CLASS="l">56</TD><TD>         * a &#34;virtual&#34; node called  RefStation is added as a reference station for closed classes and</TD></TR><TR><TD CLASS="l">57</TD><TD>         * routed when (in terms of mean values) a single visit is performed in the system. (as visits values are scaled to</TD></TR><TR><TD CLASS="l">58</TD><TD>         * compute probability distribution).</TD></TR><TR><TD CLASS="l">59</TD><TD>         * &lt;br&gt;</TD></TR><TR><TD CLASS="l">60</TD><TD>         * Note that a single router node, called &#34;Router&#34; is used to route jobs through the</TD></TR><TR><TD CLASS="l">61</TD><TD>         * entire network, simplyfing its thopology. Stations (LI, LD and Delays) are connected in a parallel form with</TD></TR><TR><TD CLASS="l">62</TD><TD>         * the Router.</TD></TR><TR><TD CLASS="l">63</TD><TD>         * @param input JMVA model (read only access)</TD></TR><TR><TD CLASS="l">64</TD><TD>         * @param output target JSIM or JMODEL model. This is expected to be empty</TD></TR><TR><TD CLASS="l"><A NAME="3">65</A></TD><TD>         * @return a List with all found warnings during conversion (in String format).</TD></TR><TR><TD CLASS="l">66</TD><TD>         */</TD></TR><TR><TD CLASS="l">67</TD><TD>        public static List&lt;String&gt; convertJMVAtoJSIM(ExactModel input, CommonModel output) {</TD></TR><TR><TD CLASS="l">68</TD><TD>                // Changes default values, then restores default back at the end of method</TD></TR><TR CLASS="z"><TD CLASS="l">69</TD><TD>                String defaultRouting = Defaults.get(&#34;stationRoutingStrategy&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">70</TD><TD>                String defaultQueue = Defaults.get(&#34;stationQueueStrategy&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">71</TD><TD>                Defaults.set(&#34;stationRoutingStrategy&#34;, RandomRouting.class.getName());</TD></TR><TR CLASS="z"><TD CLASS="l">72</TD><TD>                Defaults.set(&#34;stationQueueStrategy&#34;, CommonConstants.QUEUE_STRATEGY_FCFS);</TD></TR><TR><TD CLASS="l">73</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">74</TD><TD>                ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();</TD></TR><TR><TD CLASS="l">75</TD><TD>                // Keys for unique items</TD></TR><TR CLASS="z"><TD CLASS="l">76</TD><TD>                Object sourceKey = null, sinkKey = null, routerKey, refRouterKey = null;</TD></TR><TR><TD CLASS="l">77</TD><TD>                // Sums visit for each class</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>                double[] visitSum = new double[input.getClasses()];</TD></TR><TR><TD CLASS="l">79</TD><TD>                // Visits matrix (row: stations, column: classes)</TD></TR><TR CLASS="z"><TD CLASS="l">80</TD><TD>                double[][] visits = input.getVisits();</TD></TR><TR><TD CLASS="l">81</TD><TD> </TD></TR><TR><TD CLASS="l">82</TD><TD>                // Convert classes</TD></TR><TR CLASS="z"><TD CLASS="l">83</TD><TD>                Object[] classKeys = new Object[input.getClasses()];</TD></TR><TR CLASS="z"><TD CLASS="l">84</TD><TD>                for (int i = 0; i &lt; input.getClasses(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">85</TD><TD>                        String name = input.getClassNames()[i];</TD></TR><TR CLASS="z"><TD CLASS="l">86</TD><TD>                        int type = input.getClassTypes()[i];</TD></TR><TR><TD CLASS="l">87</TD><TD>                        // This holds customers if class is closed or arrival rate if open</TD></TR><TR CLASS="z"><TD CLASS="l">88</TD><TD>                        double data = input.getClassData()[i];</TD></TR><TR><TD CLASS="l">89</TD><TD>                        Object key;</TD></TR><TR><TD CLASS="l">90</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">91</TD><TD>                        visitSum[i] = 1; // Sums visit for each station. This is initialized to one as we</TD></TR><TR><TD CLASS="l">92</TD><TD>                        // count visit to reference station</TD></TR><TR CLASS="z"><TD CLASS="l">93</TD><TD>                        for (int j = 0; j &lt; input.getStations(); j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">94</TD><TD>                                visitSum[i] += visits[j][i];</TD></TR><TR><TD CLASS="l">95</TD><TD>                        }</TD></TR><TR><TD CLASS="l">96</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">97</TD><TD>                        if (type == ExactConstants.CLASS_CLOSED) {</TD></TR><TR><TD CLASS="l">98</TD><TD>                                // Closed class</TD></TR><TR CLASS="z"><TD CLASS="l">99</TD><TD>                                key = output.addClass(name, CommonConstants.CLASS_TYPE_CLOSED, 0, new Integer((int) data), null);</TD></TR><TR><TD CLASS="l">100</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">101</TD><TD>                                // Open class</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>                                Exponential ex = new Exponential();</TD></TR><TR CLASS="z"><TD CLASS="l">103</TD><TD>                                ex.setMean(1 / data);</TD></TR><TR CLASS="z"><TD CLASS="l">104</TD><TD>                                key = output.addClass(name, CommonConstants.CLASS_TYPE_OPEN, 0, null, ex);</TD></TR><TR><TD CLASS="l">105</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>                        classKeys[i] = key;</TD></TR><TR><TD CLASS="l">107</TD><TD>                }</TD></TR><TR><TD CLASS="l">108</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">109</TD><TD>                routerKey = output.addStation(&#34;Router&#34;, CommonConstants.STATION_TYPE_ROUTER);</TD></TR><TR><TD CLASS="l">110</TD><TD> </TD></TR><TR><TD CLASS="l">111</TD><TD>                // Creates source, sink and router (if needed)</TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>                if (input.isClosed() || input.isMixed()) {</TD></TR><TR CLASS="z"><TD CLASS="l">113</TD><TD>                        refRouterKey = output.addStation(&#34;RefStation&#34;, CommonConstants.STATION_TYPE_ROUTER);</TD></TR><TR><TD CLASS="l">114</TD><TD>                        // Makes connection between refRouter and router</TD></TR><TR CLASS="z"><TD CLASS="l">115</TD><TD>                        output.setConnected(refRouterKey, routerKey, true);</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>                        output.setConnected(routerKey, refRouterKey, true);</TD></TR><TR><TD CLASS="l">117</TD><TD>                        // Gives warning on refStation</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>                        res</TD></TR><TR><TD CLASS="l">119</TD><TD>                                        .add(&#34;A special node, called \&#34;RefStation\&#34; was added in order to compute correctly the System Response Time and System Throughput of closed classes.&#34;</TD></TR><TR><TD CLASS="l">120</TD><TD>                                                        + &#34; Its presence is fundamental to compute correctly number of visits at each station for closed classes.&#34;);</TD></TR><TR><TD CLASS="l">121</TD><TD>                }</TD></TR><TR><TD CLASS="l">122</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>                if (input.isOpen() || input.isMixed()) {</TD></TR><TR CLASS="z"><TD CLASS="l">124</TD><TD>                        sourceKey = output.addStation(&#34;Source&#34;, CommonConstants.STATION_TYPE_SOURCE);</TD></TR><TR CLASS="z"><TD CLASS="l">125</TD><TD>                        sinkKey = output.addStation(&#34;Sink&#34;, CommonConstants.STATION_TYPE_SINK);</TD></TR><TR><TD CLASS="l">126</TD><TD>                        //Makes connections between source, sink and router</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>                        output.setConnected(sourceKey, routerKey, true);</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>                        output.setConnected(routerKey, sinkKey, true);</TD></TR><TR><TD CLASS="l">129</TD><TD>                }</TD></TR><TR><TD CLASS="l">130</TD><TD> </TD></TR><TR><TD CLASS="l">131</TD><TD>                // Convert stations</TD></TR><TR CLASS="z"><TD CLASS="l">132</TD><TD>                Object[] stationKeys = new Object[input.getStations()];</TD></TR><TR CLASS="z"><TD CLASS="l">133</TD><TD>                for (int i = 0; i &lt; input.getStations(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">134</TD><TD>                        String name = input.getStationNames()[i];</TD></TR><TR CLASS="z"><TD CLASS="l">135</TD><TD>                        int type = input.getStationTypes()[i];</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>                        int servers = input.getStationServers()[i];</TD></TR><TR CLASS="z"><TD CLASS="l">137</TD><TD>                        double[][] serviceTimes = input.getServiceTimes()[i];</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>                        Object key = null;</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>                        switch (type) {</TD></TR><TR><TD CLASS="l">140</TD><TD>                                case ExactConstants.STATION_DELAY:</TD></TR><TR><TD CLASS="l">141</TD><TD>                                        // Delay</TD></TR><TR CLASS="z"><TD CLASS="l">142</TD><TD>                                        key = output.addStation(name, CommonConstants.STATION_TYPE_DELAY);</TD></TR><TR><TD CLASS="l">143</TD><TD>                                        // Sets distribution for each class</TD></TR><TR CLASS="z"><TD CLASS="l">144</TD><TD>                                        for (int j = 0; j &lt; classKeys.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>                                                Exponential ex = new Exponential();</TD></TR><TR CLASS="z"><TD CLASS="l">146</TD><TD>                                                ex.setMean(serviceTimes[j][0]);</TD></TR><TR CLASS="z"><TD CLASS="l">147</TD><TD>                                                output.setServiceTimeDistribution(key, classKeys[j], ex);</TD></TR><TR><TD CLASS="l">148</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">149</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">150</TD><TD>                                case ExactConstants.STATION_LI:</TD></TR><TR><TD CLASS="l">151</TD><TD>                                        // Load independent</TD></TR><TR CLASS="z"><TD CLASS="l">152</TD><TD>                                        key = output.addStation(name, CommonConstants.STATION_TYPE_SERVER);</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                                        output.setStationNumberOfServers(new Integer(servers), key);</TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>                                        output.setStationQueueStrategy(key, CommonConstants.QUEUE_STRATEGY_STATION_PS);</TD></TR><TR><TD CLASS="l">155</TD><TD>                                        // Sets distribution for each class</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                                        for (int j = 0; j &lt; classKeys.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>                                                Exponential ex = new Exponential();</TD></TR><TR CLASS="z"><TD CLASS="l">158</TD><TD>                                                ex.setMean(serviceTimes[j][0]);</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>                                                output.setServiceTimeDistribution(key, classKeys[j], ex);</TD></TR><TR><TD CLASS="l">160</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">162</TD><TD>                                case ExactConstants.STATION_LD:</TD></TR><TR><TD CLASS="l">163</TD><TD>                                        // Load dependent - this is single class only, but here</TD></TR><TR><TD CLASS="l">164</TD><TD>                                        // we support multiclass too (future extensions).</TD></TR><TR CLASS="z"><TD CLASS="l">165</TD><TD>                                        key = output.addStation(name, CommonConstants.STATION_TYPE_SERVER);</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>                                        output.setStationNumberOfServers(new Integer(servers), key);</TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>                                        output.setStationQueueStrategy(key, CommonConstants.QUEUE_STRATEGY_STATION_PS);</TD></TR><TR><TD CLASS="l">168</TD><TD>                                        // Sets distribution for each class</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>                                        for (int j = 0; j &lt; classKeys.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">170</TD><TD>                                                LDStrategy lds = new LDStrategy();</TD></TR><TR CLASS="z"><TD CLASS="l">171</TD><TD>                                                Object rangeKey = lds.getAllRanges()[0];</TD></TR><TR CLASS="z"><TD CLASS="l">172</TD><TD>                                                for (int range = 0; range &lt; serviceTimes[j].length; range++) {</TD></TR><TR><TD CLASS="l">173</TD><TD>                                                        // First range is already available</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                                                        if (range &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                                                                rangeKey = lds.addRange();</TD></TR><TR><TD CLASS="l">176</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                                                        Exponential ex = new Exponential();</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                                                        ex.setMean(serviceTimes[j][range]);</TD></TR><TR CLASS="z"><TD CLASS="l">179</TD><TD>                                                        lds.setRangeDistribution(rangeKey, ex);</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>                                                        lds.setRangeDistributionMean(rangeKey, Double.toString(serviceTimes[j][range]));</TD></TR><TR><TD CLASS="l">181</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">182</TD><TD>                                                output.setServiceTimeDistribution(key, classKeys[j], lds);</TD></TR><TR><TD CLASS="l">183</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">184</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">185</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>                        stationKeys[i] = key;</TD></TR><TR><TD CLASS="l">187</TD><TD> </TD></TR><TR><TD CLASS="l">188</TD><TD>                        // Make connections with router</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                        output.setConnected(routerKey, key, true);</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                        output.setConnected(key, routerKey, true);</TD></TR><TR><TD CLASS="l">191</TD><TD>                }</TD></TR><TR><TD CLASS="l">192</TD><TD> </TD></TR><TR><TD CLASS="l">193</TD><TD>                // Sets routing for router</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>                for (int i = 0; i &lt; classKeys.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>                        ProbabilityRouting pr = new ProbabilityRouting();</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>                        output.setRoutingStrategy(routerKey, classKeys[i], pr);</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                        for (int j = 0; j &lt; stationKeys.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                                pr.getValues().put(stationKeys[j], new Double(visits[j][i] / visitSum[i]));</TD></TR><TR><TD CLASS="l">199</TD><TD>                        }</TD></TR><TR><TD CLASS="l">200</TD><TD> </TD></TR><TR><TD CLASS="l">201</TD><TD>                        // Sets refRouter as reference station for closed class, sets its routing and avoid put jobs into sink</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>                        if (output.getClassType(classKeys[i]) == CommonConstants.CLASS_TYPE_CLOSED) {</TD></TR><TR CLASS="z"><TD CLASS="l">203</TD><TD>                                output.setClassRefStation(classKeys[i], refRouterKey);</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                                pr.getValues().put(refRouterKey, new Double(1 / visitSum[i]));</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>                                if (sinkKey != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                                        pr.getValues().put(sinkKey, new Double(0.0));</TD></TR><TR><TD CLASS="l">207</TD><TD>                                }</TD></TR><TR><TD CLASS="l">208</TD><TD>                        }</TD></TR><TR><TD CLASS="l">209</TD><TD>                        // Sets source as reference station for open class and sets sink routing, avoid routing to refRouter</TD></TR><TR><TD CLASS="l">210</TD><TD>                        else {</TD></TR><TR CLASS="z"><TD CLASS="l">211</TD><TD>                                output.setClassRefStation(classKeys[i], sourceKey);</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                                pr.getValues().put(sinkKey, new Double(1 / visitSum[i]));</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                                if (refRouterKey != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>                                        pr.getValues().put(refRouterKey, new Double(0.0));</TD></TR><TR><TD CLASS="l">215</TD><TD>                                }</TD></TR><TR><TD CLASS="l">216</TD><TD>                        }</TD></TR><TR><TD CLASS="l">217</TD><TD>                }</TD></TR><TR><TD CLASS="l">218</TD><TD> </TD></TR><TR><TD CLASS="l">219</TD><TD>                // Create measures</TD></TR><TR CLASS="z"><TD CLASS="l">220</TD><TD>                for (Object classKey : classKeys) {</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>                        for (Object stationKey : stationKeys) {</TD></TR><TR><TD CLASS="l">222</TD><TD>                                // Queue length</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                                output.addMeasure(SimulationDefinition.MEASURE_QL, stationKey, classKey);</TD></TR><TR><TD CLASS="l">224</TD><TD>                                // Residence Time</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>                                output.addMeasure(SimulationDefinition.MEASURE_RD, stationKey, classKey);</TD></TR><TR><TD CLASS="l">226</TD><TD>                                // Utilization</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>                                output.addMeasure(SimulationDefinition.MEASURE_U, stationKey, classKey);</TD></TR><TR><TD CLASS="l">228</TD><TD>                                // Throughput</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>                                output.addMeasure(SimulationDefinition.MEASURE_X, stationKey, classKey);</TD></TR><TR><TD CLASS="l">230</TD><TD>                        }</TD></TR><TR><TD CLASS="l">231</TD><TD>                }</TD></TR><TR><TD CLASS="l">232</TD><TD>                // Restores default values</TD></TR><TR CLASS="z"><TD CLASS="l">233</TD><TD>                Defaults.set(&#34;stationRoutingStrategy&#34;, defaultRouting);</TD></TR><TR CLASS="z"><TD CLASS="l">234</TD><TD>                Defaults.set(&#34;stationQueueStrategy&#34;, defaultQueue);</TD></TR><TR><TD CLASS="l">235</TD><TD> </TD></TR><TR><TD CLASS="l">236</TD><TD>                // Manage preloading</TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>                output.manageJobs();</TD></TR><TR><TD CLASS="l">238</TD><TD> </TD></TR><TR><TD CLASS="l">239</TD><TD>                // Return warnings</TD></TR><TR CLASS="z"><TD CLASS="l">240</TD><TD>                return res;</TD></TR><TR><TD CLASS="l">241</TD><TD>        }</TD></TR><TR><TD CLASS="l">242</TD><TD> </TD></TR><TR><TD CLASS="l">243</TD><TD>        // ----------------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">244</TD><TD> </TD></TR><TR><TD CLASS="l">245</TD><TD>        // --- Methods for conversion JSIM --&gt; JMVA -----------------------------------------------</TD></TR><TR><TD CLASS="l">246</TD><TD>        /**</TD></TR><TR><TD CLASS="l">247</TD><TD>         * Converts a JSIM model to JMVA. Visits are computed from thopology. To work well this</TD></TR><TR><TD CLASS="l">248</TD><TD>         * method requires:</TD></TR><TR><TD CLASS="l">249</TD><TD>         * &lt;ul&gt;</TD></TR><TR><TD CLASS="l">250</TD><TD>         * &lt;li&gt; Reference station to be set for each class</TD></TR><TR><TD CLASS="l">251</TD><TD>         * &lt;li&gt; Every station must have at least one incoming connection and one outgoing connection</TD></TR><TR><TD CLASS="l">252</TD><TD>         * &lt;li&gt; Routing strategy have to be &lt;code&gt;ProbabilityRouting&lt;/code&gt; or &lt;code&gt;RandomRouting&lt;/code&gt;</TD></TR><TR><TD CLASS="l">253</TD><TD>         * &lt;/ul&gt;</TD></TR><TR><TD CLASS="l">254</TD><TD>         * @param input JSIM model (read only)</TD></TR><TR><TD CLASS="l">255</TD><TD>         * @param output empty JMVA model (write)</TD></TR><TR><TD CLASS="l"><A NAME="4">256</A></TD><TD>         * @return a vector that enumerates all conversion warnings and how they have been fixed</TD></TR><TR><TD CLASS="l">257</TD><TD>         */</TD></TR><TR><TD CLASS="l">258</TD><TD>        public static List&lt;String&gt; convertJSIMtoJMVA(CommonModel input, ExactModel output) {</TD></TR><TR><TD CLASS="l">259</TD><TD>                // Normalize probability routing</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                input.manageProbabilities();</TD></TR><TR><TD CLASS="l">261</TD><TD> </TD></TR><TR><TD CLASS="l">262</TD><TD>                // Used to store warnings</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();</TD></TR><TR><TD CLASS="l">264</TD><TD>                int classNum, stationNum;</TD></TR><TR><TD CLASS="l">265</TD><TD>                // Used to iterate on lists</TD></TR><TR><TD CLASS="l">266</TD><TD>                Iterator&lt;Object&gt; it;</TD></TR><TR><TD CLASS="l">267</TD><TD> </TD></TR><TR><TD CLASS="l">268</TD><TD>                // Number of classes</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                classNum = input.getClassKeys().size();</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                Vector&lt;Object&gt; classKeys = input.getClassKeys();</TD></TR><TR><TD CLASS="l">271</TD><TD> </TD></TR><TR><TD CLASS="l">272</TD><TD>                // Find number of convertible stations</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                it = input.getStationKeys().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                stationNum = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                Vector&lt;Object&gt; stationKeys = new Vector&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                        Object key = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                        String stationType = input.getStationType(key);</TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                        if (stationType.equals(CommonConstants.STATION_TYPE_DELAY) || stationType.equals(CommonConstants.STATION_TYPE_SERVER)) {</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                                stationNum++;</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                                stationKeys.add(key);</TD></TR><TR><TD CLASS="l">282</TD><TD>                        }</TD></TR><TR><TD CLASS="l">283</TD><TD>                        // Show here warning if a station type is discarded (fork and join)</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>                }</TD></TR><TR><TD CLASS="l">285</TD><TD> </TD></TR><TR><TD CLASS="l">286</TD><TD>                // Resizes output data structure</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                output.resize(stationNum, classNum);</TD></TR><TR><TD CLASS="l">288</TD><TD> </TD></TR><TR><TD CLASS="l">289</TD><TD>                // Exports class data</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>                int[] classTypes = new int[classNum];</TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>                String[] classNames = new String[classNum];</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                double[] classData = new double[classNum];</TD></TR><TR><TD CLASS="l">293</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>                for (int i = 0; i &lt; classNum; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                        Object key = classKeys.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">296</TD><TD>                        classNames[i] = input.getClassName(key);</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                        if (input.getClassType(key) == CommonConstants.CLASS_TYPE_CLOSED) {</TD></TR><TR><TD CLASS="l">298</TD><TD>                                // Closed class parameters</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                                classTypes[i] = ExactConstants.CLASS_CLOSED;</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>                                classData[i] = input.getClassPopulation(key).doubleValue();</TD></TR><TR><TD CLASS="l">301</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">302</TD><TD>                                // Open class parameters</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                                classTypes[i] = ExactConstants.CLASS_OPEN;</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                                Distribution d = (Distribution) input.getClassDistribution(key);</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>                                if (d.hasMean()) {</TD></TR><TR CLASS="z"><TD CLASS="l">306</TD><TD>                                        classData[i] = 1.0 / d.getMean();</TD></TR><TR><TD CLASS="l">307</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>                                        classData[i] = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">309</TD><TD>                                        res.add(input.getClassName(key) + &#34; arrival distribution does not have a valid mean value.&#34;</TD></TR><TR><TD CLASS="l">310</TD><TD>                                                        + &#34; Arrival rate for that class was set to default value 1&#34;);</TD></TR><TR><TD CLASS="l">311</TD><TD>                                }</TD></TR><TR><TD CLASS="l">312</TD><TD>                        }</TD></TR><TR><TD CLASS="l">313</TD><TD>                }</TD></TR><TR><TD CLASS="l">314</TD><TD>                // Sets extracted values to output</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                output.setClassNames(classNames);</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>                output.setClassTypes(classTypes);</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                output.setClassData(classData);</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>                classNames = null;</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                classTypes = null;</TD></TR><TR CLASS="z"><TD CLASS="l">320</TD><TD>                classData = null;</TD></TR><TR><TD CLASS="l">321</TD><TD> </TD></TR><TR><TD CLASS="l">322</TD><TD>                // Exports station data</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                double[][][] serviceTimes = new double[stationNum][classNum][];</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                int[] stationTypes = new int[stationNum];</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>                String[] stationNames = new String[stationNum];</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                int[] stationServers = new int[stationNum];</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                for (int st = 0; st &lt; stationNum; st++) {</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                        Object key = stationKeys.get(st);</TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                        stationNames[st] = input.getStationName(key);</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                        Integer serverNum = input.getStationNumberOfServers(key);</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                        if (serverNum != null &amp;&amp; serverNum.intValue() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                                stationServers[st] = serverNum.intValue();</TD></TR><TR><TD CLASS="l">333</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                                stationServers[st] = 1;</TD></TR><TR><TD CLASS="l">335</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                        if (input.getStationType(key).equals(CommonConstants.STATION_TYPE_DELAY)) {</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                                stationTypes[st] = ExactConstants.STATION_DELAY;</TD></TR><TR><TD CLASS="l">338</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>                                stationTypes[st] = ExactConstants.STATION_LI;</TD></TR><TR><TD CLASS="l">340</TD><TD>                        }</TD></TR><TR><TD CLASS="l">341</TD><TD> </TD></TR><TR><TD CLASS="l">342</TD><TD>                        // Sets service time for each class</TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                        for (int cl = 0; cl &lt; classNum; cl++) {</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                                Object serv = input.getServiceTimeDistribution(key, classKeys.get(cl));</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                                if (serv instanceof Distribution) {</TD></TR><TR CLASS="z"><TD CLASS="l">346</TD><TD>                                        Distribution d = (Distribution) serv;</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                                        serviceTimes[st][cl] = new double[1]; // This is not load dependent</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                                        if (d.hasMean()) {</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                                                serviceTimes[st][cl][0] = d.getMean();</TD></TR><TR><TD CLASS="l">350</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                                                serviceTimes[st][cl][0] = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                                                res.add(output.getStationNames()[st] + &#34; service time distribution for &#34; + output.getClassNames()[cl]</TD></TR><TR><TD CLASS="l">353</TD><TD>                                                                + &#34; does not have a valid mean value.&#34; + &#34; Service time is set to default value 1&#34;);</TD></TR><TR><TD CLASS="l">354</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>                                } else if (serv instanceof ZeroStrategy) {</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                                        serviceTimes[st][cl] = new double[1];</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>                                        serviceTimes[st][cl][0] = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                                } else if (serv instanceof LDStrategy) {</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>                                        LDStrategy lds = (LDStrategy) serv;</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>                                        if (output.isClosed() &amp;&amp; !output.isMultiClass()) {</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                                                int pop = input.getClassPopulation(classKeys.get(cl)).intValue();</TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>                                                serviceTimes[st][cl] = new double[pop]; // This is load dependent</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                                                stationTypes[st] = ExactConstants.STATION_LD;</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>                                                for (int i = 0; i &lt; pop; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                                                        serviceTimes[st][cl][i] = lds.getMeanValue(i);</TD></TR><TR><TD CLASS="l">366</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                                                serviceTimes[st][cl] = new double[1]; // This is not load dependent</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>                                                serviceTimes[st][cl][0] = lds.getMeanValue(1);</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                                                res.add(&#34;LD stations are supported only if model is closed and &#34; + &#34;single class. &#34; + stationNames[st]</TD></TR><TR><TD CLASS="l">371</TD><TD>                                                                + &#34; was converted to a LI station.&#34;);</TD></TR><TR><TD CLASS="l">372</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">373</TD><TD>                                }</TD></TR><TR><TD CLASS="l">374</TD><TD>                        }</TD></TR><TR><TD CLASS="l">375</TD><TD>                }</TD></TR><TR><TD CLASS="l">376</TD><TD>                // Sets extracted values to output</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                output.setStationNames(stationNames);</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                stationNames = null;</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                output.setStationServers(stationServers);</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                stationServers = null;</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>                output.setStationTypes(stationTypes);</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                stationTypes = null;</TD></TR><TR CLASS="z"><TD CLASS="l">383</TD><TD>                output.setServiceTimes(serviceTimes);</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>                serviceTimes = null;</TD></TR><TR><TD CLASS="l">385</TD><TD> </TD></TR><TR><TD CLASS="l">386</TD><TD>                // Now calculates visits starting from routing.</TD></TR><TR><TD CLASS="l">387</TD><TD>                Vector&lt;Object&gt; stations; // This is not equivalent to stationKeys as routers are considered</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                double[][] visits = new double[stationNum][classNum];</TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>                double[] vis = null; // array used to store results of mldivide</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>                for (int cl = 0; cl &lt; classNum; cl++) {</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                        if (output.getClassTypes()[cl] == ExactConstants.CLASS_OPEN) {</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                                stations = input.getStationKeysNoSourceSink();</TD></TR><TR><TD CLASS="l">393</TD><TD>                                // Open class, must calculate routing from source</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                                Object refStat = input.getClassRefStation(classKeys.get(cl));</TD></TR><TR><TD CLASS="l">395</TD><TD>                                double[] p0;</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>                                if (refStat == null) {</TD></TR><TR><TD CLASS="l">397</TD><TD>                                        // Reference station for this class was not set</TD></TR><TR CLASS="z"><TD CLASS="l">398</TD><TD>                                        Vector&lt;Object&gt; sources = input.getStationKeysSource();</TD></TR><TR CLASS="z"><TD CLASS="l">399</TD><TD>                                        if (sources.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                                                refStat = sources.get(0);</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                                                res.add(&#34;Reference station for &#34; + output.getClassNames()[cl] + &#34; was &#34; + &#34;not set. &#34; + input.getStationName(refStat)</TD></TR><TR><TD CLASS="l">402</TD><TD>                                                                + &#34; was chosen.&#34;);</TD></TR><TR><TD CLASS="l">403</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>                                                res.add(&#34;Reference station for &#34; + output.getClassNames()[cl] + &#34; was &#34; + &#34;not set. &#34; + output.getStationNames()[0]</TD></TR><TR><TD CLASS="l">405</TD><TD>                                                                + &#34; was chosen.&#34;);</TD></TR><TR><TD CLASS="l">406</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">407</TD><TD>                                }</TD></TR><TR><TD CLASS="l">408</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>                                if (refStat != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">410</TD><TD>                                        p0 = getRoutingProbability(refStat, classKeys.get(cl), input, stations, res);</TD></TR><TR><TD CLASS="l">411</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>                                        p0 = new double[stations.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>                                        p0[0] = 1; // Assumes that all jobs enters in first station</TD></TR><TR><TD CLASS="l">414</TD><TD>                                }</TD></TR><TR><TD CLASS="l">415</TD><TD>                                try {</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>                                        Matrix b = new Matrix(p0, 1);</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>                                        Matrix P = new Matrix(buildProbabilityMatrix(stations, input, classKeys.get(cl), res));</TD></TR><TR><TD CLASS="l">418</TD><TD>                                        // V = (P-eye(3))' \ (-b') where \ is &#34;mldivide&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                                        Matrix V = P.minus(Matrix.identity(stations.size(), stations.size())).solveTranspose(b.uminus());</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>                                        vis = V.getColumnPackedCopy();</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                                } catch (Exception e) {</TD></TR><TR><TD CLASS="l">422</TD><TD>                                        // Matrix is singular</TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>                                        res.add(&#34;Cannot compute correctly visits for &#34; + output.getClassNames()[cl] + &#34; as&#34; + &#34; network thopology was badly specified&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>                                }</TD></TR><TR><TD CLASS="l">425</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">427</TD><TD>                                // Closed class, system is indefinded, so sets visits to reference station to</TD></TR><TR><TD CLASS="l">428</TD><TD>                                // 1 and builds a smaller P matrix</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>                                stations = new Vector&lt;Object&gt;(input.getStationKeysNoSourceSink());</TD></TR><TR><TD CLASS="l">430</TD><TD>                                // Finds reference station</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                                Object refStat = input.getClassRefStation(classKeys.get(cl));</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                                if (refStat == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                                        refStat = stations.get(0);</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                                        res.add(&#34;Reference station for &#34; + output.getClassNames()[cl] + &#34; was &#34; + &#34;not set. &#34; + input.getStationName(refStat)</TD></TR><TR><TD CLASS="l">435</TD><TD>                                                        + &#34; was chosen.&#34;);</TD></TR><TR><TD CLASS="l">436</TD><TD>                                }</TD></TR><TR><TD CLASS="l">437</TD><TD> </TD></TR><TR><TD CLASS="l">438</TD><TD>                                // Sets visits to reference station (if allowed) to 1</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                                if (stationKeys.contains(refStat)) {</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                                        visits[stationKeys.lastIndexOf(refStat)][cl] = 1;</TD></TR><TR><TD CLASS="l">441</TD><TD>                                }</TD></TR><TR><TD CLASS="l">442</TD><TD>                                // Removes reference station from stations vector and computes p0</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>                                stations.remove(refStat);</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                                double[] p0 = getRoutingProbability(refStat, classKeys.get(cl), input, stations, res);</TD></TR><TR><TD CLASS="l">445</TD><TD> </TD></TR><TR><TD CLASS="l">446</TD><TD>                                try {</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                                        Matrix b = new Matrix(p0, 1);</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                                        Matrix P = new Matrix(buildProbabilityMatrix(stations, input, classKeys.get(cl), res));</TD></TR><TR><TD CLASS="l">449</TD><TD>                                        // V = (P-eye(3))' \ (-b') where \ is &#34;mldivide&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                                        Matrix V = P.minus(Matrix.identity(stations.size(), stations.size())).solveTranspose(b.uminus());</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>                                        vis = V.getColumnPackedCopy();</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                                } catch (Exception e) {</TD></TR><TR><TD CLASS="l">453</TD><TD>                                        // Matrix is singular</TD></TR><TR CLASS="z"><TD CLASS="l">454</TD><TD>                                        res.add(&#34;Cannot compute correctly visits for &#34; + output.getClassNames()[cl] + &#34; as&#34; + &#34; network thopology was badly specified&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                                }</TD></TR><TR><TD CLASS="l">456</TD><TD>                        }</TD></TR><TR><TD CLASS="l">457</TD><TD> </TD></TR><TR><TD CLASS="l">458</TD><TD>                        // Puts computed values into visits matrix. Rounds at 1e-10 for machine precision issues</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                        if (vis != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                                for (int i = 0; i &lt; vis.length; i++) {</TD></TR><TR><TD CLASS="l">461</TD><TD>                                        // Skips not allowed components (Routers, Terminals, Fork, Join....)</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                                        if (stationKeys.contains(stations.get(i))) {</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                                                visits[stationKeys.lastIndexOf(stations.get(i))][cl] = 1e-10 * Math.round(vis[i] * 1e10);</TD></TR><TR><TD CLASS="l">464</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">465</TD><TD>                                }</TD></TR><TR><TD CLASS="l">466</TD><TD>                        }</TD></TR><TR><TD CLASS="l">467</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                output.setVisits(visits);</TD></TR><TR CLASS="z"><TD CLASS="l">469</TD><TD>                return res;</TD></TR><TR><TD CLASS="l">470</TD><TD>        }</TD></TR><TR><TD CLASS="l">471</TD><TD> </TD></TR><TR><TD CLASS="l">472</TD><TD>        /**</TD></TR><TR><TD CLASS="l">473</TD><TD>         * This method will return a reachability vector for given station and given class</TD></TR><TR><TD CLASS="l">474</TD><TD>         * @param stationKey search's key for given station</TD></TR><TR><TD CLASS="l">475</TD><TD>         * @param classKey search's key for given class</TD></TR><TR><TD CLASS="l">476</TD><TD>         * @param model model data structure</TD></TR><TR><TD CLASS="l">477</TD><TD>         * @param stations vector with ordered station keys (the same order is used in output array)</TD></TR><TR><TD CLASS="l"><A NAME="5">478</A></TD><TD>         * @param warnings vector Vector to store warnings found during computation</TD></TR><TR><TD CLASS="l">479</TD><TD>         * @return an array with probability to reach each other station starting from given station</TD></TR><TR><TD CLASS="l">480</TD><TD>         */</TD></TR><TR><TD CLASS="l">481</TD><TD>        private static double[] getRoutingProbability(Object stationKey, Object classKey, CommonModel model, List&lt;Object&gt; stations, List&lt;String&gt; warnings) {</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>                double[] p = new double[stations.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                RoutingStrategy strategy = (RoutingStrategy) model.getRoutingStrategy(stationKey, classKey);</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>                if (strategy instanceof ProbabilityRouting &amp;&amp; !model.getStationType(stationKey).equals(CommonConstants.STATION_TYPE_FORK)) {</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                        Map routingMap = strategy.getValues();</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>                        Iterator it = routingMap.keySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                        while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>                                Object dest = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>                                if (stations.lastIndexOf(dest) &gt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">490</TD><TD>                                        p[stations.lastIndexOf(dest)] = ((Double) routingMap.get(dest)).doubleValue();</TD></TR><TR><TD CLASS="l">491</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>                        if (model.getStationType(stationKey).equals(CommonConstants.STATION_TYPE_FORK)) {</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                                warnings.add(&#34;Fork-Join are not supported in JMVA. They are considered as routers.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                        } else if (!(strategy instanceof RandomRouting)) {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                                warnings.add(&#34;\&#34;&#34; + strategy.getName() + &#34;\&#34; routing strategy in &#34; + model.getClassName(classKey) + &#34; for &#34;</TD></TR><TR><TD CLASS="l">498</TD><TD>                                                + model.getStationName(stationKey) + &#34; is not allowed. This was considered as RandomRouting&#34;);</TD></TR><TR><TD CLASS="l">499</TD><TD>                        }</TD></TR><TR><TD CLASS="l">500</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>                        Vector&lt;Object&gt; links = model.getForwardConnections(stationKey);</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>                        int linksNum = links.size();</TD></TR><TR><TD CLASS="l">503</TD><TD>                        // Now ignores sinks for closed classes</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>                        if (model.getClassType(classKey) == CommonConstants.CLASS_TYPE_CLOSED) {</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>                                for (int i = 0; i &lt; links.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>                                        if (model.getStationType(links.get(i)).equals(CommonConstants.STATION_TYPE_SINK)) {</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                                                linksNum--;</TD></TR><TR><TD CLASS="l">508</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">509</TD><TD>                                }</TD></TR><TR><TD CLASS="l">510</TD><TD>                        }</TD></TR><TR><TD CLASS="l">511</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                        double weight = 1.0 / linksNum;</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>                        for (int i = 0; i &lt; links.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>                                if (stations.contains(links.get(i))) {</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>                                        p[stations.lastIndexOf(links.get(i))] = weight;</TD></TR><TR><TD CLASS="l">516</TD><TD>                                }</TD></TR><TR><TD CLASS="l">517</TD><TD>                        }</TD></TR><TR><TD CLASS="l">518</TD><TD>                }</TD></TR><TR><TD CLASS="l">519</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>                return p;</TD></TR><TR><TD CLASS="l">521</TD><TD>        }</TD></TR><TR><TD CLASS="l">522</TD><TD> </TD></TR><TR><TD CLASS="l">523</TD><TD>        /**</TD></TR><TR><TD CLASS="l">524</TD><TD>         * Builds a routing probability matrix for a given set of stations</TD></TR><TR><TD CLASS="l">525</TD><TD>         * @param stations stations to be considered</TD></TR><TR><TD CLASS="l">526</TD><TD>         * @param model data structure</TD></TR><TR><TD CLASS="l">527</TD><TD>         * @param classKey search's key for target class</TD></TR><TR><TD CLASS="l"><A NAME="2">528</A></TD><TD>         * @param warnings Vector where computation warnings must be put</TD></TR><TR><TD CLASS="l">529</TD><TD>         * @return computated routing probability matrix</TD></TR><TR><TD CLASS="l">530</TD><TD>         */</TD></TR><TR><TD CLASS="l">531</TD><TD>        private static double[][] buildProbabilityMatrix(List&lt;Object&gt; stations, CommonModel model, Object classKey, List&lt;String&gt; warnings) {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                double[][] matrix = new double[stations.size()][stations.size()];</TD></TR><TR><TD CLASS="l">533</TD><TD>                double[] tmp;</TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>                for (int i = 0; i &lt; stations.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">535</TD><TD>                        tmp = getRoutingProbability(stations.get(i), classKey, model, stations, warnings);</TD></TR><TR CLASS="z"><TD CLASS="l">536</TD><TD>                        System.arraycopy(tmp, 0, matrix[i], 0, tmp.length);</TD></TR><TR><TD CLASS="l">537</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>                return matrix;</TD></TR><TR><TD CLASS="l">539</TD><TD>        }</TD></TR><TR><TD CLASS="l">540</TD><TD>        // ----------------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">541</TD><TD> </TD></TR><TR><TD CLASS="l">542</TD><TD>        // --- Methods for conversion JABA --&gt; JMVA -----------------------------------------------</TD></TR><TR><TD CLASS="l">543</TD><TD> </TD></TR><TR><TD CLASS="l">544</TD><TD>        // ----------------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">545</TD><TD> </TD></TR><TR><TD CLASS="l">546</TD><TD>        // --- Methods for conversion JMVA --&gt; JABA -----------------------------------------------</TD></TR><TR><TD CLASS="l">547</TD><TD> </TD></TR><TR><TD CLASS="l">548</TD><TD>        // ----------------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">549</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="34.html">jmt.gui.common.definitions</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>