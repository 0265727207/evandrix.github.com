<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="21.html">jmt.engine.math.parser</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Parser.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Parser.java</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/923)</TD><TD CLASS="h">0%   (0/170)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Parser</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/839)</TD><TD CLASS="h">0%   (0/151)</TD></TR><TR><TD CLASS="f"><A HREF="#1">E (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">F (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3">G (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">H (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#0">Parser (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">Parser (String, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#7">S (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">T (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#9">U (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/126)</TD><TD CLASS="h">0%   (0/27)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">convertInput (String): char []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/55)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#b">detectImplicitMult (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">getExpression (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#d">getInputString (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">getParsedFunctions (): HashSet</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getParsedVariables (): HashSet</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getTree (): ExpressionNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getValue (): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">isBracket (char): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">isEndOfExpression (char): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">isNumber (char): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#15">isOperator (char): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">isText (char): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">parse (): Parser$Element</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/286)</TD><TD CLASS="h">0%   (0/35)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">setVariable (String, double): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#19">Parser$Element</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/84)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#19">Parser$Element (Parser, char): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1b">Parser$Element (Parser, char, String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#1c">Parser$Element (Parser, char, double): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1d">Parser$Element (Parser, char, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#1e">getToken (): char</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/**    </TD></TR><TR><TD CLASS="l">2</TD><TD>  * Copyright 2006 Bertoli Marco</TD></TR><TR><TD CLASS="l">3</TD><TD> </TD></TR><TR><TD CLASS="l">4</TD><TD>  *  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);</TD></TR><TR><TD CLASS="l">5</TD><TD>  *  you may not use this file except in compliance with the License.</TD></TR><TR><TD CLASS="l">6</TD><TD>  *  You may obtain a copy of the License at</TD></TR><TR><TD CLASS="l">7</TD><TD> </TD></TR><TR><TD CLASS="l">8</TD><TD>  *  http://www.apache.org/licenses/LICENSE-2.0</TD></TR><TR><TD CLASS="l">9</TD><TD> </TD></TR><TR><TD CLASS="l">10</TD><TD>  *  Unless required by applicable law or agreed to in writing, software</TD></TR><TR><TD CLASS="l">11</TD><TD>  *  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</TD></TR><TR><TD CLASS="l">12</TD><TD>  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</TD></TR><TR><TD CLASS="l">13</TD><TD>  *  See the License for the specific language governing permissions and</TD></TR><TR><TD CLASS="l">14</TD><TD>  *  limitations under the License.</TD></TR><TR><TD CLASS="l">15</TD><TD>  */</TD></TR><TR><TD CLASS="l">16</TD><TD>package jmt.engine.math.parser;</TD></TR><TR><TD CLASS="l">17</TD><TD> </TD></TR><TR><TD CLASS="l">18</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>/**</TD></TR><TR><TD CLASS="l">21</TD><TD> * &lt;p&gt;&lt;b&gt;Name:&lt;/b&gt; Parser&lt;/p&gt; </TD></TR><TR><TD CLASS="l">22</TD><TD> * &lt;p&gt;&lt;b&gt;Description:&lt;/b&gt; </TD></TR><TR><TD CLASS="l">23</TD><TD> * Simple Java arithmetic expression parser and ELL(1) grammar syntactical analizer and evaluator.</TD></TR><TR><TD CLASS="l">24</TD><TD> * Parser supports detection of implicit multiplication when a constant is followed by a variable or function.</TD></TR><TR><TD CLASS="l">25</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">26</TD><TD> * &lt;p&gt;&lt;b&gt;Grammar:&lt;/b&gt;&lt;br&gt;</TD></TR><TR><TD CLASS="l">27</TD><TD> * S -&amp;gt; E (('+' | '-') E)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">28</TD><TD> * E -&amp;gt; G ('*' G)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">29</TD><TD> * G -&amp;gt; H ('/' H)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">30</TD><TD> * H -&amp;gt; T ('%' T)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">31</TD><TD> * T -&amp;gt; F | '-' F&lt;br&gt;</TD></TR><TR><TD CLASS="l">32</TD><TD> * F -&amp;gt; U ('^' U)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">33</TD><TD> * U -&amp;gt; function '(' S ')' | number | '(' S ')' | variable&lt;br&gt;</TD></TR><TR><TD CLASS="l">34</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">35</TD><TD> * &lt;p&gt;&lt;b&gt;Date:&lt;/b&gt; 08/dic/06</TD></TR><TR><TD CLASS="l">36</TD><TD> * &lt;b&gt;Time:&lt;/b&gt; 13:58:28&lt;/p&gt;</TD></TR><TR><TD CLASS="l">37</TD><TD> * @author Bertoli Marco</TD></TR><TR><TD CLASS="l">38</TD><TD> * @version 1.0</TD></TR><TR><TD CLASS="l">39</TD><TD> */</TD></TR><TR><TD CLASS="l">40</TD><TD>public class Parser {</TD></TR><TR><TD CLASS="l">41</TD><TD>        // Special tokens</TD></TR><TR><TD CLASS="l">42</TD><TD>        private static final char TERM = '@'; // Input end character</TD></TR><TR><TD CLASS="l">43</TD><TD>        private static final char NUM = 'n'; // number</TD></TR><TR><TD CLASS="l">44</TD><TD>        private static final char FUNC = 'f'; // function</TD></TR><TR><TD CLASS="l">45</TD><TD>        private static final char VAR = 'x'; // variable</TD></TR><TR><TD CLASS="l">46</TD><TD>        private static final char OP_BRACKET = '('; // open bracket</TD></TR><TR><TD CLASS="l">47</TD><TD>        private static final char CL_BRACKET = ')'; // closed bracket</TD></TR><TR><TD CLASS="l">48</TD><TD> </TD></TR><TR><TD CLASS="l">49</TD><TD>        private char[] input;</TD></TR><TR><TD CLASS="l">50</TD><TD>        private boolean error;</TD></TR><TR><TD CLASS="l">51</TD><TD>        private int inp_cur; // Current input position</TD></TR><TR><TD CLASS="l">52</TD><TD>        private Element cc; // Current character</TD></TR><TR><TD CLASS="l">53</TD><TD>        private ExpressionNode root; // Root of expression tree</TD></TR><TR><TD CLASS="l">54</TD><TD> </TD></TR><TR><TD CLASS="l">55</TD><TD>        private HashSet&lt;String&gt; functions; // Used functions</TD></TR><TR><TD CLASS="l">56</TD><TD>        private HashSet&lt;String&gt; variables; // Used variables</TD></TR><TR><TD CLASS="l">57</TD><TD> </TD></TR><TR><TD CLASS="l">58</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="0">59</A></TD><TD>         * Class constructor</TD></TR><TR><TD CLASS="l">60</TD><TD>         * @param str Input string to be analyzed</TD></TR><TR><TD CLASS="l">61</TD><TD>         */</TD></TR><TR><TD CLASS="l">62</TD><TD>        public Parser(String str) {</TD></TR><TR CLASS="z"><TD CLASS="l">63</TD><TD>                this(str, false);</TD></TR><TR CLASS="z"><TD CLASS="l">64</TD><TD>        }</TD></TR><TR><TD CLASS="l">65</TD><TD> </TD></TR><TR><TD CLASS="l">66</TD><TD>        /**</TD></TR><TR><TD CLASS="l">67</TD><TD>         * Class constructor</TD></TR><TR><TD CLASS="l">68</TD><TD>         * @param str Input string to be analyzed</TD></TR><TR><TD CLASS="l"><A NAME="6">69</A></TD><TD>         * @param error if true, an exception is raised when value is get</TD></TR><TR><TD CLASS="l">70</TD><TD>         * from a variable not initialized. If false, that variable is</TD></TR><TR><TD CLASS="l">71</TD><TD>         * considered as zero.</TD></TR><TR><TD CLASS="l">72</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">73</TD><TD>        public Parser(String str, boolean error) {</TD></TR><TR CLASS="z"><TD CLASS="l">74</TD><TD>                input = convertInput(str);</TD></TR><TR CLASS="z"><TD CLASS="l">75</TD><TD>                root = null;</TD></TR><TR CLASS="z"><TD CLASS="l">76</TD><TD>                inp_cur = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">77</TD><TD>                this.error = error;</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>                functions = new HashSet&lt;String&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">79</TD><TD>                variables = new HashSet&lt;String&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">80</TD><TD>        }</TD></TR><TR><TD CLASS="l">81</TD><TD> </TD></TR><TR><TD CLASS="l">82</TD><TD>        /**</TD></TR><TR><TD CLASS="l">83</TD><TD>         * Converts input string in a character array and removes unsupported characters</TD></TR><TR><TD CLASS="l"><A NAME="a">84</A></TD><TD>         * @param str input string</TD></TR><TR><TD CLASS="l">85</TD><TD>         * @return converted string, terminated by TERM character</TD></TR><TR><TD CLASS="l">86</TD><TD>         */</TD></TR><TR><TD CLASS="l">87</TD><TD>        protected char[] convertInput(String str) {</TD></TR><TR CLASS="z"><TD CLASS="l">88</TD><TD>                char[] input = str.toCharArray();</TD></TR><TR CLASS="z"><TD CLASS="l">89</TD><TD>                char[] output = new char[input.length + 1]; // One more space for terminator</TD></TR><TR CLASS="z"><TD CLASS="l">90</TD><TD>                int pos = 0; // Position on output</TD></TR><TR CLASS="z"><TD CLASS="l">91</TD><TD>                for (char c : input) {</TD></TR><TR CLASS="z"><TD CLASS="l">92</TD><TD>                        if (isNumber(c) || isOperator(c) || isText(c) || isBracket(c)) {</TD></TR><TR CLASS="z"><TD CLASS="l">93</TD><TD>                                output[pos++] = c;</TD></TR><TR><TD CLASS="l">94</TD><TD>                        }</TD></TR><TR><TD CLASS="l">95</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">96</TD><TD>                output[pos++] = TERM;</TD></TR><TR CLASS="z"><TD CLASS="l">97</TD><TD>                return output;</TD></TR><TR><TD CLASS="l">98</TD><TD>        }</TD></TR><TR><TD CLASS="l">99</TD><TD> </TD></TR><TR><TD CLASS="l">100</TD><TD>        /**</TD></TR><TR><TD CLASS="l">101</TD><TD>         * Returns the tree of the function generated by the parser</TD></TR><TR><TD CLASS="l"><A NAME="10">102</A></TD><TD>         * @return Node root node of parsed tree</TD></TR><TR><TD CLASS="l">103</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">104</TD><TD>         */</TD></TR><TR><TD CLASS="l">105</TD><TD>        public ExpressionNode getTree() throws ParseError {</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>                if (root == null) { // Function need parsing</TD></TR><TR CLASS="z"><TD CLASS="l">107</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">108</TD><TD>                        root = S();</TD></TR><TR CLASS="z"><TD CLASS="l">109</TD><TD>                        if (!isEndOfExpression(cc.getToken())) {</TD></TR><TR CLASS="z"><TD CLASS="l">110</TD><TD>                                throw new ParseError(&#34;Expecting operator or end of input&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">111</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>                        return root;</TD></TR><TR><TD CLASS="l">113</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>                        return root; // Parsing was already performed before</TD></TR><TR><TD CLASS="l">115</TD><TD>                }</TD></TR><TR><TD CLASS="l">116</TD><TD>        }</TD></TR><TR><TD CLASS="l">117</TD><TD> </TD></TR><TR><TD CLASS="l">118</TD><TD>        /**</TD></TR><TR><TD CLASS="l">119</TD><TD>         * Returns if input character is a number</TD></TR><TR><TD CLASS="l"><A NAME="14">120</A></TD><TD>         * @param c input character</TD></TR><TR><TD CLASS="l">121</TD><TD>         * @return truth value</TD></TR><TR><TD CLASS="l">122</TD><TD>         */</TD></TR><TR><TD CLASS="l">123</TD><TD>        private boolean isNumber(char c) {</TD></TR><TR CLASS="z"><TD CLASS="l">124</TD><TD>                if ((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.') {</TD></TR><TR CLASS="z"><TD CLASS="l">125</TD><TD>                        return true;</TD></TR><TR><TD CLASS="l">126</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">128</TD><TD>        }</TD></TR><TR><TD CLASS="l">129</TD><TD> </TD></TR><TR><TD CLASS="l">130</TD><TD>        /**</TD></TR><TR><TD CLASS="l">131</TD><TD>         * Returns if imput character character is an operator</TD></TR><TR><TD CLASS="l"><A NAME="15">132</A></TD><TD>         * @param c input character</TD></TR><TR><TD CLASS="l">133</TD><TD>         * @return truth value</TD></TR><TR><TD CLASS="l">134</TD><TD>         */</TD></TR><TR><TD CLASS="l">135</TD><TD>        private boolean isOperator(char c) {</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>                for (char element : OperatorNode.OPERATIONS) {</TD></TR><TR CLASS="z"><TD CLASS="l">137</TD><TD>                        if (c == element) {</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">139</TD><TD>                        }</TD></TR><TR><TD CLASS="l">140</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">142</TD><TD>        }</TD></TR><TR><TD CLASS="l">143</TD><TD> </TD></TR><TR><TD CLASS="l">144</TD><TD>        /**</TD></TR><TR><TD CLASS="l">145</TD><TD>         * Returns if input character is valid text</TD></TR><TR><TD CLASS="l"><A NAME="16">146</A></TD><TD>         * @param c input character</TD></TR><TR><TD CLASS="l">147</TD><TD>         * @return truth value</TD></TR><TR><TD CLASS="l">148</TD><TD>         */</TD></TR><TR><TD CLASS="l">149</TD><TD>        private boolean isText(char c) {</TD></TR><TR CLASS="z"><TD CLASS="l">150</TD><TD>                return ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_');</TD></TR><TR><TD CLASS="l">151</TD><TD>        }</TD></TR><TR><TD CLASS="l">152</TD><TD> </TD></TR><TR><TD CLASS="l">153</TD><TD>        /**</TD></TR><TR><TD CLASS="l">154</TD><TD>         * Returns if input character is a bracket</TD></TR><TR><TD CLASS="l"><A NAME="12">155</A></TD><TD>         * @param c character</TD></TR><TR><TD CLASS="l">156</TD><TD>         * @return truth value</TD></TR><TR><TD CLASS="l">157</TD><TD>         */</TD></TR><TR><TD CLASS="l">158</TD><TD>        private boolean isBracket(char c) {</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>                return (c == OP_BRACKET) || (c == CL_BRACKET);</TD></TR><TR><TD CLASS="l">160</TD><TD>        }</TD></TR><TR><TD CLASS="l">161</TD><TD> </TD></TR><TR><TD CLASS="l">162</TD><TD>        /**</TD></TR><TR><TD CLASS="l">163</TD><TD>         * Returns if imput character is the last one (TERM)</TD></TR><TR><TD CLASS="l"><A NAME="13">164</A></TD><TD>         * @param c input character</TD></TR><TR><TD CLASS="l">165</TD><TD>         * @return truth value</TD></TR><TR><TD CLASS="l">166</TD><TD>         */</TD></TR><TR><TD CLASS="l">167</TD><TD>        private boolean isEndOfExpression(char c) {</TD></TR><TR CLASS="z"><TD CLASS="l">168</TD><TD>                return c == TERM;</TD></TR><TR><TD CLASS="l">169</TD><TD>        }</TD></TR><TR><TD CLASS="l">170</TD><TD> </TD></TR><TR><TD CLASS="l">171</TD><TD>        /**</TD></TR><TR><TD CLASS="l">172</TD><TD>         * Perform parsing of input string</TD></TR><TR><TD CLASS="l"><A NAME="17">173</A></TD><TD>         * @return Element</TD></TR><TR><TD CLASS="l">174</TD><TD>         */</TD></TR><TR><TD CLASS="l">175</TD><TD>        private Element parse() {</TD></TR><TR><TD CLASS="l">176</TD><TD>                // Detects implicit multiplication</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                if (detectImplicitMult()) {</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                        return new Element('*');</TD></TR><TR><TD CLASS="l">179</TD><TD>                }</TD></TR><TR><TD CLASS="l">180</TD><TD>                // Matches operators, brackets and termination character</TD></TR><TR CLASS="z"><TD CLASS="l">181</TD><TD>                if (isOperator(input[inp_cur]) || isBracket(input[inp_cur]) || isEndOfExpression(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">182</TD><TD>                        return new Element(input[inp_cur++]);</TD></TR><TR><TD CLASS="l">183</TD><TD>                }</TD></TR><TR><TD CLASS="l">184</TD><TD> </TD></TR><TR><TD CLASS="l">185</TD><TD>                // Matches numbers</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>                if (isNumber(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">187</TD><TD>                        int tmp = inp_cur++;</TD></TR><TR><TD CLASS="l">188</TD><TD>                        // Finds the end of number</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                        while (isNumber(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                                inp_cur++;</TD></TR><TR><TD CLASS="l">191</TD><TD>                        }</TD></TR><TR><TD CLASS="l">192</TD><TD>                        // Eventual exponential</TD></TR><TR CLASS="z"><TD CLASS="l">193</TD><TD>                        if (Character.toLowerCase(input[inp_cur]) == 'e') {</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>                                if (input[inp_cur + 1] == '-' || isNumber(input[inp_cur + 1])) {</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>                                        inp_cur += 2;</TD></TR><TR><TD CLASS="l">196</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                                while (isNumber(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                                        inp_cur++;</TD></TR><TR><TD CLASS="l">199</TD><TD>                                }</TD></TR><TR><TD CLASS="l">200</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                        String s = new String(input, tmp, inp_cur - tmp);</TD></TR><TR><TD CLASS="l">202</TD><TD>                        double d;</TD></TR><TR><TD CLASS="l">203</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                                d = Double.valueOf(s).doubleValue();</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>                        } catch (NumberFormatException ex) {</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                                throw new ParseError(&#34;Invalid number: &#34; + s, inp_cur);</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>                        return new Element(NUM, d);</TD></TR><TR><TD CLASS="l">209</TD><TD>                }</TD></TR><TR><TD CLASS="l">210</TD><TD> </TD></TR><TR><TD CLASS="l">211</TD><TD>                // Matches text (functions or variables or built-in constants)</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                if (isText(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                        int tmp = inp_cur++;</TD></TR><TR><TD CLASS="l">214</TD><TD>                        // Finds the end of text</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>                        while (isText(input[inp_cur]) || isNumber(input[inp_cur])) {</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>                                inp_cur++;</TD></TR><TR><TD CLASS="l">217</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                        String s = new String(input, tmp, inp_cur - tmp);</TD></TR><TR><TD CLASS="l">219</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">220</TD><TD>                        String lower = s.toLowerCase();</TD></TR><TR><TD CLASS="l">221</TD><TD>                        // Now searches if this string is a function</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                        for (int i = 0; i &lt; FunctionNode.FUNCTIONS.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                                if (lower.equals(FunctionNode.FUNCTIONS[i])) {</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>                                        functions.add(FunctionNode.FUNCTIONS[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>                                        return new Element(FUNC, i);</TD></TR><TR><TD CLASS="l">226</TD><TD>                                }</TD></TR><TR><TD CLASS="l">227</TD><TD>                        }</TD></TR><TR><TD CLASS="l">228</TD><TD> </TD></TR><TR><TD CLASS="l">229</TD><TD>                        // Now searches if this string is a built-in constant</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>                        for (int i = 0; i &lt; ConstantNode.CONSTANTS.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">231</TD><TD>                                if (lower.equals(ConstantNode.CONSTANTS[i])) {</TD></TR><TR CLASS="z"><TD CLASS="l">232</TD><TD>                                        return new Element(NUM, i);</TD></TR><TR><TD CLASS="l">233</TD><TD>                                }</TD></TR><TR><TD CLASS="l">234</TD><TD>                        }</TD></TR><TR><TD CLASS="l">235</TD><TD> </TD></TR><TR><TD CLASS="l">236</TD><TD>                        // String was not a function, so treat it as a variable</TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>                        variables.add(s);</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>                        return new Element(VAR, s);</TD></TR><TR><TD CLASS="l">239</TD><TD>                }</TD></TR><TR><TD CLASS="l">240</TD><TD>                //At this point everything not recognized is an error</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                throw new ParseError(&#34;Unrecognized identifier&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">242</TD><TD>        }</TD></TR><TR><TD CLASS="l">243</TD><TD> </TD></TR><TR><TD CLASS="l">244</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="b">245</A></TD><TD>         * Helper method to detect implicit multiplication</TD></TR><TR><TD CLASS="l">246</TD><TD>         * @return true only if inplicit multiplication is detected</TD></TR><TR><TD CLASS="l">247</TD><TD>         */</TD></TR><TR><TD CLASS="l">248</TD><TD>        private boolean detectImplicitMult() {</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                if (cc != null &amp;&amp; cc.getToken() == NUM) {</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                        cc = null; // Otherwise we will loop forever</TD></TR><TR><TD CLASS="l">251</TD><TD>                        // Stores old pointer to restore it back</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>                        int old_input = inp_cur;</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>                        Element next = parse();</TD></TR><TR><TD CLASS="l">254</TD><TD>                        // Restores old pointer back</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                        inp_cur = old_input;</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                        if (next.getToken() == VAR || next.getToken() == FUNC) {</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">258</TD><TD>                        }</TD></TR><TR><TD CLASS="l">259</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">261</TD><TD>        }</TD></TR><TR><TD CLASS="l">262</TD><TD> </TD></TR><TR><TD CLASS="l">263</TD><TD>        /**</TD></TR><TR><TD CLASS="l">264</TD><TD>         * Grammar Axiom S&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="7">265</A></TD><TD>         * S -&amp;gt; E (('+' | '-') E)*</TD></TR><TR><TD CLASS="l">266</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">267</TD><TD>         */</TD></TR><TR><TD CLASS="l">268</TD><TD>        private ExpressionNode S() {</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                ExpressionNode current = E();</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                while (cc.getToken() == '+' || cc.getToken() == '-') {</TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>                        char operator = cc.getToken();</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                        current = new OperatorNode(current, E(), operator);</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                return current;</TD></TR><TR><TD CLASS="l">276</TD><TD>        }</TD></TR><TR><TD CLASS="l">277</TD><TD> </TD></TR><TR><TD CLASS="l">278</TD><TD>        /**</TD></TR><TR><TD CLASS="l">279</TD><TD>         * Non-terminal E&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="1">280</A></TD><TD>         * E -&amp;gt; G ('*' G)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">281</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">282</TD><TD>         */</TD></TR><TR><TD CLASS="l">283</TD><TD>        private ExpressionNode E() {</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>                ExpressionNode current = G();</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                while (cc.getToken() == '*') {</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                        current = new OperatorNode(current, G(), '*');</TD></TR><TR><TD CLASS="l">288</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>                return current;</TD></TR><TR><TD CLASS="l">290</TD><TD>        }</TD></TR><TR><TD CLASS="l">291</TD><TD> </TD></TR><TR><TD CLASS="l">292</TD><TD>        /**</TD></TR><TR><TD CLASS="l">293</TD><TD>         * Non-terminal G&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="3">294</A></TD><TD>         * G -&amp;gt; H ('/' H)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">295</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">296</TD><TD>         */</TD></TR><TR><TD CLASS="l">297</TD><TD>        private ExpressionNode G() {</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                ExpressionNode current = H();</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                while (cc.getToken() == '/') {</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>                        current = new OperatorNode(current, H(), '/');</TD></TR><TR><TD CLASS="l">302</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                return current;</TD></TR><TR><TD CLASS="l">304</TD><TD>        }</TD></TR><TR><TD CLASS="l">305</TD><TD> </TD></TR><TR><TD CLASS="l">306</TD><TD>        /**</TD></TR><TR><TD CLASS="l">307</TD><TD>         * Non-terminal H&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="4">308</A></TD><TD>         * H -&amp;gt; T ('%' T)*&lt;br&gt;</TD></TR><TR><TD CLASS="l">309</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">310</TD><TD>         */</TD></TR><TR><TD CLASS="l">311</TD><TD>        private ExpressionNode H() {</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>                ExpressionNode current = T();</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                while (cc.getToken() == '%') {</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                        current = new OperatorNode(current, T(), '%');</TD></TR><TR><TD CLASS="l">316</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                return current;</TD></TR><TR><TD CLASS="l">318</TD><TD>        }</TD></TR><TR><TD CLASS="l">319</TD><TD> </TD></TR><TR><TD CLASS="l">320</TD><TD>        /**</TD></TR><TR><TD CLASS="l">321</TD><TD>         * Non-terminal T&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="8">322</A></TD><TD>         * T -&amp;gt; F | '-' F&lt;br&gt;</TD></TR><TR><TD CLASS="l">323</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">324</TD><TD>         */</TD></TR><TR><TD CLASS="l">325</TD><TD>        private ExpressionNode T() {</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                if (cc.getToken() == '-') {</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                        return new FunctionNode(F(), &#34;-&#34;);</TD></TR><TR><TD CLASS="l">329</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                return F();</TD></TR><TR><TD CLASS="l">331</TD><TD>        }</TD></TR><TR><TD CLASS="l">332</TD><TD> </TD></TR><TR><TD CLASS="l">333</TD><TD>        /**</TD></TR><TR><TD CLASS="l">334</TD><TD>         * Non-terminal F&lt;br&gt;</TD></TR><TR><TD CLASS="l">335</TD><TD>         * F -&amp;gt; U ('^' U)*</TD></TR><TR><TD CLASS="l"><A NAME="2">336</A></TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">337</TD><TD>         */</TD></TR><TR><TD CLASS="l">338</TD><TD>        private ExpressionNode F() {</TD></TR><TR><TD CLASS="l">339</TD><TD>                ExpressionNode left;</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                left = U();</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>                if (cc.getToken() == '^') {</TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                        return new OperatorNode(left, F(), '^');</TD></TR><TR><TD CLASS="l">344</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                return left;</TD></TR><TR><TD CLASS="l">346</TD><TD>        }</TD></TR><TR><TD CLASS="l">347</TD><TD> </TD></TR><TR><TD CLASS="l">348</TD><TD>        /**</TD></TR><TR><TD CLASS="l">349</TD><TD>         * Non-terminal U&lt;br&gt;</TD></TR><TR><TD CLASS="l"><A NAME="9">350</A></TD><TD>         * U -&amp;gt; function '(' S ')' | number | '(' S ')' | variable</TD></TR><TR><TD CLASS="l">351</TD><TD>         * @return Node</TD></TR><TR><TD CLASS="l">352</TD><TD>         */</TD></TR><TR><TD CLASS="l">353</TD><TD>        private ExpressionNode U() {</TD></TR><TR CLASS="z"><TD CLASS="l">354</TD><TD>                switch (cc.getToken()) {</TD></TR><TR><TD CLASS="l">355</TD><TD>                        case NUM:</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                                double n = cc.number;</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>                                int constPosition = cc.position; // Position if this is a built-in constant</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                                cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>                                if (constPosition &gt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>                                        return new ConstantNode(constPosition);</TD></TR><TR><TD CLASS="l">361</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>                                        return new ConstantNode(n);</TD></TR><TR><TD CLASS="l">363</TD><TD>                                }</TD></TR><TR><TD CLASS="l">364</TD><TD>                        case VAR:</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                                String name = cc.name;</TD></TR><TR CLASS="z"><TD CLASS="l">366</TD><TD>                                cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>                                return new VariableNode(name, error);</TD></TR><TR><TD CLASS="l">368</TD><TD>                        case OP_BRACKET:</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>                                cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                                ExpressionNode tmp = S();</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                                if (cc.getToken() == CL_BRACKET) {</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                                        cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">373</TD><TD>                                        return tmp;</TD></TR><TR><TD CLASS="l">374</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                                throw new ParseError(&#34;Semantic Error, expected '&#34; + CL_BRACKET + &#34;'&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">376</TD><TD>                        case FUNC:</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                                int function = cc.position;</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                                cc = parse();</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                                if (cc.getToken() == OP_BRACKET) {</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                                        cc = parse();</TD></TR><TR><TD CLASS="l">381</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                                        throw new ParseError(&#34;Semantic Error, expected '&#34; + OP_BRACKET + &#34;'&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">383</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>                                ExpressionNode tmp2 = S();</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>                                if (cc.getToken() == CL_BRACKET) {</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                                        cc = parse();</TD></TR><TR><TD CLASS="l">387</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                                        throw new ParseError(&#34;Semantic Error, expected '&#34; + CL_BRACKET + &#34;'&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">389</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>                                return new FunctionNode(tmp2, function);</TD></TR><TR><TD CLASS="l">391</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                throw new ParseError(&#34;Semantic Error, expected function or variable or constant or '('&#34;, inp_cur);</TD></TR><TR><TD CLASS="l">393</TD><TD>        }</TD></TR><TR><TD CLASS="l">394</TD><TD> </TD></TR><TR><TD CLASS="l">395</TD><TD>        /**</TD></TR><TR><TD CLASS="l">396</TD><TD>         * Data structure used internally to return parsed elements.</TD></TR><TR><TD CLASS="l">397</TD><TD>         */</TD></TR><TR><TD CLASS="l">398</TD><TD>        private class Element {</TD></TR><TR><TD CLASS="l">399</TD><TD>                private char token;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="19">400</A></TD><TD>                public double number = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                public int position = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>                public String name = null;</TD></TR><TR><TD CLASS="l">403</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1c">404</A></TD><TD>                public Element(char token) {</TD></TR><TR CLASS="z"><TD CLASS="l">405</TD><TD>                        this.token = token;</TD></TR><TR CLASS="z"><TD CLASS="l">406</TD><TD>                }</TD></TR><TR><TD CLASS="l">407</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">408</TD><TD>                public Element(char token, double number) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1b">409</A></TD><TD>                        this.token = token;</TD></TR><TR CLASS="z"><TD CLASS="l">410</TD><TD>                        this.number = number;</TD></TR><TR CLASS="z"><TD CLASS="l">411</TD><TD>                }</TD></TR><TR><TD CLASS="l">412</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>                public Element(char token, String name) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1d">414</A></TD><TD>                        this.token = token;</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>                        this.name = name;</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>                }</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">418</TD><TD>                public Element(char token, int position) {</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                        this.token = token;</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>                        this.position = position;</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                }</TD></TR><TR><TD CLASS="l">422</TD><TD> </TD></TR><TR><TD CLASS="l">423</TD><TD>                /**</TD></TR><TR><TD CLASS="l"><A NAME="1e">424</A></TD><TD>                 * Returns the token</TD></TR><TR><TD CLASS="l">425</TD><TD>                 * @return char</TD></TR><TR><TD CLASS="l">426</TD><TD>                 */</TD></TR><TR><TD CLASS="l">427</TD><TD>                public char getToken() {</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>                        return token;</TD></TR><TR><TD CLASS="l">429</TD><TD>                }</TD></TR><TR><TD CLASS="l">430</TD><TD>        }</TD></TR><TR><TD CLASS="l">431</TD><TD> </TD></TR><TR><TD CLASS="l">432</TD><TD>        /**</TD></TR><TR><TD CLASS="l">433</TD><TD>         * Sets the value for a given variable</TD></TR><TR><TD CLASS="l">434</TD><TD>         * @param name name of the variable to be set (case sensitive)</TD></TR><TR><TD CLASS="l"><A NAME="18">435</A></TD><TD>         * @param value value for the variable</TD></TR><TR><TD CLASS="l">436</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">437</TD><TD>         */</TD></TR><TR><TD CLASS="l">438</TD><TD>        public void setVariable(String name, double value) throws ParseError {</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                getTree();</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                root.setVariable(name, value);</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>        }</TD></TR><TR><TD CLASS="l">442</TD><TD> </TD></TR><TR><TD CLASS="l">443</TD><TD>        /**</TD></TR><TR><TD CLASS="l">444</TD><TD>         * Returns the value for evaluated expression</TD></TR><TR><TD CLASS="l">445</TD><TD>         * @return value of expression</TD></TR><TR><TD CLASS="l">446</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">447</TD><TD>         * @throws EvaluationException if one variable was not initialized and parser was </TD></TR><TR><TD CLASS="l"><A NAME="11">448</A></TD><TD>         * created with &lt;code&gt;error = true&lt;/code&gt;</TD></TR><TR><TD CLASS="l">449</TD><TD>         * @see #Parser(String, boolean)</TD></TR><TR><TD CLASS="l">450</TD><TD>         */</TD></TR><TR><TD CLASS="l">451</TD><TD>        public double getValue() throws ParseError, EvaluationException {</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                getTree();</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>                return root.getValue();</TD></TR><TR><TD CLASS="l">454</TD><TD>        }</TD></TR><TR><TD CLASS="l">455</TD><TD> </TD></TR><TR><TD CLASS="l">456</TD><TD>        /**</TD></TR><TR><TD CLASS="l">457</TD><TD>         * Returns a string rappresentation of parsed expression with the right parentesis</TD></TR><TR><TD CLASS="l"><A NAME="c">458</A></TD><TD>         * @return a string rappresentation of parsed expression with the right parentesis</TD></TR><TR><TD CLASS="l">459</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">460</TD><TD>         */</TD></TR><TR><TD CLASS="l">461</TD><TD>        public String getExpression() throws ParseError {</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                getTree();</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                return root.toString();</TD></TR><TR><TD CLASS="l">464</TD><TD>        }</TD></TR><TR><TD CLASS="l">465</TD><TD> </TD></TR><TR><TD CLASS="l">466</TD><TD>        /**</TD></TR><TR><TD CLASS="l">467</TD><TD>         * Returns a Set of all functions parsed in input string</TD></TR><TR><TD CLASS="l"><A NAME="e">468</A></TD><TD>         * @return a set with all parsed functions</TD></TR><TR><TD CLASS="l">469</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">470</TD><TD>         */</TD></TR><TR><TD CLASS="l">471</TD><TD>        public HashSet&lt;String&gt; getParsedFunctions() throws ParseError {</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>                getTree();</TD></TR><TR CLASS="z"><TD CLASS="l">473</TD><TD>                return functions;</TD></TR><TR><TD CLASS="l">474</TD><TD>        }</TD></TR><TR><TD CLASS="l">475</TD><TD> </TD></TR><TR><TD CLASS="l">476</TD><TD>        /**</TD></TR><TR><TD CLASS="l">477</TD><TD>         * Returns a Set of all variables parsed in input string</TD></TR><TR><TD CLASS="l"><A NAME="f">478</A></TD><TD>         * @return a set with all parsed variables</TD></TR><TR><TD CLASS="l">479</TD><TD>         * @throws ParseError if parsed input string was malformed</TD></TR><TR><TD CLASS="l">480</TD><TD>         */</TD></TR><TR><TD CLASS="l">481</TD><TD>        public HashSet&lt;String&gt; getParsedVariables() throws ParseError {</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>                getTree();</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                return variables;</TD></TR><TR><TD CLASS="l">484</TD><TD>        }</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR><TD CLASS="l">486</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="d">487</A></TD><TD>         * Returns input string, without invalid characters</TD></TR><TR><TD CLASS="l">488</TD><TD>         * @return input string without invalid characters</TD></TR><TR><TD CLASS="l">489</TD><TD>         */</TD></TR><TR><TD CLASS="l">490</TD><TD>        public String getInputString() {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                StringBuffer output = new StringBuffer();</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                for (int i = 0; i &lt; input.length &amp;&amp; input[i] != TERM; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                        output.append(input[i]);</TD></TR><TR><TD CLASS="l">494</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                return output.toString();</TD></TR><TR><TD CLASS="l">496</TD><TD>        }</TD></TR><TR><TD CLASS="l">497</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="21.html">jmt.engine.math.parser</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>