<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="4d.html">jmt.gui.jmodel.controller</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Mediator.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Mediator.java</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/166)</TD><TD CLASS="h">0%   (0/7361)</TD><TD CLASS="h">0%   (0/1359)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Mediator</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/162)</TD><TD CLASS="h">0%   (0/7322)</TD><TD CLASS="h">0%   (0/1354)</TD></TR><TR><TD CLASS="f"><A HREF="#1">InsertCell (Point2D, JmtCell): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">Mediator (JmtJGraph, MainWindow): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/298)</TD><TD CLASS="h">0%   (0/58)</TD></TR><TR><TD CLASS="f"><A HREF="#3">about (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">access$000 (Mediator): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5">activateSelect (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">addCellsToBlockingRegion (Object [], Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#7">addSelectionToNewBlockingRegion (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/108)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">adjustGraph (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/459)</TD><TD CLASS="h">0%   (0/85)</TD></TR><TR><TD CLASS="f"><A HREF="#9">autoscroll (Point): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">avoidOverlappingCell (Object []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#b">changeSimActionsState (boolean, boolean, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">checkForSave (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#d">closeModel (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/150)</TD><TD CLASS="h">0%   (0/41)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">connect (JmtCell, JmtCell): JmtEdge</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#f">connect (JmtCell, JmtCell, boolean): JmtEdge</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/133)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">connect (Point2D, Point2D, PortView, PortView): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/119)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR><TD CLASS="f"><A HREF="#11">copySelection (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">createMenu (): JMTMenuBar</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/201)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#13">createToolbar (): JMTToolBar</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/119)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">cutSelection (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#15">deleteSelected (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/275)</TD><TD CLASS="h">0%   (0/54)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">displayGraphErrMsg (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#17">editMeasures (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">editPAParameters (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#19">editSimulationParameters (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">editUserClasses (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">enableAddBlockingRegion (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">enableCopyAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">enableCutAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">enableDeleteAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">enableEditUserClasses (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">enablePasteAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#21">enableRedoAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">enableRotateAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#23">enableSetRight (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">enableUndoAction (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#25">existCell (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">exit (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#27">fromScreen (Point2D): Point2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">fromScreen (Rectangle2D): Rectangle2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#29">getAbout (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">getAddBlockingRegion (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">getBlockingRegionDefinition (): BlockingRegionDefinition</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">getCellCoordinates (JmtCell): Point2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">getCellDimension (JmtCell): Rectangle2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">getCellFactory (): CellFactory</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">getClassDefinition (): JmodelClassDefinition</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">getCloseModel (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#31">getComponentBar (): JMTToolBar</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">getCopyAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#33">getCutAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">getDeleteAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#35">getEditClickCount (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">getEditDefaults (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#37">getEditMeasures (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">getEditPAParams (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#39">getEditSimParams (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">getEditUserClasses (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">getExit (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">getGraph (): JGraph</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">getGraphBackground (): Color</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">getGraphCursor (): Cursor</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">getGraphGraphics (): Graphics2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">getGraphMarqueeColor (): Color</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#41">getInPortViewAt (int, int): PortView</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">getIsReleased (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#43">getNewModel (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">getNextViewAt (CellView, double, double): CellView</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#45">getOldCursor (): Cursor</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">getOpenHelp (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#47">getOpenModel (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">getOutPortViewAt (int, int): PortView</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#49">getPAProgressWindow (): PAProgressWindow</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">getParent (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">getPasteAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">getPauseSimulation (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">getRedoAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">getResultsWindow (): JFrame</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">getRotate (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">getSaveModel (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#51">getSaveModelAs (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">getSetConnect (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#53">getSetOptions (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">getSetRight (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#55">getSetSelect (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">getShowResults (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#57">getSimulate (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#58">getSimulationDefinition (): SimulationDefinition</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#59">getSolveAnalitic (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">getSolveApp (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">getStationDefinition (): JmodelStationDefinition</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">getStopSimulation (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">getSwitchToWizard (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">getTakeScreenShot (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5f">getTolerance (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#60">getUndoAction (): AbstractJmodelAction</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#61">getUndoManager (): GraphUndoManager</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">getViewOfCell (Object, boolean): CellView</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#63">graphRepaint (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#64">graphRequestFocus (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#65">handleException (Exception): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#66">handlesBlockingRegionDrag (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/179)</TD><TD CLASS="h">0%   (0/35)</TD></TR><TR><TD CLASS="f"><A HREF="#67">isAnimationDisplayable (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#68">isCellEditable (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#69">isCellSelected (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6a">isCellVisible (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6b">isForceMarqueeEvent (MouseEvent): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6c">isGraphEditing (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6d">isGraphEnabled (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6e">isInGroup (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/72)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#6f">isSomethingSelected (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#70">isToggleSelectionEvent (MouseEvent): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#71">newModel (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/175)</TD><TD CLASS="h">0%   (0/44)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#72">openModel (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/129)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR><TD CLASS="f"><A HREF="#73">overlapCells (Point, Dimension): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/62)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#74">overlapCells (Point2D, JmtCell): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#75">pasteSelection (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#76">pauseSimulation (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#77">populateGraph (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/207)</TD><TD CLASS="h">0%   (0/40)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#78">putCellInGoodPlace (JmtCell, int, int, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1572)</TD><TD CLASS="h">0%   (0/229)</TD></TR><TR><TD CLASS="f"><A HREF="#79">putSelectedCellsInGoodPlace (Object [], Integer [], Integer []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/81)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7a">redo (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7b">repositionSons (JmtCell, List, int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/143)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7c">resetMouseState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#7d">rotateComponent (Object []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/86)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7e">saveModel (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#7f">saveModelAs (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#80">searchNext (JmtCell): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/293)</TD><TD CLASS="h">0%   (0/42)</TD></TR><TR><TD CLASS="f"><A HREF="#81">selectAt (MouseEvent): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#82">selectCellForEvent (Object, MouseEvent): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#83">setConnectState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#84">setCopyState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#85">setCursor (Cursor): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#86">setCutState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#87">setGraphCursor (Cursor): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#88">setHandle (CellHandle): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#89">setInsertState (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8a">setIsReleased (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#8b">setMouseListner (GraphMouseListner): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8c">setOldCursor (Cursor): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#8d">setResultsWindow (JFrame): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8e">setSelectState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#8f">setUndoManager (GraphUndoManager): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#90">showClassPanel (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#91">showDefaultsEditor (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#92">showErrorMessage (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#93">showHelp (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/47)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#94">showOPanel (Point): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#95">showRelatedPanel (int, int, Object, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/700)</TD><TD CLASS="h">0%   (0/109)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#96">showResultsWindow (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#97">showResultsWindow (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#98">snap (Point2D): Point2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#99">startEditingAtCell (Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/137)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9a">startSimulation (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/412)</TD><TD CLASS="h">0%   (0/75)</TD></TR><TR><TD CLASS="f"><A HREF="#9b">stopSimulation (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9c">takeScreenShot (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9d">toJMVA (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/74)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9e">toScreen (Point2D): Point2D</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#9f">undo (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a0">updateStationPositions (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#a1">zoomIn (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a2">zoomOut (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#a3">Mediator$1</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#a3">Mediator$1 (Mediator, Mediator): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a5">createEdgeView (Object): EdgeView</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#a6">Mediator$2</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#a6">Mediator$2 (Mediator): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a8">windowClosing (WindowEvent): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/**</TD></TR><TR><TD CLASS="l">2</TD><TD>  * Copyright (C) 2007, Laboratorio di Valutazione delle Prestazioni - Politecnico di Milano</TD></TR><TR><TD CLASS="l">3</TD><TD> </TD></TR><TR><TD CLASS="l">4</TD><TD>  * This program is free software; you can redistribute it and/or modify</TD></TR><TR><TD CLASS="l">5</TD><TD>  * it under the terms of the GNU General Public License as published by</TD></TR><TR><TD CLASS="l">6</TD><TD>  * the Free Software Foundation; either version 2 of the License, or</TD></TR><TR><TD CLASS="l">7</TD><TD>  * (at your option) any later version.</TD></TR><TR><TD CLASS="l">8</TD><TD> </TD></TR><TR><TD CLASS="l">9</TD><TD>  * This program is distributed in the hope that it will be useful,</TD></TR><TR><TD CLASS="l">10</TD><TD>  * but WITHOUT ANY WARRANTY; without even the implied warranty of</TD></TR><TR><TD CLASS="l">11</TD><TD>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</TD></TR><TR><TD CLASS="l">12</TD><TD>  * GNU General Public License for more details.</TD></TR><TR><TD CLASS="l">13</TD><TD> </TD></TR><TR><TD CLASS="l">14</TD><TD>  * You should have received a copy of the GNU General Public License</TD></TR><TR><TD CLASS="l">15</TD><TD>  * along with this program; if not, write to the Free Software</TD></TR><TR><TD CLASS="l">16</TD><TD>  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</TD></TR><TR><TD CLASS="l">17</TD><TD>  */</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>package jmt.gui.jmodel.controller;</TD></TR><TR><TD CLASS="l">20</TD><TD> </TD></TR><TR><TD CLASS="l">21</TD><TD>import java.awt.BorderLayout;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.awt.Color;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.awt.Component;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.awt.Cursor;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.awt.Dimension;</TD></TR><TR><TD CLASS="l">26</TD><TD>import java.awt.Graphics2D;</TD></TR><TR><TD CLASS="l">27</TD><TD>import java.awt.Point;</TD></TR><TR><TD CLASS="l">28</TD><TD>import java.awt.Rectangle;</TD></TR><TR><TD CLASS="l">29</TD><TD>import java.awt.event.MouseEvent;</TD></TR><TR><TD CLASS="l">30</TD><TD>import java.awt.event.WindowAdapter;</TD></TR><TR><TD CLASS="l">31</TD><TD>import java.awt.event.WindowEvent;</TD></TR><TR><TD CLASS="l">32</TD><TD>import java.awt.geom.Point2D;</TD></TR><TR><TD CLASS="l">33</TD><TD>import java.awt.geom.Rectangle2D;</TD></TR><TR><TD CLASS="l">34</TD><TD>import java.io.File;</TD></TR><TR><TD CLASS="l">35</TD><TD>import java.net.URL;</TD></TR><TR><TD CLASS="l">36</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">37</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">38</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">39</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">40</TD><TD>import java.util.Hashtable;</TD></TR><TR><TD CLASS="l">41</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">42</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">43</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">44</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">45</TD><TD>import java.util.Vector;</TD></TR><TR><TD CLASS="l">46</TD><TD> </TD></TR><TR><TD CLASS="l">47</TD><TD>import javax.help.HelpSet;</TD></TR><TR><TD CLASS="l">48</TD><TD>import javax.help.JHelp;</TD></TR><TR><TD CLASS="l">49</TD><TD>import javax.swing.ImageIcon;</TD></TR><TR><TD CLASS="l">50</TD><TD>import javax.swing.JFrame;</TD></TR><TR><TD CLASS="l">51</TD><TD>import javax.swing.JOptionPane;</TD></TR><TR><TD CLASS="l">52</TD><TD> </TD></TR><TR><TD CLASS="l">53</TD><TD>import jmt.framework.gui.components.JMTFrame;</TD></TR><TR><TD CLASS="l">54</TD><TD>import jmt.framework.gui.components.JMTMenuBar;</TD></TR><TR><TD CLASS="l">55</TD><TD>import jmt.framework.gui.components.JMTToolBar;</TD></TR><TR><TD CLASS="l">56</TD><TD>import jmt.framework.gui.image.ImageLoader;</TD></TR><TR><TD CLASS="l">57</TD><TD>import jmt.framework.gui.listeners.MenuAction;</TD></TR><TR><TD CLASS="l">58</TD><TD>import jmt.gui.common.CommonConstants;</TD></TR><TR><TD CLASS="l">59</TD><TD>import jmt.gui.common.controller.DispatcherThread;</TD></TR><TR><TD CLASS="l">60</TD><TD>import jmt.gui.common.controller.ModelChecker;</TD></TR><TR><TD CLASS="l">61</TD><TD>import jmt.gui.common.controller.PADispatcherThread;</TD></TR><TR><TD CLASS="l">62</TD><TD>import jmt.gui.common.definitions.BlockingRegionDefinition;</TD></TR><TR><TD CLASS="l">63</TD><TD>import jmt.gui.common.definitions.GuiInterface;</TD></TR><TR><TD CLASS="l">64</TD><TD>import jmt.gui.common.definitions.ModelConverter;</TD></TR><TR><TD CLASS="l">65</TD><TD>import jmt.gui.common.definitions.PAResultsModel;</TD></TR><TR><TD CLASS="l">66</TD><TD>import jmt.gui.common.definitions.ResultsModel;</TD></TR><TR><TD CLASS="l">67</TD><TD>import jmt.gui.common.definitions.SimulationDefinition;</TD></TR><TR><TD CLASS="l">68</TD><TD>import jmt.gui.common.editors.DefaultsEditor;</TD></TR><TR><TD CLASS="l">69</TD><TD>import jmt.gui.common.panels.AboutDialogFactory;</TD></TR><TR><TD CLASS="l">70</TD><TD>import jmt.gui.common.panels.BlockingRegionParameterPanel;</TD></TR><TR><TD CLASS="l">71</TD><TD>import jmt.gui.common.panels.MeasurePanel;</TD></TR><TR><TD CLASS="l">72</TD><TD>import jmt.gui.common.panels.ResultsWindow;</TD></TR><TR><TD CLASS="l">73</TD><TD>import jmt.gui.common.panels.SimulationPanel;</TD></TR><TR><TD CLASS="l">74</TD><TD>import jmt.gui.common.panels.StationParameterPanel;</TD></TR><TR><TD CLASS="l">75</TD><TD>import jmt.gui.common.panels.WarningWindow;</TD></TR><TR><TD CLASS="l">76</TD><TD>import jmt.gui.common.panels.parametric.PAProgressWindow;</TD></TR><TR><TD CLASS="l">77</TD><TD>import jmt.gui.common.panels.parametric.PAResultsWindow;</TD></TR><TR><TD CLASS="l">78</TD><TD>import jmt.gui.common.panels.parametric.ParametricAnalysisPanel;</TD></TR><TR><TD CLASS="l">79</TD><TD>import jmt.gui.common.resources.JMTImageLoader;</TD></TR><TR><TD CLASS="l">80</TD><TD>import jmt.gui.common.xml.ModelLoader;</TD></TR><TR><TD CLASS="l">81</TD><TD>import jmt.gui.common.xml.XMLWriter;</TD></TR><TR><TD CLASS="l">82</TD><TD>import jmt.gui.exact.ExactModel;</TD></TR><TR><TD CLASS="l">83</TD><TD>import jmt.gui.exact.ExactWizard;</TD></TR><TR><TD CLASS="l">84</TD><TD>import jmt.gui.jmodel.DialogFactory;</TD></TR><TR><TD CLASS="l">85</TD><TD>import jmt.gui.jmodel.JGraphMod.BlockingRegion;</TD></TR><TR><TD CLASS="l">86</TD><TD>import jmt.gui.jmodel.JGraphMod.CellComponent;</TD></TR><TR><TD CLASS="l">87</TD><TD>import jmt.gui.jmodel.JGraphMod.CellFactory;</TD></TR><TR><TD CLASS="l">88</TD><TD>import jmt.gui.jmodel.JGraphMod.InputPort;</TD></TR><TR><TD CLASS="l">89</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtCell;</TD></TR><TR><TD CLASS="l">90</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtDefaultCellViewFactory;</TD></TR><TR><TD CLASS="l">91</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtEdge;</TD></TR><TR><TD CLASS="l">92</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtEdgeView;</TD></TR><TR><TD CLASS="l">93</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtGraphConstants;</TD></TR><TR><TD CLASS="l">94</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtJGraph;</TD></TR><TR><TD CLASS="l">95</TD><TD>import jmt.gui.jmodel.JGraphMod.JmtOverlapping;</TD></TR><TR><TD CLASS="l">96</TD><TD>import jmt.gui.jmodel.JGraphMod.OutputPort;</TD></TR><TR><TD CLASS="l">97</TD><TD>import jmt.gui.jmodel.JGraphMod.SinkCell;</TD></TR><TR><TD CLASS="l">98</TD><TD>import jmt.gui.jmodel.JGraphMod.SourceCell;</TD></TR><TR><TD CLASS="l">99</TD><TD>import jmt.gui.jmodel.controller.actions.About;</TD></TR><TR><TD CLASS="l">100</TD><TD>import jmt.gui.jmodel.controller.actions.AbstractJmodelAction;</TD></TR><TR><TD CLASS="l">101</TD><TD>import jmt.gui.jmodel.controller.actions.ActionCopy;</TD></TR><TR><TD CLASS="l">102</TD><TD>import jmt.gui.jmodel.controller.actions.ActionCut;</TD></TR><TR><TD CLASS="l">103</TD><TD>import jmt.gui.jmodel.controller.actions.ActionDelete;</TD></TR><TR><TD CLASS="l">104</TD><TD>import jmt.gui.jmodel.controller.actions.ActionPaste;</TD></TR><TR><TD CLASS="l">105</TD><TD>import jmt.gui.jmodel.controller.actions.ActionRedo;</TD></TR><TR><TD CLASS="l">106</TD><TD>import jmt.gui.jmodel.controller.actions.ActionRotate;</TD></TR><TR><TD CLASS="l">107</TD><TD>import jmt.gui.jmodel.controller.actions.ActionSetRight;</TD></TR><TR><TD CLASS="l">108</TD><TD>import jmt.gui.jmodel.controller.actions.ActionUndo;</TD></TR><TR><TD CLASS="l">109</TD><TD>import jmt.gui.jmodel.controller.actions.AddBlockingRegion;</TD></TR><TR><TD CLASS="l">110</TD><TD>import jmt.gui.jmodel.controller.actions.CloseModel;</TD></TR><TR><TD CLASS="l">111</TD><TD>import jmt.gui.jmodel.controller.actions.EditDefaults;</TD></TR><TR><TD CLASS="l">112</TD><TD>import jmt.gui.jmodel.controller.actions.EditMeasures;</TD></TR><TR><TD CLASS="l">113</TD><TD>import jmt.gui.jmodel.controller.actions.EditPAParams;</TD></TR><TR><TD CLASS="l">114</TD><TD>import jmt.gui.jmodel.controller.actions.EditSimParams;</TD></TR><TR><TD CLASS="l">115</TD><TD>import jmt.gui.jmodel.controller.actions.EditUserClasses;</TD></TR><TR><TD CLASS="l">116</TD><TD>import jmt.gui.jmodel.controller.actions.Exit;</TD></TR><TR><TD CLASS="l">117</TD><TD>import jmt.gui.jmodel.controller.actions.NewModel;</TD></TR><TR><TD CLASS="l">118</TD><TD>import jmt.gui.jmodel.controller.actions.OpenHelp;</TD></TR><TR><TD CLASS="l">119</TD><TD>import jmt.gui.jmodel.controller.actions.OpenModel;</TD></TR><TR><TD CLASS="l">120</TD><TD>import jmt.gui.jmodel.controller.actions.PauseSimulation;</TD></TR><TR><TD CLASS="l">121</TD><TD>import jmt.gui.jmodel.controller.actions.SaveModel;</TD></TR><TR><TD CLASS="l">122</TD><TD>import jmt.gui.jmodel.controller.actions.SaveModelAs;</TD></TR><TR><TD CLASS="l">123</TD><TD>import jmt.gui.jmodel.controller.actions.SetConnectState;</TD></TR><TR><TD CLASS="l">124</TD><TD>import jmt.gui.jmodel.controller.actions.SetOptions;</TD></TR><TR><TD CLASS="l">125</TD><TD>import jmt.gui.jmodel.controller.actions.SetSelectState;</TD></TR><TR><TD CLASS="l">126</TD><TD>import jmt.gui.jmodel.controller.actions.ShowResults;</TD></TR><TR><TD CLASS="l">127</TD><TD>import jmt.gui.jmodel.controller.actions.Simulate;</TD></TR><TR><TD CLASS="l">128</TD><TD>import jmt.gui.jmodel.controller.actions.SolveAnalytic;</TD></TR><TR><TD CLASS="l">129</TD><TD>import jmt.gui.jmodel.controller.actions.SolveApprox;</TD></TR><TR><TD CLASS="l">130</TD><TD>import jmt.gui.jmodel.controller.actions.StopSimulation;</TD></TR><TR><TD CLASS="l">131</TD><TD>import jmt.gui.jmodel.controller.actions.SwitchToExactSolver;</TD></TR><TR><TD CLASS="l">132</TD><TD>import jmt.gui.jmodel.controller.actions.TakeScreenShot;</TD></TR><TR><TD CLASS="l">133</TD><TD>import jmt.gui.jmodel.definitions.JMODELModel;</TD></TR><TR><TD CLASS="l">134</TD><TD>import jmt.gui.jmodel.definitions.JMTPoint;</TD></TR><TR><TD CLASS="l">135</TD><TD>import jmt.gui.jmodel.definitions.JmodelClassDefinition;</TD></TR><TR><TD CLASS="l">136</TD><TD>import jmt.gui.jmodel.definitions.JmodelStationDefinition;</TD></TR><TR><TD CLASS="l">137</TD><TD>import jmt.gui.jmodel.mainGui.ComponentBar;</TD></TR><TR><TD CLASS="l">138</TD><TD>import jmt.gui.jmodel.mainGui.MainWindow;</TD></TR><TR><TD CLASS="l">139</TD><TD>import jmt.gui.jmodel.panels.JModelProblemsWindow;</TD></TR><TR><TD CLASS="l">140</TD><TD>import jmt.gui.jmodel.panels.StationNamePanel;</TD></TR><TR><TD CLASS="l">141</TD><TD>import jmt.gui.jmodel.panels.jmodelClassesPanel;</TD></TR><TR><TD CLASS="l">142</TD><TD> </TD></TR><TR><TD CLASS="l">143</TD><TD>import org.jgraph.JGraph;</TD></TR><TR><TD CLASS="l">144</TD><TD>import org.jgraph.graph.CellHandle;</TD></TR><TR><TD CLASS="l">145</TD><TD>import org.jgraph.graph.CellView;</TD></TR><TR><TD CLASS="l">146</TD><TD>import org.jgraph.graph.ConnectionSet;</TD></TR><TR><TD CLASS="l">147</TD><TD>import org.jgraph.graph.DefaultGraphModel;</TD></TR><TR><TD CLASS="l">148</TD><TD>import org.jgraph.graph.DefaultPort;</TD></TR><TR><TD CLASS="l">149</TD><TD>import org.jgraph.graph.Edge;</TD></TR><TR><TD CLASS="l">150</TD><TD>import org.jgraph.graph.EdgeView;</TD></TR><TR><TD CLASS="l">151</TD><TD>import org.jgraph.graph.GraphConstants;</TD></TR><TR><TD CLASS="l">152</TD><TD>import org.jgraph.graph.GraphModel;</TD></TR><TR><TD CLASS="l">153</TD><TD>import org.jgraph.graph.GraphUndoManager;</TD></TR><TR><TD CLASS="l">154</TD><TD>import org.jgraph.graph.PortView;</TD></TR><TR><TD CLASS="l">155</TD><TD>import org.jgraph.plaf.basic.BasicGraphUI;</TD></TR><TR><TD CLASS="l">156</TD><TD> </TD></TR><TR><TD CLASS="l">157</TD><TD>/**</TD></TR><TR><TD CLASS="l">158</TD><TD> * This class mantains a reference to all the main copmponents of the Gui,</TD></TR><TR><TD CLASS="l">159</TD><TD> * in this way it's possible to divide the responsability of the actions &amp;</TD></TR><TR><TD CLASS="l">160</TD><TD> * every object know only about of himself &amp; the mediator.</TD></TR><TR><TD CLASS="l">161</TD><TD> * Other actions are made through the mediator without knowing who will actually</TD></TR><TR><TD CLASS="l">162</TD><TD> * do it.</TD></TR><TR><TD CLASS="l">163</TD><TD> *</TD></TR><TR><TD CLASS="l">164</TD><TD> </TD></TR><TR><TD CLASS="l">165</TD><TD> * @author Federico Granata</TD></TR><TR><TD CLASS="l">166</TD><TD> * Date: 3-giu-2003</TD></TR><TR><TD CLASS="l">167</TD><TD> * Time: 16.54.45</TD></TR><TR><TD CLASS="l">168</TD><TD> </TD></TR><TR><TD CLASS="l">169</TD><TD> * Heavily modified by Bertoli Marco 2-giu-2005</TD></TR><TR><TD CLASS="l">170</TD><TD> </TD></TR><TR><TD CLASS="l">171</TD><TD> * Modified by Francesco D'Aquino</TD></TR><TR><TD CLASS="l">172</TD><TD> </TD></TR><TR><TD CLASS="l">173</TD><TD> * Modyfied by Bertoli Marco to support JGraph 5.8 - 21/mar/2006</TD></TR><TR><TD CLASS="l">174</TD><TD> </TD></TR><TR><TD CLASS="l">175</TD><TD> * Modified by Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">176</TD><TD> * </TD></TR><TR><TD CLASS="l">177</TD><TD> * @author Ashanka Date: 11March 2010</TD></TR><TR><TD CLASS="l">178</TD><TD> * Description: Added a logic to remove the duplicate name of the files from displaying.</TD></TR><TR><TD CLASS="l">179</TD><TD> * </TD></TR><TR><TD CLASS="l">180</TD><TD> * Modified by Ashanka (May 2010): </TD></TR><TR><TD CLASS="l">181</TD><TD> * Patch: Multi-Sink Perf. Index </TD></TR><TR><TD CLASS="l">182</TD><TD> * Description: Added new Performance index for the capturing the </TD></TR><TR><TD CLASS="l">183</TD><TD> *                                 1. global response time (ResponseTime per Sink)</TD></TR><TR><TD CLASS="l"><A NAME="0">184</A></TD><TD> *              2. global throughput (Throughput per Sink)</TD></TR><TR><TD CLASS="l">185</TD><TD> *              each sink per class.</TD></TR><TR><TD CLASS="l">186</TD><TD> * Model validation of the perf indices.</TD></TR><TR><TD CLASS="l">187</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>public class Mediator implements GuiInterface {</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>        private boolean isReleased = false;</TD></TR><TR><TD CLASS="l">190</TD><TD>        // making it final allows the compiler to skip code generation when false</TD></TR><TR><TD CLASS="l">191</TD><TD>        private GraphMouseListner mouseListner;</TD></TR><TR><TD CLASS="l">192</TD><TD>        // Dialog factory</TD></TR><TR><TD CLASS="l">193</TD><TD>        private DialogFactory dialogFactory;</TD></TR><TR><TD CLASS="l">194</TD><TD>        // Cell factory</TD></TR><TR><TD CLASS="l">195</TD><TD>        private CellFactory cellFactory;</TD></TR><TR><TD CLASS="l">196</TD><TD> </TD></TR><TR><TD CLASS="l">197</TD><TD>        private AbstractJmodelAction closeModel, newModel, openHelp, openModel, saveModel, setConnect, actionCopy, actionCut, setOptions, actionPaste,</TD></TR><TR><TD CLASS="l">198</TD><TD>                        setSelect, actionDelete, simulate, solveAnalitic, solveApp, editUserClasses, editMeasures, switchToExactSolver, exit,</TD></TR><TR><TD CLASS="l">199</TD><TD>                        // Bertoli Marco</TD></TR><TR><TD CLASS="l">200</TD><TD>                        editDefaults, saveModelAs, pauseSimulation, stopSimulation, editSimParams, showResults, about, addBlockingRegion, takeScreenShot,</TD></TR><TR><TD CLASS="l">201</TD><TD>                        // end</TD></TR><TR><TD CLASS="l">202</TD><TD> </TD></TR><TR><TD CLASS="l">203</TD><TD>                        // Giuseppe De CIcco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">204</TD><TD>                        actionRotate, actionSetRight,</TD></TR><TR><TD CLASS="l">205</TD><TD> </TD></TR><TR><TD CLASS="l">206</TD><TD>                        // Conti Andrea</TD></TR><TR><TD CLASS="l">207</TD><TD>                        editUndo, editRedo;</TD></TR><TR><TD CLASS="l">208</TD><TD>        // end</TD></TR><TR><TD CLASS="l">209</TD><TD> </TD></TR><TR><TD CLASS="l">210</TD><TD>        private JmtJGraph graph;</TD></TR><TR><TD CLASS="l">211</TD><TD>        private MainWindow mainWindow;</TD></TR><TR><TD CLASS="l">212</TD><TD> </TD></TR><TR><TD CLASS="l">213</TD><TD>        protected Object[] cells;</TD></TR><TR><TD CLASS="l">214</TD><TD>        protected Map cellsAttr;</TD></TR><TR><TD CLASS="l">215</TD><TD> </TD></TR><TR><TD CLASS="l">216</TD><TD>        public static boolean advanced;</TD></TR><TR><TD CLASS="l">217</TD><TD>        private Cursor cursor;</TD></TR><TR><TD CLASS="l">218</TD><TD>        private Cursor oldCursor;</TD></TR><TR><TD CLASS="l">219</TD><TD> </TD></TR><TR><TD CLASS="l">220</TD><TD>        // Bertoli Marco</TD></TR><TR><TD CLASS="l">221</TD><TD>        private JMODELModel model;</TD></TR><TR><TD CLASS="l">222</TD><TD>        private JFrame resultsWindow;</TD></TR><TR><TD CLASS="l">223</TD><TD>        private JmtClipboard clipboard;</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>        private DispatcherThread dispatcher = null; // To control simulation</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>        private ModelLoader modelLoader = new ModelLoader(ModelLoader.JMODEL); // To</TD></TR><TR><TD CLASS="l">226</TD><TD>        // Save</TD></TR><TR><TD CLASS="l">227</TD><TD>        // /</TD></TR><TR><TD CLASS="l">228</TD><TD>        // Load</TD></TR><TR><TD CLASS="l">229</TD><TD>        private JMTToolBar componentBar;</TD></TR><TR><TD CLASS="l">230</TD><TD>        // end</TD></TR><TR><TD CLASS="l">231</TD><TD> </TD></TR><TR><TD CLASS="l">232</TD><TD>        // Francesco D'Aquino</TD></TR><TR><TD CLASS="l">233</TD><TD>        private ModelChecker mc;</TD></TR><TR><TD CLASS="l">234</TD><TD>        private JModelProblemsWindow pw;</TD></TR><TR><TD CLASS="l">235</TD><TD>        private PADispatcherThread batchThread;</TD></TR><TR><TD CLASS="l">236</TD><TD>        private PAProgressWindow progressWindow;</TD></TR><TR><TD CLASS="l">237</TD><TD>        private AbstractJmodelAction editPAParams;</TD></TR><TR><TD CLASS="l">238</TD><TD>        // end</TD></TR><TR><TD CLASS="l">239</TD><TD> </TD></TR><TR><TD CLASS="l">240</TD><TD>        // Giuseppe De Cicco</TD></TR><TR><TD CLASS="l"><A NAME="2">241</A></TD><TD>        private JmtOverlapping overlapping;</TD></TR><TR><TD CLASS="l">242</TD><TD> </TD></TR><TR><TD CLASS="l">243</TD><TD>        // end</TD></TR><TR><TD CLASS="l">244</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>        public Mediator(final JmtJGraph graph, MainWindow mainWindow) {</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                this.mainWindow = mainWindow;</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>                dialogFactory = new DialogFactory(mainWindow);</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                cellFactory = new CellFactory(this);</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                this.graph = graph;</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                closeModel = new CloseModel(this);</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                newModel = new NewModel(this);</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>                openHelp = new OpenHelp(this);</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>                openModel = new OpenModel(this);</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                saveModel = new SaveModel(this);</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                setConnect = new SetConnectState(this);</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                actionCopy = new ActionCopy(this);</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                actionCut = new ActionCut(this);</TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                setOptions = new SetOptions(this);</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                actionPaste = new ActionPaste(this);</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                setSelect = new SetSelectState(this);</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>                actionDelete = new ActionDelete(this);</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                simulate = new Simulate(this);</TD></TR><TR><TD CLASS="l">263</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>                solveAnalitic = new SolveAnalytic(this);</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>                solveApp = new SolveApprox(this);</TD></TR><TR><TD CLASS="l">266</TD><TD>                // Conti Andrea - undo</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                undoManager = new GraphUndoManager();</TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                undoProxy = new UndoManagerProxy(undoManager);</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                editUndo = new ActionUndo(this, undoManager);</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                editRedo = new ActionRedo(this, undoManager);</TD></TR><TR><TD CLASS="l">271</TD><TD>                // end</TD></TR><TR><TD CLASS="l">272</TD><TD>                // Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                pauseSimulation = new PauseSimulation(this);</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                stopSimulation = new StopSimulation(this);</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                exit = new Exit(this);</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                clipboard = new JmtClipboard(this);</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                editDefaults = new EditDefaults(this);</TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                saveModelAs = new SaveModelAs(this);</TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                editSimParams = new EditSimParams(this);</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                editPAParams = new EditPAParams(this);</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                showResults = new ShowResults(this);</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>                about = new About(this);</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>                addBlockingRegion = new AddBlockingRegion(this);</TD></TR><TR><TD CLASS="l">284</TD><TD>                // fg</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                actionSetRight = new ActionSetRight(this);</TD></TR><TR><TD CLASS="l">286</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                takeScreenShot = new TakeScreenShot(this);</TD></TR><TR><TD CLASS="l">288</TD><TD>                // end</TD></TR><TR><TD CLASS="l">289</TD><TD> </TD></TR><TR><TD CLASS="l">290</TD><TD>                // GDC &amp; FG</TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>                actionRotate = new ActionRotate(this);</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                overlapping = new JmtOverlapping(this);</TD></TR><TR><TD CLASS="l">293</TD><TD>                // end</TD></TR><TR><TD CLASS="l">294</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                editUserClasses = new EditUserClasses(this);</TD></TR><TR CLASS="z"><TD CLASS="l">296</TD><TD>                editMeasures = new EditMeasures(this);</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                switchToExactSolver = new SwitchToExactSolver(this);</TD></TR><TR><TD CLASS="l">298</TD><TD>                // Initialize new Component bar</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                componentBar = new ComponentBar(this);</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>        }</TD></TR><TR><TD CLASS="l">301</TD><TD> </TD></TR><TR><TD CLASS="l">302</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="13">303</A></TD><TD>         * Creates a toolbar to be displayed in main window.</TD></TR><TR><TD CLASS="l">304</TD><TD>         * @return created toolbar.</TD></TR><TR><TD CLASS="l">305</TD><TD>         */</TD></TR><TR><TD CLASS="l">306</TD><TD>        public JMTToolBar createToolbar() {</TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>                JMTToolBar toolbar = new JMTToolBar(JMTImageLoader.getImageLoader());</TD></TR><TR><TD CLASS="l">308</TD><TD>                // Builds an array with all actions to be put in the toolbar</TD></TR><TR CLASS="z"><TD CLASS="l">309</TD><TD>                AbstractJmodelAction[] actions = new AbstractJmodelAction[] { newModel, openModel, saveModel, null,</TD></TR><TR><TD CLASS="l">310</TD><TD>                                // editUndo, editRedo, null,</TD></TR><TR><TD CLASS="l">311</TD><TD>                                actionCut, actionCopy, actionPaste, null, editUserClasses, editMeasures, editSimParams, editPAParams, null, switchToExactSolver,</TD></TR><TR><TD CLASS="l">312</TD><TD>                                null, simulate, pauseSimulation, stopSimulation, showResults, null, editDefaults, openHelp };</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                toolbar.populateToolbar(actions);</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                return toolbar;</TD></TR><TR><TD CLASS="l">315</TD><TD>        }</TD></TR><TR><TD CLASS="l">316</TD><TD> </TD></TR><TR><TD CLASS="l">317</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="12">318</A></TD><TD>         * Creates a menu to be displayed in main window.</TD></TR><TR><TD CLASS="l">319</TD><TD>         * @return created menu.</TD></TR><TR><TD CLASS="l">320</TD><TD>         */</TD></TR><TR><TD CLASS="l">321</TD><TD>        public JMTMenuBar createMenu() {</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>                JMTMenuBar menu = new JMTMenuBar(JMTImageLoader.getImageLoader());</TD></TR><TR><TD CLASS="l">323</TD><TD>                // File menu</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                MenuAction action = new MenuAction(&#34;File&#34;, new AbstractJmodelAction[] { newModel, openModel, saveModel, saveModelAs, closeModel, null, exit });</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>                menu.addMenu(action);</TD></TR><TR><TD CLASS="l">326</TD><TD> </TD></TR><TR><TD CLASS="l">327</TD><TD>                // Edit menu</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                action = new MenuAction(&#34;Edit&#34;, new AbstractJmodelAction[] {</TD></TR><TR><TD CLASS="l">329</TD><TD>                // editUndo, editRedo, null</TD></TR><TR><TD CLASS="l">330</TD><TD>                                actionCut, actionCopy, actionPaste, actionDelete, null, takeScreenShot });</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                menu.addMenu(action);</TD></TR><TR><TD CLASS="l">332</TD><TD> </TD></TR><TR><TD CLASS="l">333</TD><TD>                // Define menu</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>                action = new MenuAction(&#34;Define&#34;,</TD></TR><TR><TD CLASS="l">335</TD><TD>                                new AbstractJmodelAction[] { editUserClasses, editMeasures, editSimParams, editPAParams, null, editDefaults });</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                menu.addMenu(action);</TD></TR><TR><TD CLASS="l">337</TD><TD> </TD></TR><TR><TD CLASS="l">338</TD><TD>                // Solve menu</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>                action = new MenuAction(&#34;Solve&#34;, new AbstractJmodelAction[] { simulate, pauseSimulation, stopSimulation, null, switchToExactSolver, null,</TD></TR><TR><TD CLASS="l">340</TD><TD>                                showResults });</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>                menu.addMenu(action);</TD></TR><TR><TD CLASS="l">342</TD><TD> </TD></TR><TR><TD CLASS="l">343</TD><TD>                // Help menu</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                action = new MenuAction(&#34;Help&#34;, new AbstractJmodelAction[] { openHelp, null, about });</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                menu.addMenu(action);</TD></TR><TR><TD CLASS="l">346</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="31">347</A></TD><TD>                return menu;</TD></TR><TR><TD CLASS="l">348</TD><TD>        }</TD></TR><TR><TD CLASS="l">349</TD><TD> </TD></TR><TR><TD CLASS="l">350</TD><TD>        public JMTToolBar getComponentBar() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8b">351</A></TD><TD>                return componentBar;</TD></TR><TR><TD CLASS="l">352</TD><TD>        }</TD></TR><TR><TD CLASS="l">353</TD><TD> </TD></TR><TR><TD CLASS="l">354</TD><TD>        public void setMouseListner(GraphMouseListner mouseListner) {</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>                this.mouseListner = mouseListner;</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>        }</TD></TR><TR><TD CLASS="l">357</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3a">358</A></TD><TD>        private File openedArchive;</TD></TR><TR><TD CLASS="l">359</TD><TD> </TD></TR><TR><TD CLASS="l">360</TD><TD>        // Bertoli Marco</TD></TR><TR><TD CLASS="l">361</TD><TD>        public AbstractJmodelAction getEditUserClasses() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3b">362</A></TD><TD>                return editUserClasses;</TD></TR><TR><TD CLASS="l">363</TD><TD>        }</TD></TR><TR><TD CLASS="l">364</TD><TD> </TD></TR><TR><TD CLASS="l">365</TD><TD>        public AbstractJmodelAction getExit() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5b">366</A></TD><TD>                return exit;</TD></TR><TR><TD CLASS="l">367</TD><TD>        }</TD></TR><TR><TD CLASS="l">368</TD><TD> </TD></TR><TR><TD CLASS="l">369</TD><TD>        public JmodelStationDefinition getStationDefinition() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2f">370</A></TD><TD>                return model;</TD></TR><TR><TD CLASS="l">371</TD><TD>        }</TD></TR><TR><TD CLASS="l">372</TD><TD> </TD></TR><TR><TD CLASS="l">373</TD><TD>        public JmodelClassDefinition getClassDefinition() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="58">374</A></TD><TD>                return model;</TD></TR><TR><TD CLASS="l">375</TD><TD>        }</TD></TR><TR><TD CLASS="l">376</TD><TD> </TD></TR><TR><TD CLASS="l">377</TD><TD>        public SimulationDefinition getSimulationDefinition() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2b">378</A></TD><TD>                return model;</TD></TR><TR><TD CLASS="l">379</TD><TD>        }</TD></TR><TR><TD CLASS="l">380</TD><TD> </TD></TR><TR><TD CLASS="l">381</TD><TD>        public BlockingRegionDefinition getBlockingRegionDefinition() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1b">382</A></TD><TD>                return model;</TD></TR><TR><TD CLASS="l">383</TD><TD>        }</TD></TR><TR><TD CLASS="l">384</TD><TD> </TD></TR><TR><TD CLASS="l">385</TD><TD>        public void enableAddBlockingRegion(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                addBlockingRegion.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="23">387</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">388</TD><TD> </TD></TR><TR><TD CLASS="l">389</TD><TD>        // Giuseppe De CIcco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">390</TD><TD>        public void enableSetRight(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                actionSetRight.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="54">392</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">393</TD><TD> </TD></TR><TR><TD CLASS="l">394</TD><TD>        // Giuseppe De CIcco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">395</TD><TD>        public AbstractJmodelAction getSetRight() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="36">396</A></TD><TD>                return actionSetRight;</TD></TR><TR><TD CLASS="l">397</TD><TD>        }</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR><TD CLASS="l">399</TD><TD>        public AbstractJmodelAction getEditDefaults() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2a">400</A></TD><TD>                return editDefaults;</TD></TR><TR><TD CLASS="l">401</TD><TD>        }</TD></TR><TR><TD CLASS="l">402</TD><TD> </TD></TR><TR><TD CLASS="l">403</TD><TD>        public AbstractJmodelAction getAddBlockingRegion() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="51">404</A></TD><TD>                return addBlockingRegion;</TD></TR><TR><TD CLASS="l">405</TD><TD>        }</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR><TD CLASS="l">407</TD><TD>        public AbstractJmodelAction getSaveModelAs() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4c">408</A></TD><TD>                return saveModelAs;</TD></TR><TR><TD CLASS="l">409</TD><TD>        }</TD></TR><TR><TD CLASS="l">410</TD><TD> </TD></TR><TR><TD CLASS="l">411</TD><TD>        public AbstractJmodelAction getPauseSimulation() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5c">412</A></TD><TD>                return pauseSimulation;</TD></TR><TR><TD CLASS="l">413</TD><TD>        }</TD></TR><TR><TD CLASS="l">414</TD><TD> </TD></TR><TR><TD CLASS="l">415</TD><TD>        public AbstractJmodelAction getStopSimulation() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="39">416</A></TD><TD>                return stopSimulation;</TD></TR><TR><TD CLASS="l">417</TD><TD>        }</TD></TR><TR><TD CLASS="l">418</TD><TD> </TD></TR><TR><TD CLASS="l">419</TD><TD>        public AbstractJmodelAction getEditSimParams() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="38">420</A></TD><TD>                return editSimParams;</TD></TR><TR><TD CLASS="l">421</TD><TD>        }</TD></TR><TR><TD CLASS="l">422</TD><TD> </TD></TR><TR><TD CLASS="l">423</TD><TD>        public AbstractJmodelAction getEditPAParams() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="56">424</A></TD><TD>                return editPAParams;</TD></TR><TR><TD CLASS="l">425</TD><TD>        }</TD></TR><TR><TD CLASS="l">426</TD><TD> </TD></TR><TR><TD CLASS="l">427</TD><TD>        public AbstractJmodelAction getShowResults() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="29">428</A></TD><TD>                return showResults;</TD></TR><TR><TD CLASS="l">429</TD><TD>        }</TD></TR><TR><TD CLASS="l">430</TD><TD> </TD></TR><TR><TD CLASS="l">431</TD><TD>        public AbstractJmodelAction getAbout() {</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                return about;</TD></TR><TR><TD CLASS="l">433</TD><TD>        }</TD></TR><TR><TD CLASS="l">434</TD><TD> </TD></TR><TR><TD CLASS="l">435</TD><TD>        // end</TD></TR><TR><TD CLASS="l">436</TD><TD> </TD></TR><TR><TD CLASS="l">437</TD><TD>        // Conti Andrea - undo</TD></TR><TR><TD CLASS="l"><A NAME="9f">438</A></TD><TD>        private GraphUndoManager undoManager;</TD></TR><TR><TD CLASS="l">439</TD><TD>        private UndoManagerProxy undoProxy;</TD></TR><TR><TD CLASS="l">440</TD><TD> </TD></TR><TR><TD CLASS="l">441</TD><TD>        public void undo() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="7a">442</A></TD><TD>                undoManager.undo();</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>        }</TD></TR><TR><TD CLASS="l">444</TD><TD> </TD></TR><TR><TD CLASS="l">445</TD><TD>        public void redo() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="24">446</A></TD><TD>                undoManager.redo();</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>        }</TD></TR><TR><TD CLASS="l">448</TD><TD> </TD></TR><TR><TD CLASS="l">449</TD><TD>        public void enableUndoAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="21">450</A></TD><TD>                editUndo.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>        }</TD></TR><TR><TD CLASS="l">452</TD><TD> </TD></TR><TR><TD CLASS="l">453</TD><TD>        public void enableRedoAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="60">454</A></TD><TD>                editRedo.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>        }</TD></TR><TR><TD CLASS="l">456</TD><TD> </TD></TR><TR><TD CLASS="l">457</TD><TD>        public AbstractJmodelAction getUndoAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4d">458</A></TD><TD>                return editUndo;</TD></TR><TR><TD CLASS="l">459</TD><TD>        }</TD></TR><TR><TD CLASS="l">460</TD><TD> </TD></TR><TR><TD CLASS="l">461</TD><TD>        public AbstractJmodelAction getRedoAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="61">462</A></TD><TD>                return editRedo;</TD></TR><TR><TD CLASS="l">463</TD><TD>        }</TD></TR><TR><TD CLASS="l">464</TD><TD> </TD></TR><TR><TD CLASS="l">465</TD><TD>        public GraphUndoManager getUndoManager() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8f">466</A></TD><TD>                return undoManager;</TD></TR><TR><TD CLASS="l">467</TD><TD>        }</TD></TR><TR><TD CLASS="l">468</TD><TD> </TD></TR><TR><TD CLASS="l">469</TD><TD>        public void setUndoManager(GraphUndoManager um) {</TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>                undoManager = um;</TD></TR><TR CLASS="z"><TD CLASS="l">471</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="83">472</A></TD><TD> </TD></TR><TR><TD CLASS="l">473</TD><TD>        // end</TD></TR><TR><TD CLASS="l">474</TD><TD> </TD></TR><TR><TD CLASS="l">475</TD><TD>        public void setConnectState() {</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR><TD CLASS="l">477</TD><TD>                // DEK (Federico Granata) 14-11-2003</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>                oldCursor = cursor;</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>                cursor = new Cursor(Cursor.CROSSHAIR_CURSOR);</TD></TR><TR CLASS="z"><TD CLASS="l">480</TD><TD>                setGraphCursor(cursor);</TD></TR><TR><TD CLASS="l">481</TD><TD> </TD></TR><TR><TD CLASS="l">482</TD><TD>                // end 14-11-2003</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="84">483</A></TD><TD>                mouseListner.setConnectState();</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>        }</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR><TD CLASS="l">486</TD><TD>        public void setCopyState() {</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR><TD CLASS="l"><A NAME="86">488</A></TD><TD>                // mouseListner.setCopyState();</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>        }</TD></TR><TR><TD CLASS="l">490</TD><TD> </TD></TR><TR><TD CLASS="l">491</TD><TD>        public void setCutState() {</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR><TD CLASS="l"><A NAME="89">493</A></TD><TD>                // mouseListner.setCutState();</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>        }</TD></TR><TR><TD CLASS="l">495</TD><TD> </TD></TR><TR><TD CLASS="l">496</TD><TD>        public void setInsertState(String className) {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8e">498</A></TD><TD>                mouseListner.setInsertState(className);</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>        }</TD></TR><TR><TD CLASS="l">500</TD><TD> </TD></TR><TR><TD CLASS="l">501</TD><TD>        public void setSelectState() {</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                mouseListner.setSelectState();</TD></TR><TR><TD CLASS="l">504</TD><TD>                // DEK (Federico Granata)</TD></TR><TR><TD CLASS="l"><A NAME="34">505</A></TD><TD>                // mainWindow.getAlbero().setSelectedButton(true);</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>        }</TD></TR><TR><TD CLASS="l">507</TD><TD> </TD></TR><TR><TD CLASS="l">508</TD><TD>        public AbstractJmodelAction getDeleteAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5">509</A></TD><TD>                return actionDelete;</TD></TR><TR><TD CLASS="l">510</TD><TD>        }</TD></TR><TR><TD CLASS="l">511</TD><TD> </TD></TR><TR><TD CLASS="l">512</TD><TD>        public void activateSelect() {</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>                setSelect.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1d">514</A></TD><TD>                componentBar.clickButton(setSelect);</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>        }</TD></TR><TR><TD CLASS="l">516</TD><TD> </TD></TR><TR><TD CLASS="l">517</TD><TD>        public void enableCutAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="20">518</A></TD><TD>                actionCut.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>        }</TD></TR><TR><TD CLASS="l">520</TD><TD> </TD></TR><TR><TD CLASS="l">521</TD><TD>        public void enablePasteAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1c">522</A></TD><TD>                actionPaste.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>        }</TD></TR><TR><TD CLASS="l">524</TD><TD> </TD></TR><TR><TD CLASS="l">525</TD><TD>        public void enableCopyAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>                actionCopy.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="22">527</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">528</TD><TD> </TD></TR><TR><TD CLASS="l">529</TD><TD>        // Giuseppe De CIcco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">530</TD><TD>        public void enableRotateAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">531</A></TD><TD>                actionRotate.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>        }</TD></TR><TR><TD CLASS="l">533</TD><TD> </TD></TR><TR><TD CLASS="l">534</TD><TD>        public void enableDeleteAction(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5e">535</A></TD><TD>                actionDelete.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">536</TD><TD>        }</TD></TR><TR><TD CLASS="l">537</TD><TD> </TD></TR><TR><TD CLASS="l">538</TD><TD>        public AbstractJmodelAction getTakeScreenShot() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="88">539</A></TD><TD>                return takeScreenShot;</TD></TR><TR><TD CLASS="l">540</TD><TD>        }</TD></TR><TR><TD CLASS="l">541</TD><TD> </TD></TR><TR><TD CLASS="l">542</TD><TD>        public void setHandle(CellHandle handle) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="30">543</A></TD><TD>                this.mouseListner.setHandle(handle);</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>        }</TD></TR><TR><TD CLASS="l">545</TD><TD> </TD></TR><TR><TD CLASS="l">546</TD><TD>        public AbstractJmodelAction getCloseModel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="43">547</A></TD><TD>                return closeModel;</TD></TR><TR><TD CLASS="l">548</TD><TD>        }</TD></TR><TR><TD CLASS="l">549</TD><TD> </TD></TR><TR><TD CLASS="l">550</TD><TD>        public AbstractJmodelAction getNewModel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="46">551</A></TD><TD>                return newModel;</TD></TR><TR><TD CLASS="l">552</TD><TD>        }</TD></TR><TR><TD CLASS="l">553</TD><TD> </TD></TR><TR><TD CLASS="l">554</TD><TD>        public AbstractJmodelAction getOpenHelp() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="47">555</A></TD><TD>                return openHelp;</TD></TR><TR><TD CLASS="l">556</TD><TD>        }</TD></TR><TR><TD CLASS="l">557</TD><TD> </TD></TR><TR><TD CLASS="l">558</TD><TD>        public AbstractJmodelAction getOpenModel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="50">559</A></TD><TD>                return openModel;</TD></TR><TR><TD CLASS="l">560</TD><TD>        }</TD></TR><TR><TD CLASS="l">561</TD><TD> </TD></TR><TR><TD CLASS="l">562</TD><TD>        public AbstractJmodelAction getSaveModel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="52">563</A></TD><TD>                return saveModel;</TD></TR><TR><TD CLASS="l">564</TD><TD>        }</TD></TR><TR><TD CLASS="l">565</TD><TD> </TD></TR><TR><TD CLASS="l">566</TD><TD>        public AbstractJmodelAction getSetConnect() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="32">567</A></TD><TD>                return setConnect;</TD></TR><TR><TD CLASS="l">568</TD><TD>        }</TD></TR><TR><TD CLASS="l">569</TD><TD> </TD></TR><TR><TD CLASS="l">570</TD><TD>        public AbstractJmodelAction getCopyAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="33">571</A></TD><TD>                return actionCopy;</TD></TR><TR><TD CLASS="l">572</TD><TD>        }</TD></TR><TR><TD CLASS="l">573</TD><TD> </TD></TR><TR><TD CLASS="l">574</TD><TD>        public AbstractJmodelAction getCutAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="53">575</A></TD><TD>                return actionCut;</TD></TR><TR><TD CLASS="l">576</TD><TD>        }</TD></TR><TR><TD CLASS="l">577</TD><TD> </TD></TR><TR><TD CLASS="l">578</TD><TD>        public AbstractJmodelAction getSetOptions() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4b">579</A></TD><TD>                return setOptions;</TD></TR><TR><TD CLASS="l">580</TD><TD>        }</TD></TR><TR><TD CLASS="l">581</TD><TD> </TD></TR><TR><TD CLASS="l">582</TD><TD>        public AbstractJmodelAction getPasteAction() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="55">583</A></TD><TD>                return actionPaste;</TD></TR><TR><TD CLASS="l">584</TD><TD>        }</TD></TR><TR><TD CLASS="l">585</TD><TD> </TD></TR><TR><TD CLASS="l">586</TD><TD>        public AbstractJmodelAction getSetSelect() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="57">587</A></TD><TD>                return setSelect;</TD></TR><TR><TD CLASS="l">588</TD><TD>        }</TD></TR><TR><TD CLASS="l">589</TD><TD> </TD></TR><TR><TD CLASS="l">590</TD><TD>        public AbstractJmodelAction getSimulate() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="59">591</A></TD><TD>                return simulate;</TD></TR><TR><TD CLASS="l">592</TD><TD>        }</TD></TR><TR><TD CLASS="l">593</TD><TD> </TD></TR><TR><TD CLASS="l">594</TD><TD>        public AbstractJmodelAction getSolveAnalitic() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5a">595</A></TD><TD>                return solveAnalitic;</TD></TR><TR><TD CLASS="l">596</TD><TD>        }</TD></TR><TR><TD CLASS="l">597</TD><TD> </TD></TR><TR><TD CLASS="l">598</TD><TD>        public AbstractJmodelAction getSolveApp() {</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>                return solveApp;</TD></TR><TR><TD CLASS="l">600</TD><TD>        }</TD></TR><TR><TD CLASS="l">601</TD><TD> </TD></TR><TR><TD CLASS="l">602</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="2e">603</A></TD><TD>         * Gets cell factory to create new graph cells</TD></TR><TR><TD CLASS="l">604</TD><TD>         * @return cell factory</TD></TR><TR><TD CLASS="l">605</TD><TD>         */</TD></TR><TR><TD CLASS="l">606</TD><TD>        public CellFactory getCellFactory() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="71">607</A></TD><TD>                return cellFactory;</TD></TR><TR><TD CLASS="l">608</TD><TD>        }</TD></TR><TR><TD CLASS="l">609</TD><TD> </TD></TR><TR><TD CLASS="l">610</TD><TD>        public void newModel() {</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>                if (checkForSave(&#34;&lt;html&gt;Save changes before creating a new model?&lt;/html&gt;&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">613</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>                resetMouseState();</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>                graph = new JmtJGraph(this);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a3">616</A></TD><TD>                graph.setModel(new DefaultGraphModel());</TD></TR><TR><TD CLASS="l">617</TD><TD> </TD></TR><TR><TD CLASS="l">618</TD><TD>                // Giuseppe De Cicco</TD></TR><TR><TD CLASS="l">619</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">620</TD><TD>                graph.getGraphLayoutCache().setFactory(new JmtDefaultCellViewFactory(this) {</TD></TR><TR><TD CLASS="l">621</TD><TD> </TD></TR><TR><TD CLASS="l">622</TD><TD>                        /**</TD></TR><TR><TD CLASS="l">623</TD><TD>                         * </TD></TR><TR><TD CLASS="l">624</TD><TD>                         */</TD></TR><TR><TD CLASS="l">625</TD><TD>                        private static final long serialVersionUID = -8352272370225918131L;</TD></TR><TR><TD CLASS="l"><A NAME="a5">626</A></TD><TD> </TD></TR><TR><TD CLASS="l">627</TD><TD>                        // Override per creare il RENDERER - Giuseppe De Cicco</TD></TR><TR><TD CLASS="l">628</TD><TD>                        protected EdgeView createEdgeView(Object cell) {</TD></TR><TR><TD CLASS="l">629</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">630</TD><TD>                                if (cell instanceof Edge || cell instanceof JmtEdge) {</TD></TR><TR><TD CLASS="l">631</TD><TD>                                        // System.out.println(&#34;Lato personalizzato&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">632</TD><TD>                                        return new JmtEdgeView(cell, mediator);</TD></TR><TR><TD CLASS="l">633</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>                                        return new JmtEdgeView(cell, mediator);</TD></TR><TR><TD CLASS="l">635</TD><TD>                                }</TD></TR><TR><TD CLASS="l">636</TD><TD>                        }</TD></TR><TR><TD CLASS="l">637</TD><TD>                });</TD></TR><TR><TD CLASS="l">638</TD><TD>                // end</TD></TR><TR><TD CLASS="l">639</TD><TD> </TD></TR><TR><TD CLASS="l">640</TD><TD>                // Sets the cloneable flag to 'false'</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>                graph.setCloneable(false);</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>                graph.setGridSize(20);</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>                graph.setGridVisible(true);</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>                if (advanced) {</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                        graph.setBackground(new Color(120, 120, 120));</TD></TR><TR><TD CLASS="l">646</TD><TD>                }</TD></TR><TR><TD CLASS="l">647</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                graph.addMouseListener(mouseListner);</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>                graph.addMouseMotionListener(mouseListner);</TD></TR><TR><TD CLASS="l">650</TD><TD> </TD></TR><TR><TD CLASS="l">651</TD><TD>                // Conti Andrea</TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>                undoProxy.discardAllEdits();</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>                graph.getModel().addUndoableEditListener(undoProxy);</TD></TR><TR><TD CLASS="l">654</TD><TD>                // end</TD></TR><TR><TD CLASS="l">655</TD><TD> </TD></TR><TR><TD CLASS="l">656</TD><TD>                // Bertoli Marco</TD></TR><TR><TD CLASS="l">657</TD><TD>                // Instantiates a new JMODELModel data structure to store the entire</TD></TR><TR><TD CLASS="l">658</TD><TD>                // model</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                model = new JMODELModel();</TD></TR><TR><TD CLASS="l">660</TD><TD>                // end</TD></TR><TR><TD CLASS="l">661</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                mainWindow.setGraph(graph);</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                closeModel.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>                saveModel.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>                saveModelAs.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>                editMeasures.setEnabled(true);</TD></TR><TR><TD CLASS="l">667</TD><TD>                // Bertoli Marco</TD></TR><TR><TD CLASS="l">668</TD><TD>                // Show only insert options on ComponentBar</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                componentBar.clearButtonGroupSelection(0);</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                componentBar.enableButtonGroup(0, true);</TD></TR><TR><TD CLASS="l">671</TD><TD> </TD></TR><TR><TD CLASS="l">672</TD><TD>                // Disables show results button and measure definition, until simulation</TD></TR><TR CLASS="z"><TD CLASS="l">673</TD><TD>                showResults.setSelected(false);</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                showResults.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">675</TD><TD>                if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>                        resultsWindow.dispose();</TD></TR><TR><TD CLASS="l">677</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">678</TD><TD>                resultsWindow = null;</TD></TR><TR><TD CLASS="l">679</TD><TD> </TD></TR><TR><TD CLASS="l">680</TD><TD>                // Disables cut/copy/delete (leave paste enabled as clipboard is not</TD></TR><TR><TD CLASS="l">681</TD><TD>                // flushed)</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>                enableCopyAction(false);</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>                enableCutAction(false);</TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>                enableDeleteAction(false);</TD></TR><TR><TD CLASS="l">685</TD><TD>                // end</TD></TR><TR><TD CLASS="l">686</TD><TD> </TD></TR><TR><TD CLASS="l">687</TD><TD>                // Disables creation of blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">688</TD><TD>                enableAddBlockingRegion(false);</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                setConnect.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>                setSelect.setEnabled(false);</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR><TD CLASS="l">692</TD><TD>                // Enable the action to perform editing user classes</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>                editUserClasses.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">694</TD><TD>                switchToExactSolver.setEnabled(true);</TD></TR><TR><TD CLASS="l">695</TD><TD>                // Enables the botton to start simualtion</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>                simulate.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>                editSimParams.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">698</TD><TD>                editPAParams.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                takeScreenShot.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                openedArchive = null;</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>                mainWindow.updateTitle(null);</TD></TR><TR><TD CLASS="l">702</TD><TD>                // Free same resources by forcing a garbage collection</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>                System.gc();</TD></TR><TR CLASS="z"><TD CLASS="l">704</TD><TD>        }</TD></TR><TR><TD CLASS="l">705</TD><TD> </TD></TR><TR><TD CLASS="l">706</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="72">707</A></TD><TD>         * Opens a model from a data file.</TD></TR><TR><TD CLASS="l">708</TD><TD>         * &lt;br&gt; Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">709</TD><TD>         */</TD></TR><TR><TD CLASS="l">710</TD><TD>        public void openModel() {</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                isReleased = true;</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                if (checkForSave(&#34;&lt;html&gt;Save changes before opening a saved model?&lt;/html&gt;&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">714</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                JMODELModel tmpmodel = new JMODELModel();</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                int state = modelLoader.loadModel(tmpmodel, mainWindow);</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>                if (state == ModelLoader.SUCCESS || state == ModelLoader.WARNING) {</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>                        resetMouseState();</TD></TR><TR><TD CLASS="l">719</TD><TD>                        // Avoid checkForSave again...</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>                        if (model != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                                model.resetSaveState();</TD></TR><TR><TD CLASS="l">722</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">723</TD><TD>                        newModel();</TD></TR><TR><TD CLASS="l">724</TD><TD>                        // At this point loading was successful, so substitutes old model</TD></TR><TR><TD CLASS="l">725</TD><TD>                        // with loaded one</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                        model = tmpmodel;</TD></TR><TR CLASS="z"><TD CLASS="l">727</TD><TD>                        this.populateGraph();</TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>                        setSelect.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>                        componentBar.clickButton(setSelect);</TD></TR><TR CLASS="z"><TD CLASS="l">730</TD><TD>                        openedArchive = modelLoader.getSelectedFile();</TD></TR><TR CLASS="z"><TD CLASS="l">731</TD><TD>                        mainWindow.updateTitle(openedArchive.getName());</TD></TR><TR><TD CLASS="l">732</TD><TD>                        // Removes selection</TD></TR><TR CLASS="z"><TD CLASS="l">733</TD><TD>                        graph.clearSelection();</TD></TR><TR><TD CLASS="l">734</TD><TD>                        // If model contains results, enable Results Window</TD></TR><TR CLASS="z"><TD CLASS="l">735</TD><TD>                        if (model.containsSimulationResults()) {</TD></TR><TR CLASS="z"><TD CLASS="l">736</TD><TD>                                if (model.isParametricAnalysisEnabled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>                                        this.setResultsWindow(new PAResultsWindow(model.getParametricAnalysisModel(), (PAResultsModel) model.getSimulationResults()));</TD></TR><TR CLASS="z"><TD CLASS="l">738</TD><TD>                                        showResults.setEnabled(true);</TD></TR><TR><TD CLASS="l">739</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">740</TD><TD>                                        this.setResultsWindow(new ResultsWindow(model.getSimulationResults()));</TD></TR><TR CLASS="z"><TD CLASS="l">741</TD><TD>                                        showResults.setEnabled(true);</TD></TR><TR><TD CLASS="l">742</TD><TD>                                }</TD></TR><TR><TD CLASS="l">743</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">744</TD><TD>                        model.resetSaveState();</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>                        System.gc();</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                } else if (state == ModelLoader.FAILURE) {</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>                        showErrorMessage(modelLoader.getFailureMotivation());</TD></TR><TR><TD CLASS="l">748</TD><TD>                }</TD></TR><TR><TD CLASS="l">749</TD><TD>                // Shows warnings if any</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>                if (state == ModelLoader.WARNING) {</TD></TR><TR CLASS="z"><TD CLASS="l">751</TD><TD>                        new WarningWindow(modelLoader.getLastWarnings(), mainWindow, modelLoader.getInputFileFormat(), CommonConstants.JSIM).show();</TD></TR><TR><TD CLASS="l">752</TD><TD>                }</TD></TR><TR><TD CLASS="l">753</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="d">754</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">755</TD><TD> </TD></TR><TR><TD CLASS="l">756</TD><TD>        public void closeModel() {</TD></TR><TR><TD CLASS="l">757</TD><TD>                // Checks if there's an old graph to save</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>                if (checkForSave(&#34;&lt;html&gt;Save changes before closing?&lt;/html&gt;&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">760</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>                resetMouseState();</TD></TR><TR><TD CLASS="l">762</TD><TD> </TD></TR><TR><TD CLASS="l">763</TD><TD>                // clear undo history</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                graph.getModel().removeUndoableEditListener(undoProxy);</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                undoProxy.discardAllEdits();</TD></TR><TR><TD CLASS="l">766</TD><TD>                // end</TD></TR><TR><TD CLASS="l">767</TD><TD>                // graph.setModel(null); //wreaks quite a bit of havoc</TD></TR><TR CLASS="z"><TD CLASS="l">768</TD><TD>                mainWindow.removeGraph();</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>                graph = null;</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>                closeModel.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>                saveModel.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>                editMeasures.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">773</TD><TD>                saveModelAs.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">774</TD><TD>                componentBar.clearButtonGroupSelection(0);</TD></TR><TR CLASS="z"><TD CLASS="l">775</TD><TD>                componentBar.enableButtonGroup(0, false);</TD></TR><TR CLASS="z"><TD CLASS="l">776</TD><TD>                setConnect.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">777</TD><TD>                actionCopy.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">778</TD><TD>                actionCut.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">779</TD><TD>                actionPaste.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">780</TD><TD>                actionDelete.setEnabled(false);</TD></TR><TR><TD CLASS="l">781</TD><TD>                // FG</TD></TR><TR CLASS="z"><TD CLASS="l">782</TD><TD>                actionSetRight.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">783</TD><TD>                actionRotate.setEnabled(false);</TD></TR><TR><TD CLASS="l">784</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>                setSelect.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>                simulate.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>                solveAnalitic.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>                solveApp.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                editUserClasses.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>                editMeasures.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">791</TD><TD>                switchToExactSolver.setEnabled(false);</TD></TR><TR><TD CLASS="l">792</TD><TD>                // Disables the botton to start simualtion</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                simulate.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">794</TD><TD>                editSimParams.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">795</TD><TD>                editPAParams.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">796</TD><TD>                takeScreenShot.setEnabled(false);</TD></TR><TR><TD CLASS="l">797</TD><TD>                // Disables show results button and measure definition</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>                showResults.setSelected(false);</TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>                showResults.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>                if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">801</TD><TD>                        resultsWindow.dispose();</TD></TR><TR><TD CLASS="l">802</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>                resultsWindow = null;</TD></TR><TR CLASS="z"><TD CLASS="l">804</TD><TD>                openedArchive = null;</TD></TR><TR CLASS="z"><TD CLASS="l">805</TD><TD>                model = new JMODELModel();</TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>                mainWindow.updateTitle(null);</TD></TR><TR><TD CLASS="l">807</TD><TD>                // Free same resources by forcing a garbage collection</TD></TR><TR CLASS="z"><TD CLASS="l">808</TD><TD>                System.gc();</TD></TR><TR CLASS="z"><TD CLASS="l">809</TD><TD>        }</TD></TR><TR><TD CLASS="l">810</TD><TD> </TD></TR><TR><TD CLASS="l">811</TD><TD>        /** Inserts a new cell (vertex) in the desired point into the graph.</TD></TR><TR><TD CLASS="l">812</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="1">813</A></TD><TD>         * @param newCell the new cell</TD></TR><TR><TD CLASS="l">814</TD><TD>         * @param pt point in absolute coordinates in the</TD></TR><TR><TD CLASS="l">815</TD><TD>         */</TD></TR><TR><TD CLASS="l">816</TD><TD>        public void InsertCell(Point2D pt, JmtCell newCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">817</TD><TD>                pt = graph.snap(pt);</TD></TR><TR CLASS="z"><TD CLASS="l">818</TD><TD>                Object[] arg = new Object[] { newCell };</TD></TR><TR CLASS="z"><TD CLASS="l">819</TD><TD>                graph.getModel().insert(arg, newCell.setAttributes(pt, graph), null, null, null);</TD></TR><TR><TD CLASS="l">820</TD><TD>                // Puts new cell on back to go under blocking regions</TD></TR><TR CLASS="z"><TD CLASS="l">821</TD><TD>                graph.getModel().toBack(new Object[] { newCell });</TD></TR><TR CLASS="z"><TD CLASS="l">822</TD><TD>                newCell.resetParent();</TD></TR><TR CLASS="z"><TD CLASS="l">823</TD><TD>                setConnect.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">824</TD><TD>        }</TD></TR><TR><TD CLASS="l">825</TD><TD> </TD></TR><TR><TD CLASS="l">826</TD><TD>        /** Set the state of mouse listner to select &amp; passes the event to the</TD></TR><TR><TD CLASS="l">827</TD><TD>         * listner as if press event is generated.</TD></TR><TR><TD CLASS="l"><A NAME="81">828</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">829</TD><TD>         * @param e</TD></TR><TR><TD CLASS="l">830</TD><TD>         */</TD></TR><TR><TD CLASS="l">831</TD><TD>        public void selectAt(MouseEvent e) {</TD></TR><TR CLASS="z"><TD CLASS="l">832</TD><TD>                activateSelect();</TD></TR><TR CLASS="z"><TD CLASS="l">833</TD><TD>                mouseListner.mousePressed(e);</TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>        }</TD></TR><TR><TD CLASS="l">835</TD><TD> </TD></TR><TR><TD CLASS="l">836</TD><TD>        /**</TD></TR><TR><TD CLASS="l">837</TD><TD>         * Determines whether this component is enabled. An enabled component</TD></TR><TR><TD CLASS="l">838</TD><TD>         * can respond to user input and generate events. Components are</TD></TR><TR><TD CLASS="l">839</TD><TD>         * enabled initially by default. A component may be enabled or disabled by</TD></TR><TR><TD CLASS="l">840</TD><TD>         * calling its &lt;code&gt;setEnabled&lt;/code&gt; method.</TD></TR><TR><TD CLASS="l">841</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if the component is enabled,</TD></TR><TR><TD CLASS="l"><A NAME="6d">842</A></TD><TD>         *                 &lt;code&gt;false&lt;/code&gt; otherwise</TD></TR><TR><TD CLASS="l">843</TD><TD>         * @since JDK1.0</TD></TR><TR><TD CLASS="l">844</TD><TD>         */</TD></TR><TR><TD CLASS="l">845</TD><TD>        public boolean isGraphEnabled() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="64">846</A></TD><TD>                return graph.isEnabled();</TD></TR><TR><TD CLASS="l">847</TD><TD>        }</TD></TR><TR><TD CLASS="l">848</TD><TD> </TD></TR><TR><TD CLASS="l">849</TD><TD>        public void graphRequestFocus() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5f">850</A></TD><TD>                graph.requestFocus();</TD></TR><TR CLASS="z"><TD CLASS="l">851</TD><TD>        }</TD></TR><TR><TD CLASS="l">852</TD><TD> </TD></TR><TR><TD CLASS="l">853</TD><TD>        public int getTolerance() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="28">854</A></TD><TD>                return graph.getTolerance();</TD></TR><TR><TD CLASS="l">855</TD><TD>        }</TD></TR><TR><TD CLASS="l">856</TD><TD> </TD></TR><TR><TD CLASS="l">857</TD><TD>        public Rectangle2D fromScreen(Rectangle2D r) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="27">858</A></TD><TD>                return graph.fromScreen(r);</TD></TR><TR><TD CLASS="l">859</TD><TD>        }</TD></TR><TR><TD CLASS="l">860</TD><TD> </TD></TR><TR><TD CLASS="l">861</TD><TD>        public Point2D fromScreen(Point2D p) {</TD></TR><TR CLASS="z"><TD CLASS="l">862</TD><TD>                return graph.fromScreen(p);</TD></TR><TR><TD CLASS="l">863</TD><TD>        }</TD></TR><TR><TD CLASS="l">864</TD><TD> </TD></TR><TR><TD CLASS="l">865</TD><TD>        /**</TD></TR><TR><TD CLASS="l">866</TD><TD>         * Returns this graph's graphics context, which lets you draw</TD></TR><TR><TD CLASS="l">867</TD><TD>         * on a component. Use this method get a &lt;code&gt;Graphics&lt;/code&gt; object and</TD></TR><TR><TD CLASS="l">868</TD><TD>         * then invoke operations on that object to draw on the component.</TD></TR><TR><TD CLASS="l"><A NAME="3f">869</A></TD><TD>         * @return this components graphics context</TD></TR><TR><TD CLASS="l">870</TD><TD>         */</TD></TR><TR><TD CLASS="l">871</TD><TD>        public Graphics2D getGraphGraphics() {</TD></TR><TR><TD CLASS="l">872</TD><TD>                // DEK (Federico Granata) 17-11-2003</TD></TR><TR CLASS="z"><TD CLASS="l">873</TD><TD>                return (Graphics2D) graph.getGraphics();</TD></TR><TR><TD CLASS="l">874</TD><TD>                // end 17-11-2003</TD></TR><TR><TD CLASS="l"><A NAME="44">875</A></TD><TD>                // return mainWindow.getGraphics();</TD></TR><TR><TD CLASS="l">876</TD><TD>        }</TD></TR><TR><TD CLASS="l">877</TD><TD> </TD></TR><TR><TD CLASS="l">878</TD><TD>        public CellView getNextViewAt(CellView current, double x, double y) {</TD></TR><TR CLASS="z"><TD CLASS="l">879</TD><TD>                return graph.getNextViewAt(current, x, y);</TD></TR><TR><TD CLASS="l">880</TD><TD>        }</TD></TR><TR><TD CLASS="l">881</TD><TD> </TD></TR><TR><TD CLASS="l">882</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6b">883</A></TD><TD>         * Returning true signifies the marquee handler has precedence over</TD></TR><TR><TD CLASS="l">884</TD><TD>         * other handlers, and is receiving subsequent mouse events.</TD></TR><TR><TD CLASS="l">885</TD><TD>         */</TD></TR><TR><TD CLASS="l">886</TD><TD>        public boolean isForceMarqueeEvent(MouseEvent e) {</TD></TR><TR CLASS="z"><TD CLASS="l">887</TD><TD>                return ((JmtGraphUI) graph.getUI()).isForceMarqueeEvent(e);</TD></TR><TR><TD CLASS="l">888</TD><TD>        }</TD></TR><TR><TD CLASS="l">889</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="35">890</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">891</TD><TD>         * Returns the number of clicks for editing of the graph to start.</TD></TR><TR><TD CLASS="l">892</TD><TD>         */</TD></TR><TR><TD CLASS="l">893</TD><TD>        public int getEditClickCount() {</TD></TR><TR CLASS="z"><TD CLASS="l">894</TD><TD>                return graph.getEditClickCount();</TD></TR><TR><TD CLASS="l">895</TD><TD>        }</TD></TR><TR><TD CLASS="l">896</TD><TD> </TD></TR><TR><TD CLASS="l">897</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="70">898</A></TD><TD>         * Returning true signifies a mouse event on the cell should toggle</TD></TR><TR><TD CLASS="l">899</TD><TD>         * the selection of only the cell under mouse.</TD></TR><TR><TD CLASS="l">900</TD><TD>         */</TD></TR><TR><TD CLASS="l">901</TD><TD>        public boolean isToggleSelectionEvent(MouseEvent e) {</TD></TR><TR CLASS="z"><TD CLASS="l">902</TD><TD>                return ((JmtGraphUI) graph.getUI()).isToggleSelectionEvent(e);</TD></TR><TR><TD CLASS="l">903</TD><TD>        }</TD></TR><TR><TD CLASS="l">904</TD><TD> </TD></TR><TR><TD CLASS="l">905</TD><TD>        /**</TD></TR><TR><TD CLASS="l">906</TD><TD>         * Returns true if the cell is currently selected.</TD></TR><TR><TD CLASS="l"><A NAME="69">907</A></TD><TD>         * @param cell an object identifying a cell</TD></TR><TR><TD CLASS="l">908</TD><TD>         * @return true if the cell is selected</TD></TR><TR><TD CLASS="l">909</TD><TD>         */</TD></TR><TR><TD CLASS="l">910</TD><TD>        public boolean isCellSelected(Object cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">911</TD><TD>                return graph.isCellSelected(cell);</TD></TR><TR><TD CLASS="l">912</TD><TD>        }</TD></TR><TR><TD CLASS="l">913</TD><TD> </TD></TR><TR><TD CLASS="l">914</TD><TD>        /**</TD></TR><TR><TD CLASS="l">915</TD><TD>         * Messaged to update the selection based on a MouseEvent over a</TD></TR><TR><TD CLASS="l">916</TD><TD>         * particular cell. If the event is a toggle selection event, the</TD></TR><TR><TD CLASS="l"><A NAME="82">917</A></TD><TD>         * cell is either selected, or deselected. Otherwise the cell is</TD></TR><TR><TD CLASS="l">918</TD><TD>         * selected.</TD></TR><TR><TD CLASS="l">919</TD><TD>         */</TD></TR><TR><TD CLASS="l">920</TD><TD>        public void selectCellForEvent(Object cell, MouseEvent e) {</TD></TR><TR CLASS="z"><TD CLASS="l">921</TD><TD>                ((JmtGraphUI) graph.getUI()).selectCellForEvent(cell, e);</TD></TR><TR CLASS="z"><TD CLASS="l">922</TD><TD>        }</TD></TR><TR><TD CLASS="l">923</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="9">924</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">925</TD><TD>         * Scroll the graph for an event at &lt;code&gt;p&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">926</TD><TD>         */</TD></TR><TR><TD CLASS="l">927</TD><TD>        public void autoscroll(Point p) {</TD></TR><TR CLASS="z"><TD CLASS="l">928</TD><TD>                BasicGraphUI.autoscroll(graph, p);</TD></TR><TR CLASS="z"><TD CLASS="l">929</TD><TD>        }</TD></TR><TR><TD CLASS="l">930</TD><TD> </TD></TR><TR><TD CLASS="l">931</TD><TD>        /**</TD></TR><TR><TD CLASS="l">932</TD><TD>         * Gets the cursor set in the graph. If the graph does</TD></TR><TR><TD CLASS="l">933</TD><TD>         * not have a cursor set, the cursor of its parent is returned.</TD></TR><TR><TD CLASS="l"><A NAME="3e">934</A></TD><TD>         * If no cursor is set in the entire hierarchy,</TD></TR><TR><TD CLASS="l">935</TD><TD>         * &lt;code&gt;Cursor.DEFAULT_CURSOR&lt;/code&gt; is returned.</TD></TR><TR><TD CLASS="l">936</TD><TD>         */</TD></TR><TR><TD CLASS="l">937</TD><TD>        public Cursor getGraphCursor() {</TD></TR><TR CLASS="z"><TD CLASS="l">938</TD><TD>                return graph.getCursor();</TD></TR><TR><TD CLASS="l">939</TD><TD>        }</TD></TR><TR><TD CLASS="l">940</TD><TD> </TD></TR><TR><TD CLASS="l">941</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="87">942</A></TD><TD>         * Sets graph cursor</TD></TR><TR><TD CLASS="l">943</TD><TD>         * @param cursor to be setted</TD></TR><TR><TD CLASS="l">944</TD><TD>         */</TD></TR><TR><TD CLASS="l">945</TD><TD>        public void setGraphCursor(Cursor cursor) {</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>                graph.setCursor(cursor);</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>        }</TD></TR><TR><TD CLASS="l">948</TD><TD> </TD></TR><TR><TD CLASS="l">949</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6c">950</A></TD><TD>         * Returns true if the graph is being edited.  The item that is being</TD></TR><TR><TD CLASS="l">951</TD><TD>         * edited can be returned by getEditingCell().</TD></TR><TR><TD CLASS="l">952</TD><TD>         */</TD></TR><TR><TD CLASS="l">953</TD><TD>        public boolean isGraphEditing() {</TD></TR><TR CLASS="z"><TD CLASS="l">954</TD><TD>                return graph.getUI().isEditing(graph);</TD></TR><TR><TD CLASS="l">955</TD><TD>        }</TD></TR><TR><TD CLASS="l">956</TD><TD> </TD></TR><TR><TD CLASS="l">957</TD><TD>        /**</TD></TR><TR><TD CLASS="l">958</TD><TD>         * Returns the given point applied to the grid.</TD></TR><TR><TD CLASS="l"><A NAME="98">959</A></TD><TD>         * @param p a point in screen coordinates.</TD></TR><TR><TD CLASS="l">960</TD><TD>         * @return the same point applied to the grid.</TD></TR><TR><TD CLASS="l">961</TD><TD>         */</TD></TR><TR><TD CLASS="l">962</TD><TD>        public Point2D snap(Point2D p) {</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>                return graph.snap(p);</TD></TR><TR><TD CLASS="l">964</TD><TD>        }</TD></TR><TR><TD CLASS="l">965</TD><TD> </TD></TR><TR><TD CLASS="l">966</TD><TD>        /**</TD></TR><TR><TD CLASS="l">967</TD><TD>         * Upscale the given point in place, ie.</TD></TR><TR><TD CLASS="l">968</TD><TD>         * using the given instance.</TD></TR><TR><TD CLASS="l"><A NAME="9e">969</A></TD><TD>         * @param p the point to be upscaled</TD></TR><TR><TD CLASS="l">970</TD><TD>         * @return the upscaled point instance</TD></TR><TR><TD CLASS="l">971</TD><TD>         */</TD></TR><TR><TD CLASS="l">972</TD><TD>        public Point2D toScreen(Point2D p) {</TD></TR><TR CLASS="z"><TD CLASS="l">973</TD><TD>                return graph.toScreen(p);</TD></TR><TR><TD CLASS="l">974</TD><TD>        }</TD></TR><TR><TD CLASS="l">975</TD><TD> </TD></TR><TR><TD CLASS="l">976</TD><TD>        /**</TD></TR><TR><TD CLASS="l">977</TD><TD>         * Gets the background color of graph.</TD></TR><TR><TD CLASS="l">978</TD><TD>         * @return this component's background color; if this component does</TD></TR><TR><TD CLASS="l"><A NAME="3d">979</A></TD><TD>         *                 not have a background color,</TD></TR><TR><TD CLASS="l">980</TD><TD>         *                the background color of its parent is returned</TD></TR><TR><TD CLASS="l">981</TD><TD>         */</TD></TR><TR><TD CLASS="l">982</TD><TD>        public Color getGraphBackground() {</TD></TR><TR CLASS="z"><TD CLASS="l">983</TD><TD>                return graph.getBackground();</TD></TR><TR><TD CLASS="l">984</TD><TD>        }</TD></TR><TR><TD CLASS="l">985</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="40">986</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">987</TD><TD>         * Returns the current marquee color of the graph.</TD></TR><TR><TD CLASS="l">988</TD><TD>         */</TD></TR><TR><TD CLASS="l">989</TD><TD>        public Color getGraphMarqueeColor() {</TD></TR><TR CLASS="z"><TD CLASS="l">990</TD><TD>                return graph.getMarqueeColor();</TD></TR><TR><TD CLASS="l">991</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="10">992</A></TD><TD> </TD></TR><TR><TD CLASS="l">993</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">994</TD><TD>        // protected boolean no = true;</TD></TR><TR><TD CLASS="l">995</TD><TD>        public void connect(Point2D start, Point2D current, PortView inPort, PortView outPort) {</TD></TR><TR CLASS="z"><TD CLASS="l">996</TD><TD>                Point2D p = fromScreen(start);</TD></TR><TR CLASS="z"><TD CLASS="l">997</TD><TD>                Point2D p2 = fromScreen(current);</TD></TR><TR CLASS="z"><TD CLASS="l">998</TD><TD>                if (inPort != null &amp;&amp; outPort != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>                        ArrayList&lt;Point2D&gt; list = new ArrayList&lt;Point2D&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>                        list.add(p);</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>                        list.add(p2);</TD></TR><TR CLASS="z"><TD CLASS="l">1002</TD><TD>                        Map map = new Hashtable();</TD></TR><TR CLASS="z"><TD CLASS="l">1003</TD><TD>                        GraphConstants.setPoints(map, list);</TD></TR><TR CLASS="z"><TD CLASS="l">1004</TD><TD>                        GraphConstants.setRouting(map, GraphConstants.ROUTING_SIMPLE);</TD></TR><TR CLASS="z"><TD CLASS="l">1005</TD><TD>                        GraphConstants.setRouting(map, JmtGraphConstants.ROUTING_JMT);</TD></TR><TR CLASS="z"><TD CLASS="l">1006</TD><TD>                        GraphConstants.setEndFill(map, true);</TD></TR><TR><TD CLASS="l">1007</TD><TD> </TD></TR><TR><TD CLASS="l">1008</TD><TD>                        // 24/09/03 - Massimo Cattai</TD></TR><TR><TD CLASS="l">1009</TD><TD>                        // //////////////////////////////////////////</TD></TR><TR><TD CLASS="l">1010</TD><TD>                        // Add a Line End Attribute</TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>                        GraphConstants.setLineEnd(map, GraphConstants.ARROW_CLASSIC);</TD></TR><TR><TD CLASS="l">1012</TD><TD>                        // 24/09/03 - end</TD></TR><TR><TD CLASS="l">1013</TD><TD>                        // /////////////////////////////////////////////////////</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>                        Map&lt;Object, Map&gt; viewMap = new Hashtable&lt;Object, Map&gt;();</TD></TR><TR><TD CLASS="l">1015</TD><TD>                        // ---- Adds connection into underlayng data structure -- BERTOLI</TD></TR><TR><TD CLASS="l">1016</TD><TD>                        // MARCO</TD></TR><TR CLASS="z"><TD CLASS="l">1017</TD><TD>                        Object sourceKey = ((CellComponent) ((JmtCell) ((OutputPort) (outPort.getCell())).getUserObject()).getUserObject()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1018</TD><TD>                        Object targetKey = ((CellComponent) ((JmtCell) ((InputPort) (inPort.getCell())).getUserObject()).getUserObject()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1019</TD><TD>                        JmtEdge connection = new JmtEdge(sourceKey, targetKey, this);</TD></TR><TR CLASS="z"><TD CLASS="l">1020</TD><TD>                        viewMap.put(connection, map);</TD></TR><TR CLASS="z"><TD CLASS="l">1021</TD><TD>                        Object[] insert = new Object[] { connection };</TD></TR><TR CLASS="z"><TD CLASS="l">1022</TD><TD>                        ConnectionSet cs = new ConnectionSet();</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>                        cs.connect(connection, outPort.getCell(), true);</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                        cs.connect(connection, inPort.getCell(), false);</TD></TR><TR><TD CLASS="l">1025</TD><TD>                        // Visualize connection only if it can be created into data</TD></TR><TR><TD CLASS="l">1026</TD><TD>                        // structure</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>                        if (model.setConnected(sourceKey, targetKey, true)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1028</TD><TD>                                graph.getModel().insert(insert, viewMap, cs, null, null);</TD></TR><TR><TD CLASS="l">1029</TD><TD>                                // FG</TD></TR><TR><TD CLASS="l">1030</TD><TD>                                // no = false;</TD></TR><TR><TD CLASS="l">1031</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1032</TD><TD>                        // ---- End -- BERTOLI MARCO</TD></TR><TR><TD CLASS="l">1033</TD><TD>                }</TD></TR><TR><TD CLASS="l">1034</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1035</TD><TD>        }</TD></TR><TR><TD CLASS="l">1036</TD><TD> </TD></TR><TR><TD CLASS="l">1037</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1038</TD><TD>         * Creates a connection between given source and target JmtCells</TD></TR><TR><TD CLASS="l">1039</TD><TD>         * @param source source cell</TD></TR><TR><TD CLASS="l">1040</TD><TD>         * @param target target cell</TD></TR><TR><TD CLASS="l">1041</TD><TD>         * @return created component or null if connection between source and target cannot be created</TD></TR><TR><TD CLASS="l"><A NAME="e">1042</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">1043</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1044</TD><TD>         */</TD></TR><TR><TD CLASS="l">1045</TD><TD>        public JmtEdge connect(JmtCell source, JmtCell target) {</TD></TR><TR CLASS="z"><TD CLASS="l">1046</TD><TD>                return connect(source, target, false);</TD></TR><TR><TD CLASS="l">1047</TD><TD>        }</TD></TR><TR><TD CLASS="l">1048</TD><TD> </TD></TR><TR><TD CLASS="l">1049</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1050</TD><TD>         * Creates a connection between given source and target JmtCells</TD></TR><TR><TD CLASS="l">1051</TD><TD>         * @param source source cell</TD></TR><TR><TD CLASS="l">1052</TD><TD>         * @param target target cell</TD></TR><TR><TD CLASS="l">1053</TD><TD>         * @param forced true if connection must be shown also if could not be created into data structure.</TD></TR><TR><TD CLASS="l">1054</TD><TD>         * @return created component or null if connection between source and target cannot be created</TD></TR><TR><TD CLASS="l">1055</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="f">1056</A></TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1057</TD><TD>         */</TD></TR><TR><TD CLASS="l">1058</TD><TD>        public JmtEdge connect(JmtCell source, JmtCell target, boolean forced) {</TD></TR><TR><TD CLASS="l">1059</TD><TD>                // If one of parameter is null, returns null</TD></TR><TR CLASS="z"><TD CLASS="l">1060</TD><TD>                if (source == null || target == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">1062</TD><TD>                }</TD></TR><TR><TD CLASS="l">1063</TD><TD>                // Retrives source and target keys to create connection</TD></TR><TR CLASS="z"><TD CLASS="l">1064</TD><TD>                Object sourceKey = ((CellComponent) source.getUserObject()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>                Object targetKey = ((CellComponent) target.getUserObject()).getKey();</TD></TR><TR><TD CLASS="l">1066</TD><TD>                // Initializes correct layout for routing edges</TD></TR><TR CLASS="z"><TD CLASS="l">1067</TD><TD>                Map map = new Hashtable();</TD></TR><TR CLASS="z"><TD CLASS="l">1068</TD><TD>                GraphConstants.setRouting(map, GraphConstants.ROUTING_SIMPLE);</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                GraphConstants.setRouting(map, JmtGraphConstants.ROUTING_JMT);</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                GraphConstants.setLineEnd(map, GraphConstants.ARROW_CLASSIC);</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>                GraphConstants.setEndFill(map, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>                Map&lt;Object, Map&gt; viewMap = new Hashtable&lt;Object, Map&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>                JmtEdge connection = new JmtEdge(sourceKey, targetKey, this);</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>                viewMap.put(connection, map);</TD></TR><TR CLASS="z"><TD CLASS="l">1075</TD><TD>                Object[] insert = new Object[] { connection };</TD></TR><TR CLASS="z"><TD CLASS="l">1076</TD><TD>                ConnectionSet cs = new ConnectionSet();</TD></TR><TR><TD CLASS="l">1077</TD><TD>                // Finds sourcePort</TD></TR><TR><TD CLASS="l">1078</TD><TD>                Iterator it;</TD></TR><TR CLASS="z"><TD CLASS="l">1079</TD><TD>                it = source.getChildren().iterator();</TD></TR><TR><TD CLASS="l">1080</TD><TD>                DefaultPort tmpPort, sourcePort, targetPort;</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>                sourcePort = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>                while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1083</TD><TD>                        tmpPort = (DefaultPort) it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>                        if (tmpPort instanceof OutputPort) {</TD></TR><TR CLASS="z"><TD CLASS="l">1085</TD><TD>                                sourcePort = tmpPort;</TD></TR><TR><TD CLASS="l">1086</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1087</TD><TD>                }</TD></TR><TR><TD CLASS="l">1088</TD><TD>                // Finds targetPort</TD></TR><TR CLASS="z"><TD CLASS="l">1089</TD><TD>                it = target.getChildren().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>                targetPort = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>                while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1092</TD><TD>                        tmpPort = (DefaultPort) it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1093</TD><TD>                        if (tmpPort instanceof InputPort) {</TD></TR><TR CLASS="z"><TD CLASS="l">1094</TD><TD>                                targetPort = tmpPort;</TD></TR><TR><TD CLASS="l">1095</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1096</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1097</TD><TD>                if (sourcePort != null &amp;&amp; targetPort != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>                        cs.connect(connection, sourcePort, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>                        cs.connect(connection, targetPort, false);</TD></TR><TR><TD CLASS="l">1100</TD><TD>                        // Adds connection to the graph only if it can be created into data</TD></TR><TR><TD CLASS="l">1101</TD><TD>                        // structure</TD></TR><TR CLASS="z"><TD CLASS="l">1102</TD><TD>                        if (model.setConnected(sourceKey, targetKey, true) || forced) {</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>                                graph.getModel().insert(insert, viewMap, cs, null, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1104</TD><TD>                                return connection;</TD></TR><TR><TD CLASS="l">1105</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1106</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1107</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">1108</TD><TD>        }</TD></TR><TR><TD CLASS="l">1109</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="63">1110</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1111</TD><TD>         * repaints the graph component</TD></TR><TR><TD CLASS="l">1112</TD><TD>         */</TD></TR><TR><TD CLASS="l">1113</TD><TD>        public void graphRepaint() {</TD></TR><TR CLASS="z"><TD CLASS="l">1114</TD><TD>                graph.repaint();</TD></TR><TR CLASS="z"><TD CLASS="l">1115</TD><TD>        }</TD></TR><TR><TD CLASS="l">1116</TD><TD> </TD></TR><TR><TD CLASS="l">1117</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1118</TD><TD>         * Returns the parent of &lt;I&gt;child&lt;/I&gt; in the model.</TD></TR><TR><TD CLASS="l">1119</TD><TD>         * &lt;I&gt;child&lt;/I&gt; must be a node previously obtained from</TD></TR><TR><TD CLASS="l">1120</TD><TD>         * this data source. This returns null if &lt;i&gt;child&lt;/i&gt; is</TD></TR><TR><TD CLASS="l">1121</TD><TD>         * a root in the model.</TD></TR><TR><TD CLASS="l">1122</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="4a">1123</A></TD><TD>         * @param   child  a node in the graph, obtained from this data source</TD></TR><TR><TD CLASS="l">1124</TD><TD>         * @return  the parent of &lt;I&gt;child&lt;/I&gt;</TD></TR><TR><TD CLASS="l">1125</TD><TD>         */</TD></TR><TR><TD CLASS="l">1126</TD><TD>        public Object getParent(Object child) {</TD></TR><TR CLASS="z"><TD CLASS="l">1127</TD><TD>                return graph.getModel().getParent(child);</TD></TR><TR><TD CLASS="l">1128</TD><TD>        }</TD></TR><TR><TD CLASS="l">1129</TD><TD> </TD></TR><TR><TD CLASS="l">1130</TD><TD>        /** gets the first portView of the input port of the cell at position</TD></TR><TR><TD CLASS="l">1131</TD><TD>         *</TD></TR><TR><TD CLASS="l">1132</TD><TD>         * @param x</TD></TR><TR><TD CLASS="l"><A NAME="41">1133</A></TD><TD>         * @param y</TD></TR><TR><TD CLASS="l">1134</TD><TD>         * @return portView of the input port</TD></TR><TR><TD CLASS="l">1135</TD><TD>         */</TD></TR><TR><TD CLASS="l">1136</TD><TD>        public PortView getInPortViewAt(int x, int y) {</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>                return (PortView) graph.getGraphLayoutCache().getMapping(graph.getInPortAt(x, y), false);</TD></TR><TR><TD CLASS="l">1138</TD><TD>        }</TD></TR><TR><TD CLASS="l">1139</TD><TD> </TD></TR><TR><TD CLASS="l">1140</TD><TD>        /** gets the first portView of the output port of the cell at position</TD></TR><TR><TD CLASS="l">1141</TD><TD>         *</TD></TR><TR><TD CLASS="l">1142</TD><TD>         * @param x</TD></TR><TR><TD CLASS="l"><A NAME="48">1143</A></TD><TD>         * @param y</TD></TR><TR><TD CLASS="l">1144</TD><TD>         * @return portView of the output port</TD></TR><TR><TD CLASS="l">1145</TD><TD>         */</TD></TR><TR><TD CLASS="l">1146</TD><TD>        public PortView getOutPortViewAt(int x, int y) {</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>                return (PortView) graph.getGraphLayoutCache().getMapping(graph.getOutPortAt(x, y), false);</TD></TR><TR><TD CLASS="l">1148</TD><TD>        }</TD></TR><TR><TD CLASS="l">1149</TD><TD> </TD></TR><TR><TD CLASS="l">1150</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1151</TD><TD>         * Returns if a given cell is visible on graph</TD></TR><TR><TD CLASS="l"><A NAME="6a">1152</A></TD><TD>         * @param cell</TD></TR><TR><TD CLASS="l">1153</TD><TD>         * @return true iff cell is visible</TD></TR><TR><TD CLASS="l">1154</TD><TD>         */</TD></TR><TR><TD CLASS="l">1155</TD><TD>        public boolean isCellVisible(Object cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1156</TD><TD>                return ((JmtGraphUI) graph.getUI()).getGraphLayoutCache().isVisible(cell);</TD></TR><TR><TD CLASS="l">1157</TD><TD>        }</TD></TR><TR><TD CLASS="l">1158</TD><TD> </TD></TR><TR><TD CLASS="l">1159</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1160</TD><TD>         * Returns the views for the specified array of cells. Returned</TD></TR><TR><TD CLASS="l"><A NAME="62">1161</A></TD><TD>         * array may contain null pointers if the respective cell is not</TD></TR><TR><TD CLASS="l">1162</TD><TD>         * mapped in this view and &lt;code&gt;create&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1163</TD><TD>         */</TD></TR><TR><TD CLASS="l">1164</TD><TD>        public CellView getViewOfCell(Object cell, boolean create) {</TD></TR><TR CLASS="z"><TD CLASS="l">1165</TD><TD>                return ((JmtGraphUI) graph.getUI()).getGraphLayoutCache().getMapping(cell, create);</TD></TR><TR><TD CLASS="l">1166</TD><TD>        }</TD></TR><TR><TD CLASS="l">1167</TD><TD> </TD></TR><TR><TD CLASS="l">1168</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1169</TD><TD>         * Selects the specified cell and initiates editing.</TD></TR><TR><TD CLASS="l">1170</TD><TD>         * The edit-attempt fails if the &lt;code&gt;CellEditor&lt;/code&gt;</TD></TR><TR><TD CLASS="l"><A NAME="99">1171</A></TD><TD>         * does not allow</TD></TR><TR><TD CLASS="l">1172</TD><TD>         * editing for the specified item.</TD></TR><TR><TD CLASS="l">1173</TD><TD>         */</TD></TR><TR><TD CLASS="l">1174</TD><TD>        public void startEditingAtCell(Object cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1175</TD><TD>                graph.startEditingAtCell(cell);</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>                if ((cell != null) &amp;&amp; (cell instanceof JmtCell)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>                        JmtCell jcell = (JmtCell) cell;</TD></TR><TR CLASS="z"><TD CLASS="l">1178</TD><TD>                        StationParameterPanel stationPanel = new jmt.gui.common.panels.StationParameterPanel(model, model,</TD></TR><TR><TD CLASS="l">1179</TD><TD>                                        ((CellComponent) jcell.getUserObject()).getKey());</TD></TR><TR><TD CLASS="l">1180</TD><TD>                        // Adds on the top a panel to change station name</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>                        stationPanel.add(new StationNamePanel(model, ((CellComponent) jcell.getUserObject()).getKey()), BorderLayout.NORTH);</TD></TR><TR CLASS="z"><TD CLASS="l">1182</TD><TD>                        dialogFactory.getDialog(stationPanel, &#34;Editing &#34; + jcell.getUserObject().toString() + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">1183</TD><TD> </TD></TR><TR><TD CLASS="l">1184</TD><TD>                        // Updates cell dimensions if name was changed too much...</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                        Hashtable&lt;Object, Map&gt; nest = new Hashtable&lt;Object, Map&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1186</TD><TD>                        Dimension cellDimension = jcell.getSize(graph);</TD></TR><TR CLASS="z"><TD CLASS="l">1187</TD><TD>                        Map attr = jcell.getAttributes();</TD></TR><TR CLASS="z"><TD CLASS="l">1188</TD><TD>                        Rectangle2D oldBounds = GraphConstants.getBounds(attr);</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                        if (oldBounds.getWidth() != cellDimension.getWidth()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1190</TD><TD>                                GraphConstants.setBounds(attr, new Rectangle2D.Double(oldBounds.getX(), oldBounds.getY(), cellDimension.getWidth(), cellDimension</TD></TR><TR><TD CLASS="l">1191</TD><TD>                                                .getHeight()));</TD></TR><TR CLASS="z"><TD CLASS="l">1192</TD><TD>                                nest.put(cell, attr);</TD></TR><TR CLASS="z"><TD CLASS="l">1193</TD><TD>                                jcell.updatePortPositions(nest, GraphConstants.getIcon(attr), cellDimension);</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>                                graph.getGraphLayoutCache().edit(nest);</TD></TR><TR><TD CLASS="l">1195</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1196</TD><TD>                }</TD></TR><TR><TD CLASS="l">1197</TD><TD>                // Blocking region editing</TD></TR><TR CLASS="z"><TD CLASS="l">1198</TD><TD>                else if ((cell != null) &amp;&amp; (cell instanceof BlockingRegion)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1199</TD><TD>                        Object regionKey = ((BlockingRegion) cell).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1200</TD><TD>                        dialogFactory.getDialog(new BlockingRegionParameterPanel(model, model, regionKey), &#34;Editing &#34; + model.getRegionName(regionKey)</TD></TR><TR><TD CLASS="l">1201</TD><TD>                                        + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">1202</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1203</TD><TD>        }</TD></TR><TR><TD CLASS="l">1204</TD><TD> </TD></TR><TR><TD CLASS="l">1205</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="14">1206</A></TD><TD>         * Cuts the selection of the graph.</TD></TR><TR><TD CLASS="l">1207</TD><TD>         */</TD></TR><TR><TD CLASS="l">1208</TD><TD>        public void cutSelection() {</TD></TR><TR><TD CLASS="l">1209</TD><TD>                // Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">1210</TD><TD>                clipboard.cut();</TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>        }</TD></TR><TR><TD CLASS="l">1212</TD><TD> </TD></TR><TR><TD CLASS="l">1213</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="75">1214</A></TD><TD>         * Pastes the selection on the graph.</TD></TR><TR><TD CLASS="l">1215</TD><TD>         */</TD></TR><TR><TD CLASS="l">1216</TD><TD>        public void pasteSelection() {</TD></TR><TR><TD CLASS="l">1217</TD><TD>                // Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>                clipboard.paste();</TD></TR><TR><TD CLASS="l">1219</TD><TD> </TD></TR><TR><TD CLASS="l">1220</TD><TD>                // If more than one stations are present enables link button</TD></TR><TR CLASS="z"><TD CLASS="l">1221</TD><TD>                if (graph.getModel().getRootCount() &gt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1222</TD><TD>                        setConnect.setEnabled(true);</TD></TR><TR><TD CLASS="l">1223</TD><TD>                }</TD></TR><TR><TD CLASS="l">1224</TD><TD>                // If one station is present show select button</TD></TR><TR CLASS="z"><TD CLASS="l">1225</TD><TD>                if (graph.getModel().getRootCount() &gt;= 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1226</TD><TD>                        activateSelect();</TD></TR><TR><TD CLASS="l">1227</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1228</TD><TD>        }</TD></TR><TR><TD CLASS="l">1229</TD><TD> </TD></TR><TR><TD CLASS="l">1230</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="11">1231</A></TD><TD>         * Copies the selection of the graph.</TD></TR><TR><TD CLASS="l">1232</TD><TD>         */</TD></TR><TR><TD CLASS="l">1233</TD><TD>        public void copySelection() {</TD></TR><TR><TD CLASS="l">1234</TD><TD>                // Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">1235</TD><TD>                clipboard.copy();</TD></TR><TR CLASS="z"><TD CLASS="l">1236</TD><TD>        }</TD></TR><TR><TD CLASS="l">1237</TD><TD> </TD></TR><TR><TD CLASS="l">1238</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1239</TD><TD>         * Displays an error message in the panel that is responable to make the</TD></TR><TR><TD CLASS="l">1240</TD><TD>         * user understand why a certain operation is not valid.</TD></TR><TR><TD CLASS="l">1241</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="16">1242</A></TD><TD>         * @param message error to be displayed.</TD></TR><TR><TD CLASS="l">1243</TD><TD>         */</TD></TR><TR><TD CLASS="l">1244</TD><TD>        public void displayGraphErrMsg(String message) {</TD></TR><TR><TD CLASS="l">1245</TD><TD>                // per ora faccio printare nell'output, assolutamente provvisorio.</TD></TR><TR CLASS="z"><TD CLASS="l">1246</TD><TD>                System.out.println(&#34;message = &#34; + message);</TD></TR><TR CLASS="z"><TD CLASS="l">1247</TD><TD>        }</TD></TR><TR><TD CLASS="l">1248</TD><TD> </TD></TR><TR><TD CLASS="l">1249</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1250</TD><TD>         * Deletes all the vertex &amp; edgees that are selected. it deletes also the</TD></TR><TR><TD CLASS="l">1251</TD><TD>         * edges that are connected to the eliminated vertexes.</TD></TR><TR><TD CLASS="l"><A NAME="15">1252</A></TD><TD> </TD></TR><TR><TD CLASS="l">1253</TD><TD>         * Bertoli Marco 03-06-2005</TD></TR><TR><TD CLASS="l">1254</TD><TD>         */</TD></TR><TR><TD CLASS="l">1255</TD><TD>        public void deleteSelected() {</TD></TR><TR CLASS="z"><TD CLASS="l">1256</TD><TD>                Object cells[] = graph.getSelectionCells();</TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>                GraphModel graphmodel = graph.getModel();</TD></TR><TR><TD CLASS="l">1258</TD><TD> </TD></TR><TR><TD CLASS="l">1259</TD><TD>                // If a cell is a blocking region avoid removing its edges and</TD></TR><TR><TD CLASS="l">1260</TD><TD>                // select its element at the end of the removal process</TD></TR><TR CLASS="z"><TD CLASS="l">1261</TD><TD>                Set edges = new HashSet();</TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>                Set&lt;Object&gt; select = new HashSet&lt;Object&gt;();</TD></TR><TR><TD CLASS="l">1263</TD><TD> </TD></TR><TR><TD CLASS="l">1264</TD><TD>                // Set with all regions that can be deleted as its child were removed</TD></TR><TR CLASS="z"><TD CLASS="l">1265</TD><TD>                Set&lt;Object&gt; regions = new HashSet&lt;Object&gt;();</TD></TR><TR><TD CLASS="l">1266</TD><TD>                // Set with all JmtCells that we are removing</TD></TR><TR CLASS="z"><TD CLASS="l">1267</TD><TD>                Set&lt;Object&gt; jmtCells = new HashSet&lt;Object&gt;();</TD></TR><TR><TD CLASS="l">1268</TD><TD> </TD></TR><TR><TD CLASS="l">1269</TD><TD>                // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">1270</TD><TD>                // for(int k=0; k&lt;cells.length; k++){</TD></TR><TR><TD CLASS="l">1271</TD><TD>                // if(cells[k] instanceof JmtEdge){</TD></TR><TR><TD CLASS="l">1272</TD><TD>                // ((JmtCell)(graphmodel.getParent(graphmodel.getSource((JmtEdge)cells[k])))).SubOut();</TD></TR><TR><TD CLASS="l">1273</TD><TD>                // ((JmtCell)(graphmodel.getParent(graphmodel.getTarget((JmtEdge)cells[k])))).SubIn();</TD></TR><TR><TD CLASS="l">1274</TD><TD>                // }</TD></TR><TR><TD CLASS="l">1275</TD><TD>                //</TD></TR><TR><TD CLASS="l">1276</TD><TD>                // }</TD></TR><TR CLASS="z"><TD CLASS="l">1277</TD><TD>                for (int i = 0; i &lt; cells.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1278</TD><TD>                        if (!(cells[i] instanceof BlockingRegion)) {</TD></TR><TR><TD CLASS="l">1279</TD><TD>                                // Adds edge for removal</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>                                edges.addAll(DefaultGraphModel.getEdges(graphmodel, new Object[] { cells[i] }));</TD></TR><TR><TD CLASS="l">1281</TD><TD>                                // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">1282</TD><TD>                                // quando vado a eliminare un nodo, a cui Ë collegato un arco,</TD></TR><TR><TD CLASS="l">1283</TD><TD>                                // vado ad incrementare o diminuire il contatore per il</TD></TR><TR><TD CLASS="l">1284</TD><TD>                                // pulsanteAGGIUSTATUTTO</TD></TR><TR><TD CLASS="l">1285</TD><TD>                                // Iterator iter = edges.iterator();</TD></TR><TR><TD CLASS="l">1286</TD><TD>                                // while (iter.hasNext()) {</TD></TR><TR><TD CLASS="l">1287</TD><TD>                                // Object next = iter.next();</TD></TR><TR><TD CLASS="l">1288</TD><TD>                                // if (next instanceof JmtEdge){</TD></TR><TR><TD CLASS="l">1289</TD><TD>                                // ((JmtCell)(graphmodel.getParent(graphmodel.getSource((JmtEdge)next)))).SubOut();</TD></TR><TR><TD CLASS="l">1290</TD><TD>                                // ((JmtCell)(graphmodel.getParent(graphmodel.getTarget((JmtEdge)next)))).SubIn();</TD></TR><TR><TD CLASS="l">1291</TD><TD>                                // }</TD></TR><TR><TD CLASS="l">1292</TD><TD>                                //</TD></TR><TR><TD CLASS="l">1293</TD><TD>                                // }</TD></TR><TR><TD CLASS="l">1294</TD><TD>                                // Stores parents information and cell</TD></TR><TR CLASS="z"><TD CLASS="l">1295</TD><TD>                                if (cells[i] instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1296</TD><TD>                                        if (((JmtCell) cells[i]).getParent() instanceof BlockingRegion) {</TD></TR><TR CLASS="z"><TD CLASS="l">1297</TD><TD>                                                regions.add(((JmtCell) cells[i]).getParent());</TD></TR><TR><TD CLASS="l">1298</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1299</TD><TD>                                        jmtCells.add(cells[i]);</TD></TR><TR><TD CLASS="l">1300</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1301</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">1302</TD><TD>                                // Adds node for selection</TD></TR><TR CLASS="z"><TD CLASS="l">1303</TD><TD>                                Object[] nodes = graph.getDescendants(new Object[] { cells[i] });</TD></TR><TR CLASS="z"><TD CLASS="l">1304</TD><TD>                                for (Object node : nodes) {</TD></TR><TR CLASS="z"><TD CLASS="l">1305</TD><TD>                                        if (node instanceof JmtCell || node instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">1306</TD><TD>                                                select.add(node);</TD></TR><TR><TD CLASS="l">1307</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1308</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1309</TD><TD>                                // Removes blocking region from data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1310</TD><TD>                                model.deleteBlockingRegion(((BlockingRegion) cells[i]).getKey());</TD></TR><TR><TD CLASS="l">1311</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1312</TD><TD>                }</TD></TR><TR><TD CLASS="l">1313</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1314</TD><TD>                if (!edges.isEmpty()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1315</TD><TD>                        graphmodel.remove(edges.toArray());</TD></TR><TR><TD CLASS="l">1316</TD><TD>                }</TD></TR><TR><TD CLASS="l">1317</TD><TD>                // removes cells from graph</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>                graphmodel.remove(cells);</TD></TR><TR><TD CLASS="l">1319</TD><TD> </TD></TR><TR><TD CLASS="l">1320</TD><TD>                // Checks if all children of a blocking region have been removed</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>                Iterator&lt;Object&gt; it = regions.iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>                while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1323</TD><TD>                        jmtCells.add(null);</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>                        BlockingRegion region = (BlockingRegion) it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1325</TD><TD>                        List child = region.getChildren();</TD></TR><TR CLASS="z"><TD CLASS="l">1326</TD><TD>                        boolean empty = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1327</TD><TD>                        for (int i = 0; i &lt; child.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1328</TD><TD>                                if (child.get(i) instanceof JmtCell &amp;&amp; !jmtCells.contains(child.get(i))) {</TD></TR><TR CLASS="z"><TD CLASS="l">1329</TD><TD>                                        empty = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1330</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">1331</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1332</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1333</TD><TD>                        if (empty) {</TD></TR><TR CLASS="z"><TD CLASS="l">1334</TD><TD>                                model.deleteBlockingRegion(region.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1335</TD><TD>                                graphmodel.remove(new Object[] { region });</TD></TR><TR><TD CLASS="l">1336</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1337</TD><TD>                }</TD></TR><TR><TD CLASS="l">1338</TD><TD> </TD></TR><TR><TD CLASS="l">1339</TD><TD>                // Removes cells from data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>                for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">1341</TD><TD>                        if (cell instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1342</TD><TD>                                model.deleteStation(((CellComponent) ((JmtCell) cell).getUserObject()).getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>                        } else if (cell instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">1344</TD><TD>                                JmtEdge link = (JmtEdge) cell;</TD></TR><TR CLASS="z"><TD CLASS="l">1345</TD><TD>                                model.setConnected(link.getSourceKey(), link.getTargetKey(), false);</TD></TR><TR><TD CLASS="l">1346</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1347</TD><TD>                }</TD></TR><TR><TD CLASS="l">1348</TD><TD> </TD></TR><TR><TD CLASS="l">1349</TD><TD>                // If no stations remains gray select and link buttons</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>                if (graph.getModel().getRootCount() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1351</TD><TD>                        componentBar.clearButtonGroupSelection(0);</TD></TR><TR CLASS="z"><TD CLASS="l">1352</TD><TD>                        setConnect.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">1353</TD><TD>                        setSelect.setEnabled(false);</TD></TR><TR><TD CLASS="l">1354</TD><TD>                }</TD></TR><TR><TD CLASS="l">1355</TD><TD> </TD></TR><TR><TD CLASS="l">1356</TD><TD>                // Selects components from removed blocking regions</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>                if (select.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1358</TD><TD>                        graph.setSelectionCells(select.toArray());</TD></TR><TR><TD CLASS="l">1359</TD><TD>                        // Resets parent information of cells that changed parent</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>                        it = select.iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1361</TD><TD>                        while (it.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>                                Object next = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1363</TD><TD>                                if (next instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1364</TD><TD>                                        ((JmtCell) next).resetParent();</TD></TR><TR><TD CLASS="l">1365</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1366</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1367</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1368</TD><TD>        }</TD></TR><TR><TD CLASS="l">1369</TD><TD> </TD></TR><TR><TD CLASS="l">1370</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1371</TD><TD>         * Shows the panel that opens when the rigth button is clicked.</TD></TR><TR><TD CLASS="l">1372</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="94">1373</A></TD><TD>         * @param p point where the right button is cliecked on the graph</TD></TR><TR><TD CLASS="l">1374</TD><TD>         */</TD></TR><TR><TD CLASS="l">1375</TD><TD>        public void showOPanel(Point p) {</TD></TR><TR><TD CLASS="l">1376</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1377</TD><TD>        }</TD></TR><TR><TD CLASS="l">1378</TD><TD> </TD></TR><TR><TD CLASS="l">1379</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="7e">1380</A></TD><TD>         * Saves the current model into current file if exists, otherwise calls saveModelAs()</TD></TR><TR><TD CLASS="l">1381</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1382</TD><TD>         */</TD></TR><TR><TD CLASS="l">1383</TD><TD>        public void saveModel() {</TD></TR><TR CLASS="z"><TD CLASS="l">1384</TD><TD>                if (openedArchive == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1385</TD><TD>                        saveModelAs();</TD></TR><TR CLASS="z"><TD CLASS="l">1386</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1387</TD><TD>                }</TD></TR><TR><TD CLASS="l">1388</TD><TD> </TD></TR><TR><TD CLASS="l">1389</TD><TD>                // Updates station positions into data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1390</TD><TD>                updateStationPositions();</TD></TR><TR CLASS="z"><TD CLASS="l">1391</TD><TD>                int status = modelLoader.saveModel(model, mainWindow, openedArchive);</TD></TR><TR CLASS="z"><TD CLASS="l">1392</TD><TD>                switch (status) {</TD></TR><TR><TD CLASS="l">1393</TD><TD>                        case ModelLoader.SUCCESS:</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>                                model.resetSaveState();</TD></TR><TR CLASS="z"><TD CLASS="l">1395</TD><TD>                                mainWindow.updateTitle(openedArchive.getName());</TD></TR><TR CLASS="z"><TD CLASS="l">1396</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1397</TD><TD>                        case ModelLoader.FAILURE:</TD></TR><TR CLASS="z"><TD CLASS="l">1398</TD><TD>                                showErrorMessage(modelLoader.getFailureMotivation());</TD></TR><TR><TD CLASS="l">1399</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1400</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1401</TD><TD>        }</TD></TR><TR><TD CLASS="l">1402</TD><TD> </TD></TR><TR><TD CLASS="l">1403</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1404</TD><TD>         * Saves the current model into a user specified file.</TD></TR><TR><TD CLASS="l"><A NAME="7f">1405</A></TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1406</TD><TD>         */</TD></TR><TR><TD CLASS="l">1407</TD><TD>        public void saveModelAs() {</TD></TR><TR><TD CLASS="l">1408</TD><TD>                // Updates station positions into data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1409</TD><TD>                updateStationPositions();</TD></TR><TR CLASS="z"><TD CLASS="l">1410</TD><TD>                int status = modelLoader.saveModel(model, mainWindow, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1411</TD><TD>                switch (status) {</TD></TR><TR><TD CLASS="l">1412</TD><TD>                        case ModelLoader.SUCCESS:</TD></TR><TR CLASS="z"><TD CLASS="l">1413</TD><TD>                                model.resetSaveState();</TD></TR><TR CLASS="z"><TD CLASS="l">1414</TD><TD>                                openedArchive = modelLoader.getSelectedFile();</TD></TR><TR CLASS="z"><TD CLASS="l">1415</TD><TD>                                mainWindow.updateTitle(openedArchive.getName());</TD></TR><TR CLASS="z"><TD CLASS="l">1416</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1417</TD><TD>                        case ModelLoader.FAILURE:</TD></TR><TR CLASS="z"><TD CLASS="l">1418</TD><TD>                                showErrorMessage(modelLoader.getFailureMotivation());</TD></TR><TR><TD CLASS="l">1419</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1420</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1421</TD><TD>        }</TD></TR><TR><TD CLASS="l">1422</TD><TD> </TD></TR><TR><TD CLASS="l">1423</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1424</TD><TD>         * Updates station positions into data structure to reflect the one shown on jgraph</TD></TR><TR><TD CLASS="l">1425</TD><TD>         * window. This method is called before saving model.</TD></TR><TR><TD CLASS="l"><A NAME="a0">1426</A></TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1427</TD><TD>         */</TD></TR><TR><TD CLASS="l">1428</TD><TD>        public void updateStationPositions() {</TD></TR><TR><TD CLASS="l">1429</TD><TD>                Object key;</TD></TR><TR CLASS="z"><TD CLASS="l">1430</TD><TD>                Object[] cells = graph.getDescendants(graph.getRoots());</TD></TR><TR CLASS="z"><TD CLASS="l">1431</TD><TD>                for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">1432</TD><TD>                        if (cell instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">1433</TD><TD>                                JmtCell jcell = (JmtCell) cell;</TD></TR><TR CLASS="z"><TD CLASS="l">1434</TD><TD>                                key = ((CellComponent) jcell.getUserObject()).getKey();</TD></TR><TR><TD CLASS="l">1435</TD><TD>                                // Sets cell coordinate into data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>                                model.setStationPosition(key, new JMTPoint(getCellCoordinates(jcell), !jcell.isLeftInputCell()));</TD></TR><TR><TD CLASS="l">1437</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1438</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>        }</TD></TR><TR><TD CLASS="l">1440</TD><TD> </TD></TR><TR><TD CLASS="l">1441</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1442</TD><TD>         * Uses information retrived from data structure to recreate graph structure.</TD></TR><TR><TD CLASS="l"><A NAME="77">1443</A></TD><TD>         * This method has to be called after loading a model.</TD></TR><TR><TD CLASS="l">1444</TD><TD>         * &lt;br&gt;Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1445</TD><TD>         */</TD></TR><TR><TD CLASS="l">1446</TD><TD>        public void populateGraph() {</TD></TR><TR CLASS="z"><TD CLASS="l">1447</TD><TD>                Object[] stations = model.getStationKeys().toArray();</TD></TR><TR CLASS="z"><TD CLASS="l">1448</TD><TD>                HashMap&lt;Object, JmtCell&gt; cells = new HashMap&lt;Object, JmtCell&gt;();</TD></TR><TR><TD CLASS="l">1449</TD><TD>                JmtCell cell;</TD></TR><TR><TD CLASS="l">1450</TD><TD> </TD></TR><TR><TD CLASS="l">1451</TD><TD>                // Variables for auto-placement. Currently items are placed on a grid...</TD></TR><TR><TD CLASS="l">1452</TD><TD>                // Need to be improved!!!</TD></TR><TR CLASS="z"><TD CLASS="l">1453</TD><TD>                int count = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1454</TD><TD>                int X = 150; // distance on the X axis</TD></TR><TR CLASS="z"><TD CLASS="l">1455</TD><TD>                int Y = 50; // distance on the Y axis</TD></TR><TR CLASS="z"><TD CLASS="l">1456</TD><TD>                int X0 = 50;</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>                int Y0 = 15;</TD></TR><TR CLASS="z"><TD CLASS="l">1458</TD><TD>                int colCount = (graph.getHeight() - 2 * Y0) / Y;</TD></TR><TR CLASS="z"><TD CLASS="l">1459</TD><TD>                boolean containPosition = true;</TD></TR><TR><TD CLASS="l">1460</TD><TD>                // Shows stations</TD></TR><TR CLASS="z"><TD CLASS="l">1461</TD><TD>                for (Object station : stations) {</TD></TR><TR CLASS="z"><TD CLASS="l">1462</TD><TD>                        cell = cellFactory.createStationCell(station);</TD></TR><TR CLASS="z"><TD CLASS="l">1463</TD><TD>                        JMTPoint position = model.getStationPosition(station);</TD></TR><TR><TD CLASS="l">1464</TD><TD>                        // If position is not present, auto-position this station</TD></TR><TR><TD CLASS="l">1465</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1466</TD><TD>                        while (position == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1467</TD><TD>                                containPosition = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1468</TD><TD>                                JMTPoint tmp = new JMTPoint(X0 + X * (count / colCount), Y0 + Y * (count % colCount), false);</TD></TR><TR CLASS="z"><TD CLASS="l">1469</TD><TD>                                if (!overlapCells(tmp, cell)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1470</TD><TD>                                        position = tmp;</TD></TR><TR><TD CLASS="l">1471</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1472</TD><TD>                                count++;</TD></TR><TR CLASS="z"><TD CLASS="l">1473</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1474</TD><TD>                        InsertCell(position, cell);</TD></TR><TR CLASS="z"><TD CLASS="l">1475</TD><TD>                        if (position.isRotate()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1476</TD><TD>                                rotateComponent(new Object[] { cell });</TD></TR><TR><TD CLASS="l">1477</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1478</TD><TD>                        cells.put(station, cell);</TD></TR><TR><TD CLASS="l">1479</TD><TD>                }</TD></TR><TR><TD CLASS="l">1480</TD><TD>                Vector forwardConnections;</TD></TR><TR><TD CLASS="l">1481</TD><TD>                // Shows connections</TD></TR><TR CLASS="z"><TD CLASS="l">1482</TD><TD>                for (Object station : stations) {</TD></TR><TR CLASS="z"><TD CLASS="l">1483</TD><TD>                        forwardConnections = model.getForwardConnections(station);</TD></TR><TR CLASS="z"><TD CLASS="l">1484</TD><TD>                        for (int j = 0; j &lt; forwardConnections.size(); j++) {</TD></TR><TR><TD CLASS="l">1485</TD><TD>                                // Forces connection as it's already present into data structure</TD></TR><TR CLASS="z"><TD CLASS="l">1486</TD><TD>                                connect(cells.get(station), cells.get(forwardConnections.get(j)), true);</TD></TR><TR><TD CLASS="l">1487</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1488</TD><TD> </TD></TR><TR><TD CLASS="l">1489</TD><TD>                }</TD></TR><TR><TD CLASS="l">1490</TD><TD>                // Now adds blocking regions</TD></TR><TR CLASS="z"><TD CLASS="l">1491</TD><TD>                Vector regions = model.getRegionKeys();</TD></TR><TR CLASS="z"><TD CLASS="l">1492</TD><TD>                for (int i = 0; i &lt; regions.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1493</TD><TD>                        Object key = regions.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">1494</TD><TD>                        Set&lt;JmtCell&gt; regionStation = new HashSet&lt;JmtCell&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1495</TD><TD>                        Iterator stationKeys = model.getBlockingRegionStations(key).iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1496</TD><TD>                        while (stationKeys.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1497</TD><TD>                                regionStation.add(cells.get(stationKeys.next()));</TD></TR><TR><TD CLASS="l">1498</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1499</TD><TD>                        // Adds cells to blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">1500</TD><TD>                        addCellsToBlockingRegion(regionStation.toArray(), key);</TD></TR><TR><TD CLASS="l">1501</TD><TD>                }</TD></TR><TR><TD CLASS="l">1502</TD><TD> </TD></TR><TR><TD CLASS="l">1503</TD><TD>                // graph.repaint();</TD></TR><TR><TD CLASS="l">1504</TD><TD> </TD></TR><TR><TD CLASS="l">1505</TD><TD>                // whether the Position is Null, the application call the reposition's</TD></TR><TR><TD CLASS="l">1506</TD><TD>                // method</TD></TR><TR CLASS="z"><TD CLASS="l">1507</TD><TD>                if (!containPosition) {</TD></TR><TR CLASS="z"><TD CLASS="l">1508</TD><TD>                        adjustGraph();</TD></TR><TR><TD CLASS="l">1509</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1510</TD><TD>                graphRepaint();</TD></TR><TR CLASS="z"><TD CLASS="l">1511</TD><TD>                graph.getGraphLayoutCache().reload();</TD></TR><TR><TD CLASS="l">1512</TD><TD>                // graph.repaint();</TD></TR><TR CLASS="z"><TD CLASS="l">1513</TD><TD>        }</TD></TR><TR><TD CLASS="l">1514</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3c">1515</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1516</TD><TD>         * @return the system &lt;code&gt;JGraph&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1517</TD><TD>         */</TD></TR><TR><TD CLASS="l">1518</TD><TD>        public JGraph getGraph() {</TD></TR><TR CLASS="z"><TD CLASS="l">1519</TD><TD>                return graph;</TD></TR><TR><TD CLASS="l">1520</TD><TD>        }</TD></TR><TR><TD CLASS="l">1521</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="1a">1522</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1523</TD><TD>         * Launches the &lt;code&gt;UserClass&lt;/code&gt; editor.</TD></TR><TR><TD CLASS="l">1524</TD><TD>         */</TD></TR><TR><TD CLASS="l">1525</TD><TD>        public void editUserClasses() {</TD></TR><TR CLASS="z"><TD CLASS="l">1526</TD><TD>                dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Define customer classes&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1527</TD><TD>        }</TD></TR><TR><TD CLASS="l">1528</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="1f">1529</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1530</TD><TD>         * Enables or not the &lt;code&gt;UserClass&lt;/code&gt; editor function.</TD></TR><TR><TD CLASS="l">1531</TD><TD>         */</TD></TR><TR><TD CLASS="l">1532</TD><TD>        public void enableEditUserClasses(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l">1533</TD><TD>                editUserClasses.setEnabled(state);</TD></TR><TR CLASS="z"><TD CLASS="l">1534</TD><TD>        }</TD></TR><TR><TD CLASS="l">1535</TD><TD> </TD></TR><TR><TD CLASS="l">1536</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1537</TD><TD>         * Searches the cell with the given &lt;i&gt;name&lt;/i&gt;.</TD></TR><TR><TD CLASS="l"><A NAME="25">1538</A></TD><TD>         * @param name A given cell name.</TD></TR><TR><TD CLASS="l">1539</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; - if the searched cell will be found.</TD></TR><TR><TD CLASS="l">1540</TD><TD>         */</TD></TR><TR><TD CLASS="l">1541</TD><TD>        public boolean existCell(String name) {</TD></TR><TR CLASS="z"><TD CLASS="l">1542</TD><TD>                int nCells = graph.getModel().getRootCount();</TD></TR><TR CLASS="z"><TD CLASS="l">1543</TD><TD>                for (int i = 0; i &lt; nCells; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1544</TD><TD>                        Object cell = graph.getModel().getRootAt(i);</TD></TR><TR CLASS="z"><TD CLASS="l">1545</TD><TD>                        if (cell instanceof JmtCell) {</TD></TR><TR><TD CLASS="l">1546</TD><TD>                                // Map attributes = ((JmtCell) cell).getAttributes();</TD></TR><TR><TD CLASS="l">1547</TD><TD>                                // String cellName = (String) attributes.get(&#34;NAME&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1548</TD><TD>                                String cellName = ((JmtCell) cell).getUserObject().toString();</TD></TR><TR CLASS="z"><TD CLASS="l">1549</TD><TD>                                if (cellName.equals(name)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1550</TD><TD>                                        return true;</TD></TR><TR><TD CLASS="l">1551</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1552</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1553</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1554</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">1555</TD><TD>        }</TD></TR><TR><TD CLASS="l">1556</TD><TD> </TD></TR><TR><TD CLASS="l">1557</TD><TD>        // /**</TD></TR><TR><TD CLASS="l">1558</TD><TD>        // * This function will put selected cells in place avoiding overlapping</TD></TR><TR><TD CLASS="l">1559</TD><TD>        // with other cells</TD></TR><TR><TD CLASS="l">1560</TD><TD>        // * in graph window</TD></TR><TR><TD CLASS="l">1561</TD><TD>        // * &lt;br&gt;</TD></TR><TR><TD CLASS="l">1562</TD><TD>        // * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1563</TD><TD>        // */</TD></TR><TR><TD CLASS="l">1564</TD><TD>        // // VECCHIO ALGORITMO</TD></TR><TR><TD CLASS="l">1565</TD><TD>        // public void putSelectedCellsInGoodPlace() {</TD></TR><TR><TD CLASS="l">1566</TD><TD>        // Object[] cells = graph.getDescendants(graph.getSelectionCells());</TD></TR><TR><TD CLASS="l">1567</TD><TD>        // for (int i=0; i&lt;cells.length;i++)</TD></TR><TR><TD CLASS="l">1568</TD><TD>        // if(cells[i] instanceof JmtCell)</TD></TR><TR><TD CLASS="l">1569</TD><TD>        // putCellInGoodPlace((JmtCell) cells[i]);</TD></TR><TR><TD CLASS="l">1570</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1571</TD><TD> </TD></TR><TR><TD CLASS="l">1572</TD><TD>        // /**</TD></TR><TR><TD CLASS="l">1573</TD><TD>        // * This function will put given cell in place avoiding overlapping with</TD></TR><TR><TD CLASS="l">1574</TD><TD>        // other cells</TD></TR><TR><TD CLASS="l">1575</TD><TD>        // * in graph window</TD></TR><TR><TD CLASS="l">1576</TD><TD>        // * &lt;br&gt;</TD></TR><TR><TD CLASS="l">1577</TD><TD>        // * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1578</TD><TD>        // * @param cell Identifier of the cell to be moved</TD></TR><TR><TD CLASS="l">1579</TD><TD>        // */</TD></TR><TR><TD CLASS="l">1580</TD><TD>        // // VECCHIO ALGORITMO</TD></TR><TR><TD CLASS="l">1581</TD><TD>        // public void putCellInGoodPlace(JmtCell cell) {</TD></TR><TR><TD CLASS="l">1582</TD><TD>        // Rectangle bounds =</TD></TR><TR><TD CLASS="l">1583</TD><TD>        // GraphConstants.getBounds(cell.getAttributes()).getBounds();</TD></TR><TR><TD CLASS="l">1584</TD><TD>        // // Avoids negative starting point</TD></TR><TR><TD CLASS="l">1585</TD><TD>        // if (bounds.getX() &lt; 0)</TD></TR><TR><TD CLASS="l">1586</TD><TD>        // bounds.setLocation(0, (int)bounds.getY());</TD></TR><TR><TD CLASS="l">1587</TD><TD>        // if (bounds.getY() &lt; 0)</TD></TR><TR><TD CLASS="l">1588</TD><TD>        // bounds.setLocation((int)bounds.getX(), 0);</TD></TR><TR><TD CLASS="l">1589</TD><TD>        //</TD></TR><TR><TD CLASS="l">1590</TD><TD>        // Object[] overlapping = graph.getDescendants(graph.getRoots(bounds));</TD></TR><TR><TD CLASS="l">1591</TD><TD>        // Point2D zero = new Point(0,0);</TD></TR><TR><TD CLASS="l">1592</TD><TD>        // while (overlapping.length &gt; 0) {</TD></TR><TR><TD CLASS="l">1593</TD><TD>        // // Moves bounds until it doesn't overlap with anything</TD></TR><TR><TD CLASS="l">1594</TD><TD>        // Point2D last = (Point2D) zero.clone();</TD></TR><TR><TD CLASS="l">1595</TD><TD>        // for (int j=0; j&lt;overlapping.length; j++) {</TD></TR><TR><TD CLASS="l">1596</TD><TD>        // // Puts last to last corner of overlapping cells</TD></TR><TR><TD CLASS="l">1597</TD><TD>        // if (overlapping[j] instanceof JmtCell &amp;&amp; overlapping[j] != cell) {</TD></TR><TR><TD CLASS="l">1598</TD><TD>        // Rectangle2D b =</TD></TR><TR><TD CLASS="l">1599</TD><TD>        // GraphConstants.getBounds(((JmtCell)overlapping[j]).getAttributes());</TD></TR><TR><TD CLASS="l">1600</TD><TD>        // // Consider only rectangles that intersects with given bound</TD></TR><TR><TD CLASS="l">1601</TD><TD>        // if (b.intersects(bounds)) {</TD></TR><TR><TD CLASS="l">1602</TD><TD>        // if (b.getMaxX() &gt; last.getX())</TD></TR><TR><TD CLASS="l">1603</TD><TD>        // last.setLocation(b.getMaxX(), last.getY());</TD></TR><TR><TD CLASS="l">1604</TD><TD>        // if (b.getMaxY() &gt; last.getY())</TD></TR><TR><TD CLASS="l">1605</TD><TD>        // last.setLocation(last.getX(), b.getMaxY());</TD></TR><TR><TD CLASS="l">1606</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1607</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1608</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1609</TD><TD>        // // if last is still zero, only Blocking section were found overlapping</TD></TR><TR><TD CLASS="l">1610</TD><TD>        // // so leave everyting as before</TD></TR><TR><TD CLASS="l">1611</TD><TD>        // if (last.equals(zero))</TD></TR><TR><TD CLASS="l">1612</TD><TD>        // break;</TD></TR><TR><TD CLASS="l">1613</TD><TD>        // // Rounds last and moves bounds to found point</TD></TR><TR><TD CLASS="l">1614</TD><TD>        // bounds.setLocation(new</TD></TR><TR><TD CLASS="l">1615</TD><TD>        // Point((int)(last.getX()+.5),(int)(last.getY()+.5)));</TD></TR><TR><TD CLASS="l">1616</TD><TD>        // overlapping = graph.getDescendants(graph.getRoots(bounds));</TD></TR><TR><TD CLASS="l">1617</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1618</TD><TD>        //</TD></TR><TR><TD CLASS="l">1619</TD><TD>        // // Puts this cell in found position</TD></TR><TR><TD CLASS="l">1620</TD><TD>        // GraphConstants.setBounds(cell.getAttributes(), bounds);</TD></TR><TR><TD CLASS="l">1621</TD><TD>        // }</TD></TR><TR><TD CLASS="l">1622</TD><TD> </TD></TR><TR><TD CLASS="l">1623</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1624</TD><TD>         * This function will put selected cells in place avoiding overlapping with other cells</TD></TR><TR><TD CLASS="l">1625</TD><TD>         * in graph window</TD></TR><TR><TD CLASS="l">1626</TD><TD>         * &lt;br&gt;</TD></TR><TR><TD CLASS="l">1627</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1628</TD><TD>         * Heavely modified by Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l"><A NAME="79">1629</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">1630</TD><TD>         */</TD></TR><TR><TD CLASS="l">1631</TD><TD>        public void putSelectedCellsInGoodPlace(Object[] cells, Integer[] X, Integer[] Y) {</TD></TR><TR><TD CLASS="l">1632</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1633</TD><TD>                for (int i = 0; i &lt; cells.length; i++) {</TD></TR><TR><TD CLASS="l">1634</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1635</TD><TD>                        if (cells[i] instanceof JmtCell) {</TD></TR><TR><TD CLASS="l">1636</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1637</TD><TD>                                putCellInGoodPlace((JmtCell) cells[i], X[i].intValue(), Y[i].intValue(), true);</TD></TR><TR><TD CLASS="l">1638</TD><TD> </TD></TR><TR><TD CLASS="l">1639</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1640</TD><TD>                        if (cells[i] instanceof BlockingRegion) {</TD></TR><TR CLASS="z"><TD CLASS="l">1641</TD><TD>                                Object[] tmp = new Object[1];</TD></TR><TR CLASS="z"><TD CLASS="l">1642</TD><TD>                                tmp[0] = cells[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1643</TD><TD>                                Object[] children = graph.getDescendants(tmp);</TD></TR><TR CLASS="z"><TD CLASS="l">1644</TD><TD>                                for (Object element : children) {</TD></TR><TR CLASS="z"><TD CLASS="l">1645</TD><TD>                                        if (element instanceof JmtCell) {</TD></TR><TR><TD CLASS="l">1646</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1647</TD><TD>                                                putCellInGoodPlace((JmtCell) element, -1, -1, false);</TD></TR><TR><TD CLASS="l">1648</TD><TD> </TD></TR><TR><TD CLASS="l">1649</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1650</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1651</TD><TD> </TD></TR><TR><TD CLASS="l">1652</TD><TD>                                // putBlockingRegionInGoodPlace((BlockingRegion) cells[i]);</TD></TR><TR><TD CLASS="l">1653</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1654</TD><TD> </TD></TR><TR><TD CLASS="l">1655</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1656</TD><TD>                graph.getGraphLayoutCache().reload();</TD></TR><TR CLASS="z"><TD CLASS="l">1657</TD><TD>                sp = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>        }</TD></TR><TR><TD CLASS="l">1659</TD><TD> </TD></TR><TR><TD CLASS="l">1660</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1661</TD><TD>         * This function will put given cell in place avoiding overlapping with other cells</TD></TR><TR><TD CLASS="l">1662</TD><TD>         * in graph window</TD></TR><TR><TD CLASS="l">1663</TD><TD>         * &lt;br&gt;</TD></TR><TR><TD CLASS="l">1664</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">1665</TD><TD>         * Heavely modified by Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">1666</TD><TD>         * @param cell Identifier of the cell to be moved</TD></TR><TR><TD CLASS="l">1667</TD><TD>         */</TD></TR><TR><TD CLASS="l">1668</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1669</TD><TD>        int resetOverLapping = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1670</TD><TD>        int sp = 0;</TD></TR><TR><TD CLASS="l">1671</TD><TD> </TD></TR><TR><TD CLASS="l">1672</TD><TD>        public void putCellInGoodPlace(JmtCell cell, int x, int y, boolean flag) {</TD></TR><TR><TD CLASS="l">1673</TD><TD>                // questo metodo viene chiamato solamente quando la classe viene</TD></TR><TR><TD CLASS="l">1674</TD><TD>                // selezionata</TD></TR><TR><TD CLASS="l"><A NAME="78">1675</A></TD><TD>                // e si ripete per il numero di classi selezionate, non risulta quindi</TD></TR><TR><TD CLASS="l">1676</TD><TD>                // essere</TD></TR><TR><TD CLASS="l">1677</TD><TD>                // pesante.</TD></TR><TR><TD CLASS="l">1678</TD><TD>                // System.out.println(&#34;Valore di Sp &#34;+sp);</TD></TR><TR CLASS="z"><TD CLASS="l">1679</TD><TD>                if (sp &gt; 9) {</TD></TR><TR CLASS="z"><TD CLASS="l">1680</TD><TD>                        sp = 0;</TD></TR><TR><TD CLASS="l">1681</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1682</TD><TD>                int oldPointX = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1683</TD><TD>                int oldPointY = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1684</TD><TD>                boolean inGroup = false;</TD></TR><TR><TD CLASS="l">1685</TD><TD>                // Il flag Ë stato creato per capire sapere se e' una block regione e</TD></TR><TR><TD CLASS="l">1686</TD><TD>                // quindi utilizzare</TD></TR><TR><TD CLASS="l">1687</TD><TD>                // il vecchio metodo oppure se e' una cella quindi flag=true allora uso</TD></TR><TR><TD CLASS="l">1688</TD><TD>                // il nuovo</TD></TR><TR><TD CLASS="l">1689</TD><TD>                // System.out.println(&#34;------------PUT CELL IN GOOD PLACE</TD></TR><TR><TD CLASS="l">1690</TD><TD>                // ----------------------&#34;);</TD></TR><TR><TD CLASS="l">1691</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1692</TD><TD>                if (flag) {</TD></TR><TR CLASS="z"><TD CLASS="l">1693</TD><TD>                        Rectangle bounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">1694</TD><TD>                        Rectangle bounds2 = new Rectangle((int) bounds.getX() - 20, (int) bounds.getY(), (int) bounds.getWidth() + 38, (int) bounds.getHeight());</TD></TR><TR><TD CLASS="l">1695</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1696</TD><TD>                        oldPointX = x;</TD></TR><TR CLASS="z"><TD CLASS="l">1697</TD><TD>                        oldPointY = y;</TD></TR><TR><TD CLASS="l">1698</TD><TD>                        // ---------inzio</TD></TR><TR><TD CLASS="l">1699</TD><TD>                        // Object[] cells=(graph).getDescendants(graph.getRoots());</TD></TR><TR><TD CLASS="l">1700</TD><TD>                        // for(int j=0;j&lt;cells.length;j++){</TD></TR><TR><TD CLASS="l">1701</TD><TD>                        // if((cells[j] instanceof JmtCell) &amp;&amp;(cells[j]!=cell)){</TD></TR><TR><TD CLASS="l">1702</TD><TD>                        // Rectangle</TD></TR><TR><TD CLASS="l">1703</TD><TD>                        // boundcell=GraphConstants.getBounds(((JmtCell)cells[j]).getAttributes()).getBounds();</TD></TR><TR><TD CLASS="l">1704</TD><TD>                        // if(boundcell.intersects(bounds2)){</TD></TR><TR><TD CLASS="l">1705</TD><TD>                        // System.out.println(&#34;true&#34;);</TD></TR><TR><TD CLASS="l">1706</TD><TD>                        // }</TD></TR><TR><TD CLASS="l">1707</TD><TD>                        // }</TD></TR><TR><TD CLASS="l">1708</TD><TD>                        // }</TD></TR><TR><TD CLASS="l">1709</TD><TD> </TD></TR><TR><TD CLASS="l">1710</TD><TD>                        // ---------------fine</TD></TR><TR><TD CLASS="l">1711</TD><TD>                        // check if a cell isInGroup</TD></TR><TR CLASS="z"><TD CLASS="l">1712</TD><TD>                        if (isInGroup(cell)) {</TD></TR><TR><TD CLASS="l">1713</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>                                inGroup = true;</TD></TR><TR><TD CLASS="l">1715</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1716</TD><TD> </TD></TR><TR><TD CLASS="l">1717</TD><TD>                        // Avoids negative starting point</TD></TR><TR CLASS="z"><TD CLASS="l">1718</TD><TD>                        if (bounds.getX() &lt; 20) {</TD></TR><TR CLASS="z"><TD CLASS="l">1719</TD><TD>                                bounds.setLocation(20, (int) bounds.getY());</TD></TR><TR><TD CLASS="l">1720</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>                        if (bounds.getY() &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1722</TD><TD>                                bounds.setLocation((int) bounds.getX(), 0);</TD></TR><TR><TD CLASS="l">1723</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1724</TD><TD> </TD></TR><TR><TD CLASS="l">1725</TD><TD>                        // Qua ho le celle e archi che intersecano la mia cella</TD></TR><TR><TD CLASS="l">1726</TD><TD>                        // selezionata..bounds (molto efficente dal punto di vista della</TD></TR><TR><TD CLASS="l">1727</TD><TD>                        // pesantezza)</TD></TR><TR CLASS="z"><TD CLASS="l">1728</TD><TD>                        Object[] overlapping = graph.getDescendants(graph.getRoots(bounds2));</TD></TR><TR><TD CLASS="l">1729</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1730</TD><TD>                        Point2D zero = new Point(20, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">1731</TD><TD>                        resetOverLapping = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1732</TD><TD>                        while (overlapping.length &gt; 0) {</TD></TR><TR><TD CLASS="l">1733</TD><TD> </TD></TR><TR><TD CLASS="l">1734</TD><TD>                                // Moves bounds until it doesn't overlap with anything</TD></TR><TR CLASS="z"><TD CLASS="l">1735</TD><TD>                                Point2D last = (Point2D) zero.clone();</TD></TR><TR CLASS="z"><TD CLASS="l">1736</TD><TD>                                for (int j = 0; j &lt; overlapping.length; j++) {</TD></TR><TR><TD CLASS="l">1737</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1738</TD><TD>                                        resetOverLapping++;</TD></TR><TR><TD CLASS="l">1739</TD><TD>                                        // resetOverLapping is inserted for an anormall behavior of</TD></TR><TR><TD CLASS="l">1740</TD><TD>                                        // Tool</TD></TR><TR><TD CLASS="l">1741</TD><TD>                                        // in fact, if you disable this variable you can see that</TD></TR><TR><TD CLASS="l">1742</TD><TD>                                        // the tools</TD></TR><TR><TD CLASS="l">1743</TD><TD>                                        // stop and &#34;for cycle&#34; will be repeated infinite times</TD></TR><TR CLASS="z"><TD CLASS="l">1744</TD><TD>                                        if (resetOverLapping &gt; 50) {</TD></TR><TR CLASS="z"><TD CLASS="l">1745</TD><TD>                                                bounds.setLocation(new Point(oldPointX, oldPointY));</TD></TR><TR CLASS="z"><TD CLASS="l">1746</TD><TD>                                                GraphConstants.setBounds(cell.getAttributes(), bounds);</TD></TR><TR CLASS="z"><TD CLASS="l">1747</TD><TD>                                                resetOverLapping = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1748</TD><TD>                                                return;</TD></TR><TR><TD CLASS="l">1749</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1750</TD><TD>                                        // System.out.println(&#34;---flag in for---&#34;);</TD></TR><TR><TD CLASS="l">1751</TD><TD>                                        // if(overlapping[j] instanceof JmtEdge</TD></TR><TR><TD CLASS="l">1752</TD><TD>                                        // &amp;&amp;((JmtEdge)overlapping[j]).intersects((EdgeView)(graph.getGraphLayoutCache()).getMapping(overlapping[j],</TD></TR><TR><TD CLASS="l">1753</TD><TD>                                        // false),</TD></TR><TR><TD CLASS="l">1754</TD><TD>                                        // GraphConstants.getBounds(((JmtCell)cell).getAttributes())))</TD></TR><TR><TD CLASS="l">1755</TD><TD>                                        // System.out.println(&#34;Intersect Ë TRUE&#34;);</TD></TR><TR><TD CLASS="l">1756</TD><TD> </TD></TR><TR><TD CLASS="l">1757</TD><TD>                                        // Puts last to last corner of overlapping cells</TD></TR><TR CLASS="z"><TD CLASS="l">1758</TD><TD>                                        if (overlapping[j] instanceof JmtCell &amp;&amp; overlapping[j] != cell &amp;&amp; inGroup) {</TD></TR><TR CLASS="z"><TD CLASS="l">1759</TD><TD>                                                Rectangle2D b2 = GraphConstants.getBounds(((JmtCell) overlapping[j]).getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">1760</TD><TD>                                                if (b2.intersects(bounds)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1761</TD><TD>                                                        if (b2.getMaxX() &gt; last.getX()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1762</TD><TD>                                                                last.setLocation(b2.getMaxX(), last.getY());</TD></TR><TR><TD CLASS="l">1763</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1764</TD><TD>                                                        if (b2.getMaxY() &gt; last.getY()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1765</TD><TD>                                                                last.setLocation(last.getX(), b2.getMaxY());</TD></TR><TR><TD CLASS="l">1766</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1767</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1768</TD><TD>                                                last.setLocation(new Point((int) (last.getX() + .5), (int) (last.getY() + .5)));</TD></TR><TR><TD CLASS="l">1769</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1770</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1771</TD><TD>                                        int numberOfChild = cell.getChildCount();</TD></TR><TR><TD CLASS="l">1772</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1773</TD><TD>                                        if (!inGroup &amp;&amp; overlapping[j] instanceof JmtCell &amp;&amp; overlapping[j] != cell) {</TD></TR><TR><TD CLASS="l">1774</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1775</TD><TD>                                                Rectangle2D b = GraphConstants.getBounds(((JmtCell) overlapping[j]).getAttributes());</TD></TR><TR><TD CLASS="l">1776</TD><TD>                                                // Consider only rectangles that intersects with given</TD></TR><TR><TD CLASS="l">1777</TD><TD>                                                // bound</TD></TR><TR CLASS="z"><TD CLASS="l">1778</TD><TD>                                                if (b.intersects(bounds2)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1779</TD><TD>                                                        last.setLocation(new Point(oldPointX, oldPointY));</TD></TR><TR><TD CLASS="l">1780</TD><TD> </TD></TR><TR><TD CLASS="l">1781</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1782</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1783</TD><TD>                                        // inizio a controllare se l intersezione e' un lato</TD></TR><TR CLASS="z"><TD CLASS="l">1784</TD><TD>                                        if (overlapping[j] instanceof JmtEdge</TD></TR><TR><TD CLASS="l">1785</TD><TD>                                                        &amp;&amp; overlapping[j] != cell</TD></TR><TR><TD CLASS="l">1786</TD><TD>                                                        &amp;&amp; !isInGroup(overlapping[j])</TD></TR><TR><TD CLASS="l">1787</TD><TD>                                                        &amp;&amp; ((JmtEdge) overlapping[j]).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(overlapping[j], false),</TD></TR><TR><TD CLASS="l">1788</TD><TD>                                                                        GraphConstants.getBounds(cell.getAttributes())) &amp;&amp; ((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1789</TD><TD>                                                boolean access = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1790</TD><TD>                                                boolean access2 = false;</TD></TR><TR><TD CLASS="l">1791</TD><TD> </TD></TR><TR><TD CLASS="l">1792</TD><TD>                                                // Nonostatne SourceCell e SinkCell estendano JMTCell</TD></TR><TR><TD CLASS="l">1793</TD><TD>                                                // avevo problemi di nullPointerException per questo</TD></TR><TR><TD CLASS="l">1794</TD><TD>                                                // verifico di che</TD></TR><TR><TD CLASS="l">1795</TD><TD>                                                // tipo sono</TD></TR><TR><TD CLASS="l">1796</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1797</TD><TD>                                                if (cell instanceof SourceCell</TD></TR><TR><TD CLASS="l">1798</TD><TD>                                                                &amp;&amp; ((JmtEdge) overlapping[j]).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(overlapping[j], false),</TD></TR><TR><TD CLASS="l">1799</TD><TD>                                                                                GraphConstants.getBounds(((SourceCell) cell).getAttributes()))) {</TD></TR><TR CLASS="z"><TD CLASS="l">1800</TD><TD>                                                        if (((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(0)) {</TD></TR><TR><TD CLASS="l">1801</TD><TD>                                                                // _______INIZIO_____</TD></TR><TR CLASS="z"><TD CLASS="l">1802</TD><TD>                                                                ArrayList&lt;Point2D&gt; intersectionPoints = ((JmtEdge) overlapping[j]).getIntersectionVertexPoint();</TD></TR><TR CLASS="z"><TD CLASS="l">1803</TD><TD>                                                                Point2D tmp = (intersectionPoints.get(0));</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>                                                                Rectangle2D cellBound = GraphConstants.getBounds(((SourceCell) cell).getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">1805</TD><TD>                                                                double vertexMaxX = (int) cellBound.getMaxX();</TD></TR><TR CLASS="z"><TD CLASS="l">1806</TD><TD>                                                                double vertexMaxY = (int) cellBound.getMaxY();</TD></TR><TR CLASS="z"><TD CLASS="l">1807</TD><TD>                                                                double vertexHeight = (int) cellBound.getHeight();</TD></TR><TR CLASS="z"><TD CLASS="l">1808</TD><TD>                                                                double vertexWidth = (int) cellBound.getWidth();</TD></TR><TR CLASS="z"><TD CLASS="l">1809</TD><TD>                                                                boolean upperSideIntersaction = ((JmtEdge) overlapping[j]).getUpperSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1810</TD><TD>                                                                boolean lowerSideIntersaction = ((JmtEdge) overlapping[j]).getLowerSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1811</TD><TD>                                                                boolean leftSideIntersaction = ((JmtEdge) overlapping[j]).getLeftSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1812</TD><TD>                                                                boolean rightSideIntersaction = ((JmtEdge) overlapping[j]).getRightSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1813</TD><TD>                                                                if (upperSideIntersaction &amp;&amp; lowerSideIntersaction) {</TD></TR><TR><TD CLASS="l">1814</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1815</TD><TD>                                                                        int valoreIntermedio = ((int) vertexMaxX - (int) (vertexWidth / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1816</TD><TD>                                                                        if ((int) tmp.getX() &lt; valoreIntermedio) {</TD></TR><TR><TD CLASS="l">1817</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1818</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1819</TD><TD>                                                                                                false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1820</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1821</TD><TD>                                                                        } else {</TD></TR><TR><TD CLASS="l">1822</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1823</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1824</TD><TD>                                                                                                false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1826</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1827</TD><TD>                                                                } else if (leftSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1828</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1829</TD><TD>                                                                        int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1830</TD><TD>                                                                        if ((int) tmp.getY() &lt; valoreIntermedio) {</TD></TR><TR CLASS="z"><TD CLASS="l">1831</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1832</TD><TD>                                                                                                false, true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1833</TD><TD>                                                                                Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);</TD></TR><TR CLASS="z"><TD CLASS="l">1834</TD><TD>                                                                                bounds.setLocation(newPosition2);</TD></TR><TR CLASS="z"><TD CLASS="l">1835</TD><TD>                                                                                sp = sp + 2;</TD></TR><TR><TD CLASS="l">1836</TD><TD>                                                                                // cellBounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1837</TD><TD>                                                                                // GraphConstants.setBounds(((SinkCell)cell).getAttributes(),</TD></TR><TR><TD CLASS="l">1838</TD><TD>                                                                                // cellBounds);</TD></TR><TR CLASS="z"><TD CLASS="l">1839</TD><TD>                                                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1840</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1841</TD><TD>                                                                                                true, false, false, false);</TD></TR><TR><TD CLASS="l">1842</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1843</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1844</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1845</TD><TD>                                                                } else if (upperSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1846</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1847</TD><TD>                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,</TD></TR><TR><TD CLASS="l">1848</TD><TD>                                                                                        false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1849</TD><TD>                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1850</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1851</TD><TD>                                                                } else if (upperSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">1852</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1853</TD><TD>                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,</TD></TR><TR><TD CLASS="l">1854</TD><TD>                                                                                        false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1855</TD><TD>                                                                        bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1856</TD><TD>                                                                } else if (lowerSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1857</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1858</TD><TD>                                                                        Point2D tmp1 = (intersectionPoints.get(1));</TD></TR><TR CLASS="z"><TD CLASS="l">1859</TD><TD>                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1, false,</TD></TR><TR><TD CLASS="l">1860</TD><TD>                                                                                        false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1861</TD><TD>                                                                        bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1862</TD><TD>                                                                } else if (lowerSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">1863</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1864</TD><TD>                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp, false,</TD></TR><TR><TD CLASS="l">1865</TD><TD>                                                                                        false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1866</TD><TD>                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1867</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1868</TD><TD>                                                                access = true;</TD></TR><TR><TD CLASS="l">1869</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1870</TD><TD> </TD></TR><TR><TD CLASS="l">1871</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1872</TD><TD>                                                if (cell instanceof SinkCell) {</TD></TR><TR><TD CLASS="l">1873</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1874</TD><TD>                                                        if (((JmtEdge) overlapping[j]).getTarget() != cell.getChildAt(0)) {</TD></TR><TR><TD CLASS="l">1875</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1876</TD><TD>                                                                if (((JmtEdge) overlapping[j]).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(overlapping[j], false),</TD></TR><TR><TD CLASS="l">1877</TD><TD>                                                                                GraphConstants.getBounds(((SinkCell) cell).getAttributes()))) {</TD></TR><TR><TD CLASS="l">1878</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1879</TD><TD>                                                                        ArrayList&lt;Point2D&gt; intersectionPoints = ((JmtEdge) overlapping[j]).getIntersectionVertexPoint();</TD></TR><TR CLASS="z"><TD CLASS="l">1880</TD><TD>                                                                        Point2D tmp = (intersectionPoints.get(0));</TD></TR><TR CLASS="z"><TD CLASS="l">1881</TD><TD>                                                                        Rectangle2D cellBound = GraphConstants.getBounds(((SinkCell) cell).getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">1882</TD><TD>                                                                        double vertexMaxX = (int) cellBound.getMaxX();</TD></TR><TR CLASS="z"><TD CLASS="l">1883</TD><TD>                                                                        double vertexMaxY = (int) cellBound.getMaxY();</TD></TR><TR CLASS="z"><TD CLASS="l">1884</TD><TD>                                                                        double vertexHeight = (int) cellBound.getHeight();</TD></TR><TR CLASS="z"><TD CLASS="l">1885</TD><TD>                                                                        double vertexWidth = (int) cellBound.getWidth();</TD></TR><TR CLASS="z"><TD CLASS="l">1886</TD><TD>                                                                        boolean upperSideIntersaction = ((JmtEdge) overlapping[j]).getUpperSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1887</TD><TD>                                                                        boolean lowerSideIntersaction = ((JmtEdge) overlapping[j]).getLowerSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1888</TD><TD>                                                                        boolean leftSideIntersaction = ((JmtEdge) overlapping[j]).getLeftSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1889</TD><TD>                                                                        boolean rightSideIntersaction = ((JmtEdge) overlapping[j]).getRightSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1890</TD><TD>                                                                        if (upperSideIntersaction &amp;&amp; lowerSideIntersaction) {</TD></TR><TR><TD CLASS="l">1891</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1892</TD><TD>                                                                                int valoreIntermedio = ((int) vertexMaxX - (int) (vertexWidth / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1893</TD><TD>                                                                                if ((int) tmp.getX() &lt; valoreIntermedio) {</TD></TR><TR CLASS="z"><TD CLASS="l">1894</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1895</TD><TD>                                                                                                        false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1896</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1897</TD><TD>                                                                                } else {</TD></TR><TR><TD CLASS="l">1898</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1899</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1900</TD><TD>                                                                                                        false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1901</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1902</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>                                                                        } else if (leftSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1904</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1905</TD><TD>                                                                                int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1906</TD><TD>                                                                                if ((int) tmp.getY() &lt; valoreIntermedio) {</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1908</TD><TD>                                                                                                        false, true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>                                                                                        Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);</TD></TR><TR CLASS="z"><TD CLASS="l">1910</TD><TD>                                                                                        bounds.setLocation(newPosition2);</TD></TR><TR CLASS="z"><TD CLASS="l">1911</TD><TD>                                                                                        sp = sp + 3;</TD></TR><TR><TD CLASS="l">1912</TD><TD>                                                                                        // bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1913</TD><TD>                                                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1914</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1915</TD><TD>                                                                                                        true, false, false, false);</TD></TR><TR><TD CLASS="l">1916</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1917</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1918</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1919</TD><TD>                                                                        } else if (upperSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1920</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1921</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1922</TD><TD>                                                                                                false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1923</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1924</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1925</TD><TD>                                                                        } else if (upperSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">1926</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1927</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1928</TD><TD>                                                                                                false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1929</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1930</TD><TD>                                                                        } else if (lowerSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1931</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1932</TD><TD>                                                                                Point2D tmp1 = (intersectionPoints.get(1));</TD></TR><TR CLASS="z"><TD CLASS="l">1933</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1,</TD></TR><TR><TD CLASS="l">1934</TD><TD>                                                                                                false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1935</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>                                                                        } else if (lowerSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">1937</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1938</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1939</TD><TD>                                                                                                false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1940</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1941</TD><TD>                                                                                // GraphConstants.setBounds(((SinkCell)cell).getAttributes(),</TD></TR><TR><TD CLASS="l">1942</TD><TD>                                                                                // cellBounds);</TD></TR><TR><TD CLASS="l">1943</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1944</TD><TD>                                                                        access2 = true;</TD></TR><TR><TD CLASS="l">1945</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1946</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1947</TD><TD> </TD></TR><TR><TD CLASS="l">1948</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1949</TD><TD>                                                if (!isInGroup(overlapping[j]) &amp;&amp; !access &amp;&amp; !access2 &amp;&amp; overlapping[j] instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">1950</TD><TD>                                                        if ((numberOfChild == 2)</TD></TR><TR><TD CLASS="l">1951</TD><TD>                                                                        &amp;&amp; ((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(0)</TD></TR><TR><TD CLASS="l">1952</TD><TD>                                                                        &amp;&amp; ((JmtEdge) overlapping[j]).getSource() != cell.getChildAt(1)</TD></TR><TR><TD CLASS="l">1953</TD><TD>                                                                        &amp;&amp; ((JmtEdge) overlapping[j]).getTarget() != cell.getChildAt(0)</TD></TR><TR><TD CLASS="l">1954</TD><TD>                                                                        &amp;&amp; ((JmtEdge) overlapping[j]).getTarget() != cell.getChildAt(1)</TD></TR><TR><TD CLASS="l">1955</TD><TD>                                                                        &amp;&amp; ((JmtEdge) overlapping[j]).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(overlapping[j],</TD></TR><TR><TD CLASS="l">1956</TD><TD>                                                                                        false), GraphConstants.getBounds(cell.getAttributes()))) {</TD></TR><TR><TD CLASS="l">1957</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1958</TD><TD>                                                                access = access2 = false;</TD></TR><TR><TD CLASS="l">1959</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1960</TD><TD>                                                                ArrayList&lt;Point2D&gt; intersectionPoints = ((JmtEdge) overlapping[j]).getIntersectionVertexPoint();</TD></TR><TR CLASS="z"><TD CLASS="l">1961</TD><TD>                                                                if ((intersectionPoints == null) || intersectionPoints.size() &lt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1962</TD><TD>                                                                        bounds.setLocation(new Point(oldPointX, oldPointY));</TD></TR><TR CLASS="z"><TD CLASS="l">1963</TD><TD>                                                                        GraphConstants.setBounds(cell.getAttributes(), bounds);</TD></TR><TR CLASS="z"><TD CLASS="l">1964</TD><TD>                                                                        resetOverLapping = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1965</TD><TD>                                                                        return;</TD></TR><TR><TD CLASS="l">1966</TD><TD>                                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1967</TD><TD>                                                                        Point2D tmp = (intersectionPoints.get(0));</TD></TR><TR><TD CLASS="l">1968</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1969</TD><TD>                                                                        Rectangle2D cellBound = GraphConstants.getBounds(cell.getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">1970</TD><TD>                                                                        double vertexMaxX = (int) cellBound.getMaxX();</TD></TR><TR CLASS="z"><TD CLASS="l">1971</TD><TD>                                                                        double vertexMaxY = (int) cellBound.getMaxY();</TD></TR><TR CLASS="z"><TD CLASS="l">1972</TD><TD>                                                                        double vertexHeight = (int) cellBound.getHeight();</TD></TR><TR CLASS="z"><TD CLASS="l">1973</TD><TD>                                                                        double vertexWidth = (int) cellBound.getWidth();</TD></TR><TR CLASS="z"><TD CLASS="l">1974</TD><TD>                                                                        boolean upperSideIntersaction = ((JmtEdge) overlapping[j]).getUpperSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                                                                        boolean lowerSideIntersaction = ((JmtEdge) overlapping[j]).getLowerSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1976</TD><TD>                                                                        boolean leftSideIntersaction = ((JmtEdge) overlapping[j]).getLeftSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1977</TD><TD>                                                                        boolean rightSideIntersaction = ((JmtEdge) overlapping[j]).getRightSideIntersaction();</TD></TR><TR CLASS="z"><TD CLASS="l">1978</TD><TD>                                                                        if (upperSideIntersaction &amp;&amp; lowerSideIntersaction) {</TD></TR><TR><TD CLASS="l">1979</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1980</TD><TD>                                                                                int valoreIntermedio = ((int) vertexMaxX - (int) (vertexWidth / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1981</TD><TD>                                                                                if ((int) tmp.getX() &lt; valoreIntermedio) {</TD></TR><TR><TD CLASS="l">1982</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1983</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1984</TD><TD>                                                                                                        false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1985</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1986</TD><TD>                                                                                } else {</TD></TR><TR><TD CLASS="l">1987</TD><TD> </TD></TR><TR><TD CLASS="l">1988</TD><TD>                                                                                        ;</TD></TR><TR CLASS="z"><TD CLASS="l">1989</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1990</TD><TD>                                                                                                        false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1991</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">1992</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1993</TD><TD>                                                                        } else if (leftSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">1994</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1995</TD><TD>                                                                                int valoreIntermedio = ((int) vertexMaxY - (int) (vertexHeight / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">1996</TD><TD>                                                                                if ((int) tmp.getY() &lt; valoreIntermedio) {</TD></TR><TR><TD CLASS="l">1997</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1998</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">1999</TD><TD>                                                                                                        false, true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2000</TD><TD>                                                                                        Point newPosition2 = new Point(newPosition.x, newPosition.y + sp);</TD></TR><TR CLASS="z"><TD CLASS="l">2001</TD><TD>                                                                                        bounds.setLocation(newPosition2);</TD></TR><TR CLASS="z"><TD CLASS="l">2002</TD><TD>                                                                                        sp = sp + 3;</TD></TR><TR><TD CLASS="l">2003</TD><TD>                                                                                        // bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">2004</TD><TD>                                                                                        // GraphConstants.setBounds(((SinkCell)cell).getAttributes(),</TD></TR><TR><TD CLASS="l">2005</TD><TD>                                                                                        // cellBounds);</TD></TR><TR CLASS="z"><TD CLASS="l">2006</TD><TD>                                                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2007</TD><TD>                                                                                        Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">2008</TD><TD>                                                                                                        true, false, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2009</TD><TD>                                                                                        bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">2010</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>                                                                        } else if (upperSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">2012</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2013</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">2014</TD><TD>                                                                                                false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">2015</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">2016</TD><TD>                                                                        } else if (upperSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">2017</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2018</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">2019</TD><TD>                                                                                                false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2020</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">2021</TD><TD>                                                                        } else if (lowerSideIntersaction &amp;&amp; rightSideIntersaction) {</TD></TR><TR><TD CLASS="l">2022</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2023</TD><TD>                                                                                Point2D tmp1 = (intersectionPoints.get(1));</TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp1,</TD></TR><TR><TD CLASS="l">2025</TD><TD>                                                                                                false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">2026</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">2027</TD><TD>                                                                        } else if (lowerSideIntersaction &amp;&amp; leftSideIntersaction) {</TD></TR><TR><TD CLASS="l">2028</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2029</TD><TD>                                                                                Point newPosition = (this.overlapping).findFreePosition(((JmtEdge) overlapping[j]), cell, cellBound, tmp,</TD></TR><TR><TD CLASS="l">2030</TD><TD>                                                                                                false, false, true, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2031</TD><TD>                                                                                bounds.setLocation(newPosition);</TD></TR><TR><TD CLASS="l">2032</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2033</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2034</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2035</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2036</TD><TD>                                        } // end if of edge</TD></TR><TR><TD CLASS="l">2037</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2038</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2039</TD><TD>                                if (last.equals(zero)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2040</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2041</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2042</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2043</TD><TD>                                bounds.setLocation(new Point((int) (last.getX()), (int) (last.getY())));</TD></TR><TR><TD CLASS="l">2044</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2045</TD><TD>                                overlapping = graph.getDescendants(graph.getRoots(bounds));</TD></TR><TR CLASS="z"><TD CLASS="l">2046</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2047</TD><TD> </TD></TR><TR><TD CLASS="l">2048</TD><TD>                        // Puts this cell in found position</TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>                        GraphConstants.setBounds(cell.getAttributes(), bounds);</TD></TR><TR><TD CLASS="l">2050</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">2052</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2053</TD><TD>                        Rectangle bounds = GraphConstants.getBounds(cell.getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">2054</TD><TD>                        if (isInGroup(cell)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2055</TD><TD>                                inGroup = true;</TD></TR><TR><TD CLASS="l">2056</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2057</TD><TD> </TD></TR><TR><TD CLASS="l">2058</TD><TD>                        // Avoids negative starting point</TD></TR><TR CLASS="z"><TD CLASS="l">2059</TD><TD>                        if (bounds.getX() &lt; 20) {</TD></TR><TR CLASS="z"><TD CLASS="l">2060</TD><TD>                                bounds.setLocation(20, (int) bounds.getY());</TD></TR><TR><TD CLASS="l">2061</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2062</TD><TD>                        if (bounds.getY() &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2063</TD><TD>                                bounds.setLocation((int) bounds.getX(), 0);</TD></TR><TR><TD CLASS="l">2064</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2065</TD><TD>                        Object[] overlapping = graph.getDescendants(graph.getRoots(bounds));</TD></TR><TR><TD CLASS="l">2066</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2067</TD><TD>                        if (overlapping == null) {</TD></TR><TR><TD CLASS="l">2068</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2069</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">2070</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2071</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2072</TD><TD>                        Point2D zero = new Point(20, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">2073</TD><TD>                        while (overlapping.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2074</TD><TD>                                Point2D last = (Point2D) zero.clone();</TD></TR><TR CLASS="z"><TD CLASS="l">2075</TD><TD>                                for (Object element : overlapping) {</TD></TR><TR CLASS="z"><TD CLASS="l">2076</TD><TD>                                        if (element instanceof JmtCell &amp;&amp; element != cell &amp;&amp; inGroup) {</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>                                                Rectangle2D b2 = GraphConstants.getBounds(((JmtCell) element).getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">2078</TD><TD>                                                if (b2.intersects(bounds)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2079</TD><TD>                                                        if (b2.getMaxX() &gt; last.getX()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2080</TD><TD>                                                                last.setLocation(b2.getMaxX(), last.getY());</TD></TR><TR><TD CLASS="l">2081</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2082</TD><TD>                                                        if (b2.getMaxY() &gt; last.getY()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2083</TD><TD>                                                                last.setLocation(last.getX(), b2.getMaxY());</TD></TR><TR><TD CLASS="l">2084</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2085</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2086</TD><TD>                                                        last.setLocation(new Point((int) (last.getX() + .5), (int) (last.getY() + .5)));</TD></TR><TR><TD CLASS="l">2087</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2088</TD><TD> </TD></TR><TR><TD CLASS="l">2089</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2090</TD><TD>                                        if (!inGroup &amp;&amp; element instanceof JmtCell &amp;&amp; element != cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2091</TD><TD>                                                last.setLocation(new Point((int) (last.getX() + .5), (int) (last.getY() + .5)));</TD></TR><TR><TD CLASS="l">2092</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>                                        int numberOfChild = cell.getChildCount();</TD></TR><TR CLASS="z"><TD CLASS="l">2094</TD><TD>                                        if (isInGroup(element) &amp;&amp; element instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">2095</TD><TD>                                                if ((numberOfChild == 2)</TD></TR><TR><TD CLASS="l">2096</TD><TD>                                                                &amp;&amp; ((JmtEdge) element).getSource() != cell.getChildAt(0)</TD></TR><TR><TD CLASS="l">2097</TD><TD>                                                                &amp;&amp; ((JmtEdge) element).getSource() != cell.getChildAt(1)</TD></TR><TR><TD CLASS="l">2098</TD><TD>                                                                &amp;&amp; ((JmtEdge) element).getTarget() != cell.getChildAt(0)</TD></TR><TR><TD CLASS="l">2099</TD><TD>                                                                &amp;&amp; ((JmtEdge) element).getTarget() != cell.getChildAt(1)</TD></TR><TR><TD CLASS="l">2100</TD><TD>                                                                &amp;&amp; ((JmtEdge) element).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(element, false), GraphConstants</TD></TR><TR><TD CLASS="l">2101</TD><TD>                                                                                .getBounds(cell.getAttributes()))) {</TD></TR><TR><TD CLASS="l">2102</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2103</TD><TD>                                                Rectangle2D b2 = GraphConstants.getBounds(((JmtEdge) element).getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">2104</TD><TD>                                                if (b2.intersects(bounds)) {</TD></TR><TR><TD CLASS="l">2105</TD><TD>                                                        // ___</TD></TR><TR><TD CLASS="l">2106</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2107</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2108</TD><TD>                                                last.setLocation(new Point((int) (last.getX() + .5), (int) (last.getY() + .5)));</TD></TR><TR><TD CLASS="l">2109</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2110</TD><TD> </TD></TR><TR><TD CLASS="l">2111</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2112</TD><TD>                                if (last.equals(zero)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2113</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2114</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2115</TD><TD>                                bounds.setLocation(new Point((int) (last.getX()), (int) (last.getY())));</TD></TR><TR CLASS="z"><TD CLASS="l">2116</TD><TD>                                overlapping = graph.getDescendants(graph.getRoots(bounds));</TD></TR><TR CLASS="z"><TD CLASS="l">2117</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2118</TD><TD>                        GraphConstants.setBounds(cell.getAttributes(), bounds);</TD></TR><TR><TD CLASS="l">2119</TD><TD> </TD></TR><TR><TD CLASS="l">2120</TD><TD>                }</TD></TR><TR><TD CLASS="l">2121</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2122</TD><TD>        }</TD></TR><TR><TD CLASS="l">2123</TD><TD> </TD></TR><TR><TD CLASS="l">2124</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2125</TD><TD>         * Retrives the location of the given cell.</TD></TR><TR><TD CLASS="l"><A NAME="2c">2126</A></TD><TD>         * @param cell The given cell</TD></TR><TR><TD CLASS="l">2127</TD><TD>         * @return The cell location</TD></TR><TR><TD CLASS="l">2128</TD><TD>         */</TD></TR><TR><TD CLASS="l">2129</TD><TD>        public Point2D getCellCoordinates(JmtCell cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2130</TD><TD>                Rectangle2D bounds = GraphConstants.getBounds(cell.getAttributes());</TD></TR><TR CLASS="z"><TD CLASS="l">2131</TD><TD>                return new Point2D.Double(bounds.getMinX(), bounds.getMinY());</TD></TR><TR><TD CLASS="l">2132</TD><TD>        }</TD></TR><TR><TD CLASS="l">2133</TD><TD> </TD></TR><TR><TD CLASS="l">2134</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2135</TD><TD>         * Checks whether the given cell overlaps an existing cell with its bounds.</TD></TR><TR><TD CLASS="l">2136</TD><TD>         * @param p The point where the given cell will be inserted.</TD></TR><TR><TD CLASS="l">2137</TD><TD>         * @param cell The given cell.</TD></TR><TR><TD CLASS="l">2138</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; - whether there's an overlapping situation.</TD></TR><TR><TD CLASS="l">2139</TD><TD>         */</TD></TR><TR><TD CLASS="l"><A NAME="74">2140</A></TD><TD>        public boolean overlapCells(Point2D p, JmtCell cell) {</TD></TR><TR><TD CLASS="l">2141</TD><TD>                Map attributes;</TD></TR><TR><TD CLASS="l">2142</TD><TD> </TD></TR><TR><TD CLASS="l">2143</TD><TD>                // Creates a rectangle representing the new cell bounds and position</TD></TR><TR CLASS="z"><TD CLASS="l">2144</TD><TD>                Dimension cellsize = cell.getSize(graph);</TD></TR><TR CLASS="z"><TD CLASS="l">2145</TD><TD>                Rectangle r = new Rectangle2D.Double(p.getX(), p.getY(), cellsize.getWidth(), cellsize.getHeight()).getBounds();</TD></TR><TR><TD CLASS="l">2146</TD><TD> </TD></TR><TR><TD CLASS="l">2147</TD><TD>                // Gets all cells that can overlap with given one</TD></TR><TR CLASS="z"><TD CLASS="l">2148</TD><TD>                Object[] cells = graph.getDescendants(graph.getRoots(r));</TD></TR><TR CLASS="z"><TD CLASS="l">2149</TD><TD>                for (Object cell2 : cells) {</TD></TR><TR><TD CLASS="l">2150</TD><TD>                        // Gets the i-th cell</TD></TR><TR CLASS="z"><TD CLASS="l">2151</TD><TD>                        Object c = cell2;</TD></TR><TR CLASS="z"><TD CLASS="l">2152</TD><TD>                        if (c instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2153</TD><TD>                                if (!c.equals(cell)) {</TD></TR><TR><TD CLASS="l">2154</TD><TD>                                        // Retrives the i-th cell attributes</TD></TR><TR CLASS="z"><TD CLASS="l">2155</TD><TD>                                        attributes = ((JmtCell) c).getAttributes();</TD></TR><TR><TD CLASS="l">2156</TD><TD>                                        // Is there an intersection ?</TD></TR><TR CLASS="z"><TD CLASS="l">2157</TD><TD>                                        if (GraphConstants.getBounds(attributes).intersects(r)) {</TD></TR><TR><TD CLASS="l">2158</TD><TD>                                                // Yes</TD></TR><TR CLASS="z"><TD CLASS="l">2159</TD><TD>                                                return true;</TD></TR><TR><TD CLASS="l">2160</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2161</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2162</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2163</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2164</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">2165</TD><TD>        }</TD></TR><TR><TD CLASS="l">2166</TD><TD> </TD></TR><TR><TD CLASS="l">2167</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2168</TD><TD>         * Checks whether the given region overlaps an existing cell with its bounds.</TD></TR><TR><TD CLASS="l">2169</TD><TD>         * This method is used to control overlapping before inserting new cell into the</TD></TR><TR><TD CLASS="l">2170</TD><TD>         * Jgraph.</TD></TR><TR><TD CLASS="l">2171</TD><TD>         * @param p The point where the given cell will be inserted.</TD></TR><TR><TD CLASS="l">2172</TD><TD>         * @param d The dimensions of cell to be inserted</TD></TR><TR><TD CLASS="l">2173</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; - whether there's an overlapping situation.</TD></TR><TR><TD CLASS="l">2174</TD><TD>         *</TD></TR><TR><TD CLASS="l">2175</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l"><A NAME="73">2176</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">2177</TD><TD>         * Heavily Modified by Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">2178</TD><TD>         */</TD></TR><TR><TD CLASS="l">2179</TD><TD>        public boolean overlapCells(Point p, Dimension d) {</TD></TR><TR CLASS="z"><TD CLASS="l">2180</TD><TD>                Rectangle r = new Rectangle(p, d);</TD></TR><TR><TD CLASS="l">2181</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2182</TD><TD>                boolean overlapCells = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2183</TD><TD>                Object[] cells = graph.getRoots(r);</TD></TR><TR CLASS="z"><TD CLASS="l">2184</TD><TD>                for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>                        if (cell instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">2186</TD><TD>                                if (((JmtEdge) cell).intersects((EdgeView) (graph.getGraphLayoutCache()).getMapping(cell, false), r)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2187</TD><TD>                                        overlapCells = true;</TD></TR><TR><TD CLASS="l">2188</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2189</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2190</TD><TD>                        if (cell instanceof JmtCell || cell instanceof BlockingRegion || cell instanceof SourceCell || cell instanceof SinkCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2191</TD><TD>                                overlapCells = true;</TD></TR><TR><TD CLASS="l">2192</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2193</TD><TD> </TD></TR><TR><TD CLASS="l">2194</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2195</TD><TD>                return overlapCells;</TD></TR><TR><TD CLASS="l">2196</TD><TD> </TD></TR><TR><TD CLASS="l">2197</TD><TD>        }</TD></TR><TR><TD CLASS="l">2198</TD><TD> </TD></TR><TR><TD CLASS="l">2199</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2200</TD><TD>         * Generates the xml to send to simulation engine.</TD></TR><TR><TD CLASS="l">2201</TD><TD>         *</TD></TR><TR><TD CLASS="l">2202</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">2203</TD><TD>         *</TD></TR><TR><TD CLASS="l">2204</TD><TD>         * Modified by Francesco D'Aquino</TD></TR><TR><TD CLASS="l"><A NAME="9a">2205</A></TD><TD>         * Modified by Michael Fercu (Logger,2008,0.7.4)</TD></TR><TR><TD CLASS="l">2206</TD><TD>         */</TD></TR><TR><TD CLASS="l">2207</TD><TD>        public void startSimulation() {</TD></TR><TR><TD CLASS="l">2208</TD><TD>                // if simulation is not in pause state</TD></TR><TR CLASS="z"><TD CLASS="l">2209</TD><TD>                if (!stopSimulation.isEnabled()) {</TD></TR><TR><TD CLASS="l">2210</TD><TD>                        // Asks for confirmation before overwriting previous simulation data</TD></TR><TR CLASS="z"><TD CLASS="l">2211</TD><TD>                        if (model.containsSimulationResults()) {</TD></TR><TR><TD CLASS="l">2212</TD><TD>                                // Find frame to show confirm dialog</TD></TR><TR CLASS="z"><TD CLASS="l">2213</TD><TD>                                Component parent = mainWindow;</TD></TR><TR CLASS="z"><TD CLASS="l">2214</TD><TD>                                if (resultsWindow != null &amp;&amp; resultsWindow.isFocused()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2215</TD><TD>                                        parent = resultsWindow;</TD></TR><TR><TD CLASS="l">2216</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2217</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2218</TD><TD>                                int resultValue = JOptionPane.showConfirmDialog(parent, &#34;This operation will overwrite old simulation results.&#34; + &#34;Continue anyway?&#34;,</TD></TR><TR><TD CLASS="l">2219</TD><TD>                                                &#34;JMT - Warning&#34;, JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2220</TD><TD>                                if (resultValue == JOptionPane.NO_OPTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">2221</TD><TD>                                        return;</TD></TR><TR><TD CLASS="l">2222</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2223</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2224</TD><TD>                        // Asks for confirmation if a logger-file exists (and has existing data) [MF08 0.7.4 (Marco Bertoli)]</TD></TR><TR CLASS="z"><TD CLASS="l">2225</TD><TD>                        String[] ln = model.getLoggerNameList();</TD></TR><TR CLASS="z"><TD CLASS="l">2226</TD><TD>                        String ln2 = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2227</TD><TD>                        if (ln != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2228</TD><TD>                                if (model.getLoggingGlbParameter(&#34;autoAppend&#34;)</TD></TR><TR><TD CLASS="l">2229</TD><TD>                                                .equalsIgnoreCase(new Integer(jmt.engine.log.LoggerParameters.LOGGER_AR_ASK).toString())) {</TD></TR><TR CLASS="z"><TD CLASS="l">2230</TD><TD>                                        if (ln.length &gt; 0) {</TD></TR><TR><TD CLASS="l">2231</TD><TD>                                                // Cache the absolute log-path</TD></TR><TR><TD CLASS="l">2232</TD><TD>                                                String logabspath;</TD></TR><TR CLASS="z"><TD CLASS="l">2233</TD><TD>                                                if (model.getLoggingGlbParameter(&#34;path&#34;).equalsIgnoreCase(&#34;&#34;) || (model.getLoggingGlbParameter(&#34;path&#34;).equalsIgnoreCase(&#34;.&#34;))) {</TD></TR><TR CLASS="z"><TD CLASS="l">2234</TD><TD>                                                        logabspath = new File(&#34;&#34;).getAbsolutePath() + File.separator;</TD></TR><TR><TD CLASS="l">2235</TD><TD>                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2236</TD><TD>                                                        logabspath = new File(model.getLoggingGlbParameter(&#34;path&#34;)).getAbsolutePath() + File.separator;</TD></TR><TR><TD CLASS="l">2237</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2238</TD><TD> </TD></TR><TR><TD CLASS="l">2239</TD><TD>                                                // Find if the logfiles have data in them:</TD></TR><TR><TD CLASS="l">2240</TD><TD>                                                try {</TD></TR><TR><TD CLASS="l">2241</TD><TD>                                                        //Code to remove duplicate file names from the list to obtain a unique list of File names.</TD></TR><TR CLASS="z"><TD CLASS="l">2242</TD><TD>                                                        Arrays.sort(ln);</TD></TR><TR CLASS="z"><TD CLASS="l">2243</TD><TD>                                                        int k = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2244</TD><TD>                                                        for (int i = 0; i &lt; ln.length; i++){</TD></TR><TR CLASS="z"><TD CLASS="l">2245</TD><TD>                                                                if (i &gt; 0 &amp;&amp; ln[i].equals(ln[i -1])){</TD></TR><TR CLASS="z"><TD CLASS="l">2246</TD><TD>                                                                        continue;</TD></TR><TR><TD CLASS="l">2247</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2248</TD><TD>                                                                ln[k++] = ln[i];</TD></TR><TR><TD CLASS="l">2249</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2250</TD><TD>                                                        String[] unique = new String[k];</TD></TR><TR CLASS="z"><TD CLASS="l">2251</TD><TD>                                                        System.arraycopy(ln, 0, unique, 0, k);</TD></TR><TR><TD CLASS="l">2252</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2253</TD><TD>                                                        for (String element : unique) {</TD></TR><TR><TD CLASS="l">2254</TD><TD>                                                                // if the files have data, print what will be overwritten</TD></TR><TR CLASS="z"><TD CLASS="l">2255</TD><TD>                                                                if (new File(logabspath + element).length() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2256</TD><TD>                                                                                ln2 = ln2 + element + &#34;, &#34;;</TD></TR><TR><TD CLASS="l">2257</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2258</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2259</TD><TD>                                                        // remove the trailing comma</TD></TR><TR CLASS="z"><TD CLASS="l">2260</TD><TD>                                                        if (ln2 != &#34;&#34;) {</TD></TR><TR CLASS="z"><TD CLASS="l">2261</TD><TD>                                                                ln2 = ln2.substring(0, ln2.length() - 2);</TD></TR><TR><TD CLASS="l">2262</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2263</TD><TD>                                                } catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2264</TD><TD>                                                        e.printStackTrace();</TD></TR><TR CLASS="z"><TD CLASS="l">2265</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2266</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>                                                if (ln2 != &#34;&#34;) {</TD></TR><TR><TD CLASS="l">2268</TD><TD>                                                        // Find frame to show dialog</TD></TR><TR CLASS="z"><TD CLASS="l">2269</TD><TD>                                                        Component parent = mainWindow;</TD></TR><TR CLASS="z"><TD CLASS="l">2270</TD><TD>                                                        if (resultsWindow != null &amp;&amp; resultsWindow.isFocused()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2271</TD><TD>                                                                parent = resultsWindow;</TD></TR><TR><TD CLASS="l">2272</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2273</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2274</TD><TD>                                                        int resultValue = JOptionPane.showConfirmDialog(parent, &#34;This operation will modify the following logfile(s): &#34; + ln2</TD></TR><TR><TD CLASS="l">2275</TD><TD>                                                                        + &#34;.  &#34; + &#34;Continue anyway?&#34;, &#34;JMT - Warning&#34;, JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2276</TD><TD>                                                        if (resultValue == JOptionPane.NO_OPTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">2277</TD><TD>                                                                return;</TD></TR><TR><TD CLASS="l">2278</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2279</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2280</TD><TD>                                        } else {</TD></TR><TR><TD CLASS="l">2281</TD><TD>                                                //System.out.println(&#34;Empty file&#34;);</TD></TR><TR><TD CLASS="l">2282</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2283</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2284</TD><TD>                        } // end confirmation if file exists</TD></TR><TR><TD CLASS="l">2285</TD><TD>                        // Correct eventual problems on preloading for closed classes</TD></TR><TR CLASS="z"><TD CLASS="l">2286</TD><TD>                        model.manageJobs();</TD></TR><TR CLASS="z"><TD CLASS="l">2287</TD><TD>                        mc = new ModelChecker(model, model, model, model, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2288</TD><TD>                        pw = new JModelProblemsWindow(mainWindow, mc, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2289</TD><TD>                        if (!mc.isEverythingOkNormal()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2290</TD><TD>                                pw.show();</TD></TR><TR><TD CLASS="l">2291</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2292</TD><TD>                        if (mc.isEverythingOkNormal() || ((!mc.isEverythingOkNormal()) &amp;&amp; (pw.continued()))) {</TD></TR><TR CLASS="z"><TD CLASS="l">2293</TD><TD>                                if (!model.isParametricAnalysisEnabled()) {</TD></TR><TR><TD CLASS="l">2294</TD><TD>                                        try {</TD></TR><TR><TD CLASS="l">2295</TD><TD>                                                // Removes previous ResultsWindow</TD></TR><TR CLASS="z"><TD CLASS="l">2296</TD><TD>                                                if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2297</TD><TD>                                                        resultsWindow.dispose();</TD></TR><TR CLASS="z"><TD CLASS="l">2298</TD><TD>                                                        showResults.setEnabled(false);</TD></TR><TR><TD CLASS="l">2299</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2300</TD><TD>                                                File temp = File.createTempFile(&#34;~JModelSimulation&#34;, &#34;.xml&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2301</TD><TD>                                                temp.deleteOnExit();</TD></TR><TR CLASS="z"><TD CLASS="l">2302</TD><TD>                                                XMLWriter.writeXML(temp, model);</TD></TR><TR><TD CLASS="l">2303</TD><TD>                                                // Creates results data structure</TD></TR><TR CLASS="z"><TD CLASS="l">2304</TD><TD>                                                model.setSimulationResults(new ResultsModel(model.getPollingInterval()));</TD></TR><TR CLASS="z"><TD CLASS="l">2305</TD><TD>                                                showResults.setEnabled(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2306</TD><TD>                                                dispatcher = new DispatcherThread(this, model, (ResultsModel) model.getSimulationResults());</TD></TR><TR CLASS="z"><TD CLASS="l">2307</TD><TD>                                                dispatcher.startSimulation(temp);</TD></TR><TR CLASS="z"><TD CLASS="l">2308</TD><TD>                                        } catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>                                                handleException(e);</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2311</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">2312</TD><TD>                                        // Removes previous ResultsWindow</TD></TR><TR CLASS="z"><TD CLASS="l">2313</TD><TD>                                        showResults.setEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">2314</TD><TD>                                        if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>                                                resultsWindow.dispose();</TD></TR><TR><TD CLASS="l">2316</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2317</TD><TD>                                        if (progressWindow == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2318</TD><TD>                                                progressWindow = new PAProgressWindow(mainWindow, simulate, pauseSimulation, stopSimulation, model</TD></TR><TR><TD CLASS="l">2319</TD><TD>                                                                .getParametricAnalysisModel());</TD></TR><TR><TD CLASS="l">2320</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2321</TD><TD>                                        batchThread = new PADispatcherThread(this, model, progressWindow);</TD></TR><TR CLASS="z"><TD CLASS="l">2322</TD><TD>                                        changeSimActionsState(false, true, true);</TD></TR><TR CLASS="z"><TD CLASS="l">2323</TD><TD>                                        progressWindow.initialize(model.getParametricAnalysisModel().getNumberOfSteps());</TD></TR><TR CLASS="z"><TD CLASS="l">2324</TD><TD>                                        progressWindow.start();</TD></TR><TR CLASS="z"><TD CLASS="l">2325</TD><TD>                                        progressWindow.show();</TD></TR><TR CLASS="z"><TD CLASS="l">2326</TD><TD>                                        batchThread.start();</TD></TR><TR><TD CLASS="l">2327</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2328</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2329</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2330</TD><TD>                        if (!model.isParametricAnalysisEnabled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2331</TD><TD>                                dispatcher.restartSimulation();</TD></TR><TR><TD CLASS="l">2332</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2333</TD><TD>                                batchThread.restartSimulation();</TD></TR><TR><TD CLASS="l">2334</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2335</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2336</TD><TD>        }</TD></TR><TR><TD CLASS="l">2337</TD><TD> </TD></TR><TR><TD CLASS="l">2338</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2339</TD><TD>         * Stops current simulation, aborting all measures</TD></TR><TR><TD CLASS="l"><A NAME="9b">2340</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">2341</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">2342</TD><TD>         */</TD></TR><TR><TD CLASS="l">2343</TD><TD>        public void stopSimulation() {</TD></TR><TR CLASS="z"><TD CLASS="l">2344</TD><TD>                if (stopSimulation.isEnabled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2345</TD><TD>                        if (!model.isParametricAnalysisEnabled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2346</TD><TD>                                dispatcher.stopSimulation();</TD></TR><TR><TD CLASS="l">2347</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2348</TD><TD>                                batchThread.stopSimulation();</TD></TR><TR><TD CLASS="l">2349</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2350</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2351</TD><TD>        }</TD></TR><TR><TD CLASS="l">2352</TD><TD> </TD></TR><TR><TD CLASS="l">2353</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2354</TD><TD>         * Pauses current simulation</TD></TR><TR><TD CLASS="l">2355</TD><TD>         *</TD></TR><TR><TD CLASS="l">2356</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l"><A NAME="76">2357</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">2358</TD><TD>         * Modified by Francesco D'Aquino</TD></TR><TR><TD CLASS="l">2359</TD><TD>         */</TD></TR><TR><TD CLASS="l">2360</TD><TD>        public void pauseSimulation() {</TD></TR><TR CLASS="z"><TD CLASS="l">2361</TD><TD>                if (model.isParametricAnalysisEnabled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2362</TD><TD>                        batchThread.pauseSimulation();</TD></TR><TR><TD CLASS="l">2363</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2364</TD><TD>                        dispatcher.pauseSimulation();</TD></TR><TR><TD CLASS="l">2365</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2366</TD><TD>        }</TD></TR><TR><TD CLASS="l">2367</TD><TD> </TD></TR><TR><TD CLASS="l">2368</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2369</TD><TD>         * Changes simulation action status. This method is called by DispatcherThread.</TD></TR><TR><TD CLASS="l">2370</TD><TD>         * @param start state for start action</TD></TR><TR><TD CLASS="l"><A NAME="b">2371</A></TD><TD>         * @param pause state for pause action</TD></TR><TR><TD CLASS="l">2372</TD><TD>         * @param stop state for stop action</TD></TR><TR><TD CLASS="l">2373</TD><TD>         */</TD></TR><TR><TD CLASS="l">2374</TD><TD>        public void changeSimActionsState(boolean start, boolean pause, boolean stop) {</TD></TR><TR CLASS="z"><TD CLASS="l">2375</TD><TD>                simulate.setEnabled(start);</TD></TR><TR CLASS="z"><TD CLASS="l">2376</TD><TD>                stopSimulation.setEnabled(stop);</TD></TR><TR CLASS="z"><TD CLASS="l">2377</TD><TD>                pauseSimulation.setEnabled(pause);</TD></TR><TR CLASS="z"><TD CLASS="l">2378</TD><TD>        }</TD></TR><TR><TD CLASS="l">2379</TD><TD> </TD></TR><TR><TD CLASS="l">2380</TD><TD>        // ///////////////////////////////////////////</TD></TR><TR><TD CLASS="l">2381</TD><TD>        // METHODS THAT MANAGE MEASURES</TD></TR><TR><TD CLASS="l">2382</TD><TD> </TD></TR><TR><TD CLASS="l">2383</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="17">2384</A></TD><TD>         * Launches the &lt;code&gt;Measure&lt;/code&gt; editor.</TD></TR><TR><TD CLASS="l">2385</TD><TD>         * Author: Bertoli Marco</TD></TR><TR><TD CLASS="l">2386</TD><TD>         */</TD></TR><TR><TD CLASS="l">2387</TD><TD>        public void editMeasures() {</TD></TR><TR CLASS="z"><TD CLASS="l">2388</TD><TD>                dialogFactory.getDialog(new MeasurePanel(model, model, model), &#34;Define performance indices&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2389</TD><TD>        }</TD></TR><TR><TD CLASS="l">2390</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="37">2391</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2392</TD><TD>         * @return A refernce to the action &lt;code&gt;EditMeasures&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">2393</TD><TD>         */</TD></TR><TR><TD CLASS="l">2394</TD><TD>        public AbstractJmodelAction getEditMeasures() {</TD></TR><TR CLASS="z"><TD CLASS="l">2395</TD><TD>                return editMeasures;</TD></TR><TR><TD CLASS="l">2396</TD><TD>        }</TD></TR><TR><TD CLASS="l">2397</TD><TD> </TD></TR><TR><TD CLASS="l">2398</TD><TD>        // ///////////////////////////////////////////</TD></TR><TR><TD CLASS="l">2399</TD><TD> </TD></TR><TR><TD CLASS="l">2400</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2401</TD><TD>         * Checks if there's an old graph to save. This methods is called when creates/closes/opens a graph.</TD></TR><TR><TD CLASS="l">2402</TD><TD>         * @param msg The message to display.</TD></TR><TR><TD CLASS="l"><A NAME="c">2403</A></TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; - whether the user accepts to save the graph, or he cancels the current action.</TD></TR><TR><TD CLASS="l">2404</TD><TD>         */</TD></TR><TR><TD CLASS="l">2405</TD><TD>        public boolean checkForSave(String msg) {</TD></TR><TR><TD CLASS="l">2406</TD><TD>                // Checks if there's an old graph to save</TD></TR><TR CLASS="z"><TD CLASS="l">2407</TD><TD>                if (model != null &amp;&amp; model.toBeSaved()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2408</TD><TD>                        int resultValue = JOptionPane.showConfirmDialog(mainWindow, msg, &#34;JMODEL - Warning&#34;, JOptionPane.YES_NO_CANCEL_OPTION,</TD></TR><TR><TD CLASS="l">2409</TD><TD>                                        JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2410</TD><TD>                        if (resultValue == JOptionPane.YES_OPTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">2411</TD><TD>                                saveModel();</TD></TR><TR CLASS="z"><TD CLASS="l">2412</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">2413</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2414</TD><TD>                        if (resultValue == JOptionPane.CANCEL_OPTION) {</TD></TR><TR CLASS="z"><TD CLASS="l">2415</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">2416</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2417</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2418</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">2419</TD><TD>        }</TD></TR><TR><TD CLASS="l">2420</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="5d">2421</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2422</TD><TD>         * @return A refernce to the action &lt;code&gt;SwitchToExactSolver&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">2423</TD><TD>         */</TD></TR><TR><TD CLASS="l">2424</TD><TD>        public AbstractJmodelAction getSwitchToWizard() {</TD></TR><TR CLASS="z"><TD CLASS="l">2425</TD><TD>                return switchToExactSolver;</TD></TR><TR><TD CLASS="l">2426</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="45">2427</A></TD><TD> </TD></TR><TR><TD CLASS="l">2428</TD><TD>        // 13/10/03 - end /////////////////////////////////////////////////////</TD></TR><TR><TD CLASS="l">2429</TD><TD> </TD></TR><TR><TD CLASS="l">2430</TD><TD>        public Cursor getOldCursor() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8c">2431</A></TD><TD>                return oldCursor;</TD></TR><TR><TD CLASS="l">2432</TD><TD>        }</TD></TR><TR><TD CLASS="l">2433</TD><TD> </TD></TR><TR><TD CLASS="l">2434</TD><TD>        public void setOldCursor(Cursor oldCursor) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="85">2435</A></TD><TD>                this.oldCursor = oldCursor;</TD></TR><TR CLASS="z"><TD CLASS="l">2436</TD><TD>        }</TD></TR><TR><TD CLASS="l">2437</TD><TD> </TD></TR><TR><TD CLASS="l">2438</TD><TD>        public void setCursor(Cursor cursor) {</TD></TR><TR CLASS="z"><TD CLASS="l">2439</TD><TD>                oldCursor = this.cursor;</TD></TR><TR CLASS="z"><TD CLASS="l">2440</TD><TD>                this.cursor = cursor;</TD></TR><TR CLASS="z"><TD CLASS="l">2441</TD><TD>                setGraphCursor(cursor);</TD></TR><TR CLASS="z"><TD CLASS="l">2442</TD><TD>        }</TD></TR><TR><TD CLASS="l">2443</TD><TD> </TD></TR><TR><TD CLASS="l">2444</TD><TD>        // --- Bertoli Marco ---------------------</TD></TR><TR><TD CLASS="l">2445</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="26">2446</A></TD><TD>         * Sends an exit signal to main window</TD></TR><TR><TD CLASS="l">2447</TD><TD>         */</TD></TR><TR><TD CLASS="l">2448</TD><TD>        public void exit() {</TD></TR><TR><TD CLASS="l">2449</TD><TD>                // Send a closing signat to main window.</TD></TR><TR CLASS="z"><TD CLASS="l">2450</TD><TD>                mainWindow.dispatchEvent(new WindowEvent(mainWindow, WindowEvent.WINDOW_CLOSING));</TD></TR><TR CLASS="z"><TD CLASS="l">2451</TD><TD>        }</TD></TR><TR><TD CLASS="l">2452</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="91">2453</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2454</TD><TD>         * Shows a DefaultEditor to edit Defaults parameters</TD></TR><TR><TD CLASS="l">2455</TD><TD>         */</TD></TR><TR><TD CLASS="l">2456</TD><TD>        public void showDefaultsEditor() {</TD></TR><TR CLASS="z"><TD CLASS="l">2457</TD><TD>                DefaultsEditor.getInstance(mainWindow, DefaultsEditor.JMODEL).show();</TD></TR><TR CLASS="z"><TD CLASS="l">2458</TD><TD>        }</TD></TR><TR><TD CLASS="l">2459</TD><TD> </TD></TR><TR><TD CLASS="l">2460</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="7c">2461</A></TD><TD>         * Used to reset mouseListener to default (to avoid File_Save / File_New</TD></TR><TR><TD CLASS="l">2462</TD><TD>         * operations while in inserting mode)</TD></TR><TR><TD CLASS="l">2463</TD><TD>         */</TD></TR><TR><TD CLASS="l">2464</TD><TD>        public void resetMouseState() {</TD></TR><TR CLASS="z"><TD CLASS="l">2465</TD><TD>                mouseListner.setDefaultState();</TD></TR><TR CLASS="z"><TD CLASS="l">2466</TD><TD>                componentBar.clearButtonGroupSelection(0);</TD></TR><TR CLASS="z"><TD CLASS="l">2467</TD><TD>                if (graph != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2468</TD><TD>                        graph.clearSelection();</TD></TR><TR CLASS="z"><TD CLASS="l">2469</TD><TD>                        setGraphCursor(Cursor.getDefaultCursor());</TD></TR><TR><TD CLASS="l">2470</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2471</TD><TD>        }</TD></TR><TR><TD CLASS="l">2472</TD><TD> </TD></TR><TR><TD CLASS="l">2473</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2474</TD><TD>         * Returns true iff specified cell is editable. This is used by &lt;code&gt;SelectState&lt;/code&gt;</TD></TR><TR><TD CLASS="l">2475</TD><TD>         * to check if editor has to be showed upon double click event.</TD></TR><TR><TD CLASS="l"><A NAME="68">2476</A></TD><TD>         * @param cell specified cell</TD></TR><TR><TD CLASS="l">2477</TD><TD>         * @return true iff cell is editable</TD></TR><TR><TD CLASS="l">2478</TD><TD>         */</TD></TR><TR><TD CLASS="l">2479</TD><TD>        public boolean isCellEditable(Object cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2480</TD><TD>                return cell instanceof JmtCell || cell instanceof BlockingRegion;</TD></TR><TR><TD CLASS="l">2481</TD><TD>        }</TD></TR><TR><TD CLASS="l">2482</TD><TD> </TD></TR><TR><TD CLASS="l">2483</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="65">2484</A></TD><TD>         * Shows a panel with catched exception</TD></TR><TR><TD CLASS="l">2485</TD><TD>         * @param e exception to be shown</TD></TR><TR><TD CLASS="l">2486</TD><TD>         */</TD></TR><TR><TD CLASS="l">2487</TD><TD>        public void handleException(Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2488</TD><TD>                e.printStackTrace();</TD></TR><TR CLASS="z"><TD CLASS="l">2489</TD><TD>                showErrorMessage(e.getMessage());</TD></TR><TR CLASS="z"><TD CLASS="l">2490</TD><TD>        }</TD></TR><TR><TD CLASS="l">2491</TD><TD> </TD></TR><TR><TD CLASS="l">2492</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="92">2493</A></TD><TD>         * Shows a panel with an error message</TD></TR><TR><TD CLASS="l">2494</TD><TD>         * @param message specified error message</TD></TR><TR><TD CLASS="l">2495</TD><TD>         */</TD></TR><TR><TD CLASS="l">2496</TD><TD>        public synchronized void showErrorMessage(String message) {</TD></TR><TR CLASS="z"><TD CLASS="l">2497</TD><TD>                Component parent = mainWindow;</TD></TR><TR CLASS="z"><TD CLASS="l">2498</TD><TD>                if (resultsWindow != null &amp;&amp; resultsWindow.hasFocus()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2499</TD><TD>                        parent = resultsWindow;</TD></TR><TR><TD CLASS="l">2500</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2501</TD><TD>                JOptionPane.showMessageDialog(parent, message, &#34;Error&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2502</TD><TD>        }</TD></TR><TR><TD CLASS="l">2503</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="9d">2504</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2505</TD><TD>         * Switch current model to JMVA exact solver</TD></TR><TR><TD CLASS="l">2506</TD><TD>         */</TD></TR><TR><TD CLASS="l">2507</TD><TD>        public void toJMVA() {</TD></TR><TR CLASS="z"><TD CLASS="l">2508</TD><TD>                mc = new ModelChecker(model, model, model, model, true);</TD></TR><TR CLASS="z"><TD CLASS="l">2509</TD><TD>                pw = new JModelProblemsWindow(mainWindow, mc, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2510</TD><TD>                if (!mc.isEverythingOkToJMVA()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2511</TD><TD>                        pw.show();</TD></TR><TR><TD CLASS="l">2512</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2513</TD><TD>                if (mc.isEverythingOkToJMVA() || ((!mc.isEverythingOkToJMVA()) &amp;&amp; (pw.continued()))) {</TD></TR><TR CLASS="z"><TD CLASS="l">2514</TD><TD>                        if (checkForSave(&#34;&lt;html&gt;Save changes before switching?&lt;/html&gt;&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2515</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">2516</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2517</TD><TD>                        // try {</TD></TR><TR><TD CLASS="l">2518</TD><TD>                        // New Converter by Bertoli Marco</TD></TR><TR CLASS="z"><TD CLASS="l">2519</TD><TD>                        ExactModel output = new ExactModel();</TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>                        List res = ModelConverter.convertJSIMtoJMVA(model, output);</TD></TR><TR CLASS="z"><TD CLASS="l">2521</TD><TD>                        ExactWizard jmva = new ExactWizard(output);</TD></TR><TR><TD CLASS="l">2522</TD><TD>                        // If problems are found, shows warnings</TD></TR><TR CLASS="z"><TD CLASS="l">2523</TD><TD>                        if (res.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2524</TD><TD>                                new WarningWindow(res, jmva, CommonConstants.JSIM, CommonConstants.JMVA).show();</TD></TR><TR><TD CLASS="l">2525</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2526</TD><TD> </TD></TR><TR><TD CLASS="l">2527</TD><TD>                        /*</TD></TR><TR><TD CLASS="l">2528</TD><TD>                         * Old code to use XSLT transformer (really bugged and unfinished)</TD></TR><TR><TD CLASS="l">2529</TD><TD>                         * </TD></TR><TR><TD CLASS="l">2530</TD><TD>                         * File xmlTempFile = File.createTempFile(&#34;~SIMtoMVA&#34;, &#34;.xml&#34;);</TD></TR><TR><TD CLASS="l">2531</TD><TD>                         * xmlTempFile.deleteOnExit(); File destFile =</TD></TR><TR><TD CLASS="l">2532</TD><TD>                         * File.createTempFile(&#34;~MVA&#34;, &#34;.xml&#34;); destFile.deleteOnExit();</TD></TR><TR><TD CLASS="l">2533</TD><TD>                         * InputStream stream =</TD></TR><TR><TD CLASS="l">2534</TD><TD>                         * XSDSchemaLoader.loadSchemaAsStream(XSDSchemaLoader.JSIM_TO_JMVA);</TD></TR><TR><TD CLASS="l">2535</TD><TD>                         * if(stream==null){ System.out.println(&#34;stream is null&#34;); return; }</TD></TR><TR><TD CLASS="l">2536</TD><TD>                         * XMLWriter.writeXML(xmlTempFile, model); InputStream is = new</TD></TR><TR><TD CLASS="l">2537</TD><TD>                         * BufferedInputStream(stream); Transformer transformer =</TD></TR><TR><TD CLASS="l">2538</TD><TD>                         * TransformerFactory.newInstance().newTransformer(new</TD></TR><TR><TD CLASS="l">2539</TD><TD>                         * StreamSource(is)); StreamSource ssrc = new</TD></TR><TR><TD CLASS="l">2540</TD><TD>                         * StreamSource(xmlTempFile); StreamResult srst = new</TD></TR><TR><TD CLASS="l">2541</TD><TD>                         * StreamResult(destFile); transformer.transform(ssrc, srst);</TD></TR><TR><TD CLASS="l">2542</TD><TD>                         * xmlTempFile.delete(); ExactModel xm = new ExactModel();</TD></TR><TR><TD CLASS="l">2543</TD><TD>                         * xm.loadDocument(new XMLUtils().loadXML(destFile)); new</TD></TR><TR><TD CLASS="l">2544</TD><TD>                         * ExactWizard(xm); }catch (Exception e) { handleException(e); }</TD></TR><TR><TD CLASS="l">2545</TD><TD>                         */</TD></TR><TR><TD CLASS="l">2546</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2547</TD><TD>        }</TD></TR><TR><TD CLASS="l">2548</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="19">2549</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2550</TD><TD>         * Called when EditSimParams action is triggered</TD></TR><TR><TD CLASS="l">2551</TD><TD>         */</TD></TR><TR><TD CLASS="l">2552</TD><TD>        public void editSimulationParameters() {</TD></TR><TR CLASS="z"><TD CLASS="l">2553</TD><TD>                dialogFactory.getDialog(new SimulationPanel(model, model, model, this), &#34;Define Simulation Parameters&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2554</TD><TD>        }</TD></TR><TR><TD CLASS="l">2555</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="18">2556</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2557</TD><TD>         * Called when EditPAParams action is triggered</TD></TR><TR><TD CLASS="l">2558</TD><TD>         */</TD></TR><TR><TD CLASS="l">2559</TD><TD>        public void editPAParameters() {</TD></TR><TR CLASS="z"><TD CLASS="l">2560</TD><TD>                dialogFactory.getDialog(new ParametricAnalysisPanel(model, model, model, this), &#34;Define What-if analysis parameters&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2561</TD><TD>        }</TD></TR><TR><TD CLASS="l">2562</TD><TD> </TD></TR><TR><TD CLASS="l">2563</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="8d">2564</A></TD><TD>         * Sets resultWindow to be shown. This method is used by pollerThread</TD></TR><TR><TD CLASS="l">2565</TD><TD>         * @param rsw window to be set as current ResultsWindow</TD></TR><TR><TD CLASS="l">2566</TD><TD>         */</TD></TR><TR><TD CLASS="l">2567</TD><TD>        public void setResultsWindow(JFrame rsw) {</TD></TR><TR CLASS="z"><TD CLASS="l">2568</TD><TD>                this.resultsWindow = rsw;</TD></TR><TR CLASS="z"><TD CLASS="l">2569</TD><TD>                if (rsw instanceof ResultsWindow) {</TD></TR><TR><TD CLASS="l">2570</TD><TD>                        // Sets action for toolbar buttons</TD></TR><TR CLASS="z"><TD CLASS="l">2571</TD><TD>                        ((ResultsWindow) rsw).addButtonActions(simulate, pauseSimulation, stopSimulation);</TD></TR><TR><TD CLASS="l">2572</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a6">2573</A></TD><TD>                        showResults.setEnabled(true);</TD></TR><TR><TD CLASS="l">2574</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="a8">2575</A></TD><TD>                // Adds a listener that will unselect Show results button upon results</TD></TR><TR><TD CLASS="l">2576</TD><TD>                // window closing</TD></TR><TR CLASS="z"><TD CLASS="l">2577</TD><TD>                rsw.addWindowListener(new WindowAdapter() {</TD></TR><TR><TD CLASS="l">2578</TD><TD>                        public void windowClosing(WindowEvent e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2579</TD><TD>                                showResults.setSelected(false);</TD></TR><TR CLASS="z"><TD CLASS="l">2580</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2581</TD><TD>                });</TD></TR><TR CLASS="z"><TD CLASS="l">2582</TD><TD>        }</TD></TR><TR><TD CLASS="l">2583</TD><TD> </TD></TR><TR><TD CLASS="l">2584</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2585</TD><TD>         * Called when showResults action is triggered</TD></TR><TR><TD CLASS="l">2586</TD><TD>         * @param selected Tells if show results button is selected or not</TD></TR><TR><TD CLASS="l"><A NAME="97">2587</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">2588</TD><TD>         * Modified by Francesco D'Aquino</TD></TR><TR><TD CLASS="l">2589</TD><TD>         */</TD></TR><TR><TD CLASS="l">2590</TD><TD>        public synchronized void showResultsWindow(boolean selected) {</TD></TR><TR CLASS="z"><TD CLASS="l">2591</TD><TD>                if (selected) {</TD></TR><TR CLASS="z"><TD CLASS="l">2592</TD><TD>                        if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2593</TD><TD>                                resultsWindow.show();</TD></TR><TR><TD CLASS="l">2594</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2595</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2596</TD><TD>                        if (resultsWindow != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2597</TD><TD>                                resultsWindow.hide();</TD></TR><TR><TD CLASS="l">2598</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2599</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2600</TD><TD>        }</TD></TR><TR><TD CLASS="l">2601</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="96">2602</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2603</TD><TD>         * Shows results window and forces show results button to be selected</TD></TR><TR><TD CLASS="l">2604</TD><TD>         */</TD></TR><TR><TD CLASS="l">2605</TD><TD>        public void showResultsWindow() {</TD></TR><TR CLASS="z"><TD CLASS="l">2606</TD><TD>                showResults.setSelected(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2607</TD><TD>                showResultsWindow(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2608</TD><TD>        }</TD></TR><TR><TD CLASS="l">2609</TD><TD> </TD></TR><TR><TD CLASS="l">2610</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="4e">2611</A></TD><TD>         * Returns current ResultsWindow</TD></TR><TR><TD CLASS="l">2612</TD><TD>         * @return current ResultsWindow or null if none was created</TD></TR><TR><TD CLASS="l">2613</TD><TD>         */</TD></TR><TR><TD CLASS="l">2614</TD><TD>        public JFrame getResultsWindow() {</TD></TR><TR CLASS="z"><TD CLASS="l">2615</TD><TD>                return resultsWindow;</TD></TR><TR><TD CLASS="l">2616</TD><TD>        }</TD></TR><TR><TD CLASS="l">2617</TD><TD> </TD></TR><TR><TD CLASS="l">2618</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="49">2619</A></TD><TD>         * Returns current PAProgressWindow</TD></TR><TR><TD CLASS="l">2620</TD><TD>         * @return current PAProgressWindow or null if none was created</TD></TR><TR><TD CLASS="l">2621</TD><TD>         */</TD></TR><TR><TD CLASS="l">2622</TD><TD>        public PAProgressWindow getPAProgressWindow() {</TD></TR><TR CLASS="z"><TD CLASS="l">2623</TD><TD>                return progressWindow;</TD></TR><TR><TD CLASS="l">2624</TD><TD>        }</TD></TR><TR><TD CLASS="l">2625</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3">2626</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2627</TD><TD>         * Shows about window</TD></TR><TR><TD CLASS="l">2628</TD><TD>         */</TD></TR><TR><TD CLASS="l">2629</TD><TD>        public void about() {</TD></TR><TR CLASS="z"><TD CLASS="l">2630</TD><TD>                AboutDialogFactory.showJMODEL(mainWindow);</TD></TR><TR CLASS="z"><TD CLASS="l">2631</TD><TD>        }</TD></TR><TR><TD CLASS="l">2632</TD><TD> </TD></TR><TR><TD CLASS="l">2633</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6f">2634</A></TD><TD>         * Tells if something is selected into graph window</TD></TR><TR><TD CLASS="l">2635</TD><TD>         * @return true if something is selected</TD></TR><TR><TD CLASS="l">2636</TD><TD>         */</TD></TR><TR><TD CLASS="l">2637</TD><TD>        public boolean isSomethingSelected() {</TD></TR><TR CLASS="z"><TD CLASS="l">2638</TD><TD>                return graph.getSelectionCell() != null;</TD></TR><TR><TD CLASS="l">2639</TD><TD>        }</TD></TR><TR><TD CLASS="l">2640</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="9c">2641</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2642</TD><TD>         * Takes a screenshot of current jgraph. Shows a dialog to select image type and name</TD></TR><TR><TD CLASS="l">2643</TD><TD>         */</TD></TR><TR><TD CLASS="l">2644</TD><TD>        public void takeScreenShot() {</TD></TR><TR CLASS="z"><TD CLASS="l">2645</TD><TD>                graph.clearSelection();</TD></TR><TR CLASS="z"><TD CLASS="l">2646</TD><TD>                graph.showScreenShotDialog();</TD></TR><TR CLASS="z"><TD CLASS="l">2647</TD><TD>        }</TD></TR><TR><TD CLASS="l">2648</TD><TD> </TD></TR><TR><TD CLASS="l">2649</TD><TD>        // --- end Bertoli Marco ---------------------</TD></TR><TR><TD CLASS="l">2650</TD><TD> </TD></TR><TR><TD CLASS="l">2651</TD><TD>        // --------------------------------- Francesco D'Aquino</TD></TR><TR><TD CLASS="l">2652</TD><TD>        // -----------------------</TD></TR><TR><TD CLASS="l">2653</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="95">2654</A></TD><TD>         *  Shows the panel to solve a problem</TD></TR><TR><TD CLASS="l">2655</TD><TD>         */</TD></TR><TR><TD CLASS="l">2656</TD><TD>        public void showRelatedPanel(int problemType, int problemSubType, Object relatedStation, Object relatedClass) {</TD></TR><TR><TD CLASS="l">2657</TD><TD>                // if it is a no class error show the class panel</TD></TR><TR CLASS="z"><TD CLASS="l">2658</TD><TD>                if ((problemSubType == ModelChecker.NO_CLASSES_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2659</TD><TD>                        dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Manage User Classes&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2660</TD><TD>                        model.manageJobs(); // a close class may be added</TD></TR><TR><TD CLASS="l">2661</TD><TD>                }</TD></TR><TR><TD CLASS="l">2662</TD><TD>                // if it is a no station error show an error message dialog</TD></TR><TR CLASS="z"><TD CLASS="l">2663</TD><TD>                else if ((problemSubType == ModelChecker.NO_STATION_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2664</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;Please insert at least one server or delay before starting simulation.&#34;, &#34;Error&#34;,</TD></TR><TR><TD CLASS="l">2665</TD><TD>                                        JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2666</TD><TD>                } else if ((problemSubType == ModelChecker.SIMULATION_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2667</TD><TD>                        dialogFactory.getDialog(new MeasurePanel(model, model, model), &#34;Edit Performance Indices&#34;);</TD></TR><TR><TD CLASS="l">2668</TD><TD>                }</TD></TR><TR><TD CLASS="l">2669</TD><TD>                // if a measure is inconsistent (i.e have one or more 'null' field) show</TD></TR><TR><TD CLASS="l">2670</TD><TD>                // performance indices panel</TD></TR><TR CLASS="z"><TD CLASS="l">2671</TD><TD>                else if ((problemSubType == ModelChecker.INCONSISTENT_MEASURE_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2672</TD><TD>                        dialogFactory.getDialog(new MeasurePanel(model, model, model), &#34;Edit Performance Indices&#34;);</TD></TR><TR><TD CLASS="l">2673</TD><TD>                }</TD></TR><TR><TD CLASS="l">2674</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">2675</TD><TD>                else if ((problemSubType == ModelChecker.SINK_PERF_IND_WITH_NO_SINK_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2676</TD><TD>                        dialogFactory.getDialog(new MeasurePanel(model, model, model), &#34;Edit Performance Indices&#34;);</TD></TR><TR><TD CLASS="l">2677</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2678</TD><TD>                else if ((problemSubType == ModelChecker.SINK_PERF_WITH_CLOSED_CLASS_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2679</TD><TD>                        dialogFactory.getDialog(new MeasurePanel(model, model, model), &#34;Edit Performance Indices&#34;);</TD></TR><TR><TD CLASS="l">2680</TD><TD>                }</TD></TR><TR><TD CLASS="l">2681</TD><TD>                // if a measure was defined more than once ask to erase all redundant</TD></TR><TR><TD CLASS="l">2682</TD><TD>                // measure</TD></TR><TR CLASS="z"><TD CLASS="l">2683</TD><TD>                else if ((problemSubType == ModelChecker.DUPLICATE_MEASURE_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2684</TD><TD>                        int k = JOptionPane.showConfirmDialog(null, &#34;Delete all redundant performance indices?\n&#34;, &#34;Redundant performance indices found&#34;,</TD></TR><TR><TD CLASS="l">2685</TD><TD>                                        JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2686</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2687</TD><TD>                                mc.deleteRedundantMeasure();</TD></TR><TR><TD CLASS="l">2688</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>                }</TD></TR><TR><TD CLASS="l">2690</TD><TD>                // if it is a reference station error show the class panel</TD></TR><TR CLASS="z"><TD CLASS="l">2691</TD><TD>                else if ((problemSubType == ModelChecker.REFERENCE_STATION_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2692</TD><TD>                        dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Manage User Classes&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2693</TD><TD>                        model.manageJobs(); // a close class may be added</TD></TR><TR><TD CLASS="l">2694</TD><TD>                }</TD></TR><TR><TD CLASS="l">2695</TD><TD>                // if a source has been inserted in the model but no open classes</TD></TR><TR><TD CLASS="l">2696</TD><TD>                // defined show the class panel</TD></TR><TR CLASS="z"><TD CLASS="l">2697</TD><TD>                else if ((problemSubType == ModelChecker.SOURCE_WITH_NO_OPEN_CLASSES_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2698</TD><TD>                        dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Manage User Classes&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2699</TD><TD>                } else if ((problemSubType == ModelChecker.ROUTING_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2700</TD><TD>                        StationParameterPanel tempPanel = new StationParameterPanel(model, model, relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2701</TD><TD>                        String stationName = model.getStationName(relatedStation);</TD></TR><TR><TD CLASS="l">2702</TD><TD>                        // set the station parameter panel to show the routing section</TD></TR><TR CLASS="z"><TD CLASS="l">2703</TD><TD>                        tempPanel.showRoutingSectionPanel(relatedClass);</TD></TR><TR CLASS="z"><TD CLASS="l">2704</TD><TD>                        dialogFactory.getDialog(tempPanel, &#34;Editing &#34; + stationName + &#34; Properties...&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2705</TD><TD>                }</TD></TR><TR><TD CLASS="l">2706</TD><TD>                // if a class may be routed into a station whose forward stations are</TD></TR><TR><TD CLASS="l">2707</TD><TD>                // all sink show an error message</TD></TR><TR CLASS="z"><TD CLASS="l">2708</TD><TD>                else if ((problemSubType == ModelChecker.ALL_FORWARD_STATION_ARE_SINK_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2709</TD><TD>                        String stationName = model.getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2710</TD><TD>                        String className = model.getClassName(relatedClass);</TD></TR><TR CLASS="z"><TD CLASS="l">2711</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;Close class &#34; + className + &#34; may be routed into &#34; + stationName</TD></TR><TR><TD CLASS="l">2712</TD><TD>                                        + &#34; whose forward station are all sink.&#34;, &#34;Error&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2713</TD><TD>                }</TD></TR><TR><TD CLASS="l">2714</TD><TD>                // if no open classes defined but at least a sink has been defined show</TD></TR><TR><TD CLASS="l">2715</TD><TD>                // the class panel</TD></TR><TR CLASS="z"><TD CLASS="l">2716</TD><TD>                else if ((problemSubType == ModelChecker.SINK_BUT_NO_OPEN_CLASSES_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2717</TD><TD>                        dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Manage User Classes&#34;);</TD></TR><TR><TD CLASS="l">2718</TD><TD>                        // JOptionPane.showConfirmDialog(null,&#34;Add an open class to the</TD></TR><TR><TD CLASS="l">2719</TD><TD>                        // model?&#34;,</TD></TR><TR><TD CLASS="l">2720</TD><TD>                        // &#34;Error&#34;,JOptionPane.OK_CANCEL_OPTION,JOptionPane.ERROR_MESSAGE);</TD></TR><TR><TD CLASS="l">2721</TD><TD>                }</TD></TR><TR><TD CLASS="l">2722</TD><TD>                // if an open class defined but no sink have been defined show an error</TD></TR><TR><TD CLASS="l">2723</TD><TD>                // message</TD></TR><TR CLASS="z"><TD CLASS="l">2724</TD><TD>                else if ((problemSubType == ModelChecker.NO_SINK_WITH_OPEN_CLASSES_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2725</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;Open classes defined but no sink, add a sink to the model.&#34;, &#34;Error&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR><TD CLASS="l">2726</TD><TD>                }</TD></TR><TR><TD CLASS="l">2727</TD><TD>                // if an open class defined but no source show an error message</TD></TR><TR CLASS="z"><TD CLASS="l">2728</TD><TD>                else if ((problemSubType == ModelChecker.OPEN_CLASS_BUT_NO_SOURCE_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2729</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;Open classes defined but no source, add a source to the model.&#34;, &#34;Error&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR><TD CLASS="l">2730</TD><TD>                }</TD></TR><TR><TD CLASS="l">2731</TD><TD>                // if there is a station link error show an error message</TD></TR><TR CLASS="z"><TD CLASS="l">2732</TD><TD>                else if ((problemSubType == ModelChecker.STATION_LINK_ERROR) &amp;&amp; (problemType == ModelChecker.ERROR_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2733</TD><TD>                        String stationName = model.getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2734</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;The station &#34; + stationName + &#34; is not forward linked, add a forward link&#34;, &#34;Error&#34;,</TD></TR><TR><TD CLASS="l">2735</TD><TD>                                        JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2736</TD><TD>                } else if ((problemType == ModelChecker.ERROR_PROBLEM) &amp;&amp; (problemSubType == ModelChecker.JOIN_WITHOUT_FORK_ERROR)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2737</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;One or more join found but no fork. Please, remove all join or add a fork&#34;);</TD></TR><TR><TD CLASS="l">2738</TD><TD>                }</TD></TR><TR><TD CLASS="l">2739</TD><TD>                // if it is a reference station error show the class panel</TD></TR><TR><TD CLASS="l">2740</TD><TD>                /*</TD></TR><TR><TD CLASS="l">2741</TD><TD>                 * else if ((problemSubType ==</TD></TR><TR><TD CLASS="l">2742</TD><TD>                 * ModelChecker.OPEN_CLASS_REFERENCE_STATION_ERROR) &amp;&amp; (problemType ==</TD></TR><TR><TD CLASS="l">2743</TD><TD>                 * ModelChecker.ERROR_PROBLEM)) { DialogFactory.getDialog(new</TD></TR><TR><TD CLASS="l">2744</TD><TD>                 * jmodelClassesPanel(model,model),&#34;Manage User Classes&#34;);</TD></TR><TR><TD CLASS="l">2745</TD><TD>                 * model.manageJobs(); //a close class may be added }</TD></TR><TR><TD CLASS="l">2746</TD><TD>                 */</TD></TR><TR><TD CLASS="l">2747</TD><TD>                // used only in JMVA conversion</TD></TR><TR CLASS="z"><TD CLASS="l">2748</TD><TD>                else if ((problemSubType == ModelChecker.BCMP_DIFFERENT_QUEUEING_STRATEGIES_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2749</TD><TD>                        String name = this.getStationDefinition().getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2750</TD><TD>                        int k = JOptionPane</TD></TR><TR><TD CLASS="l">2751</TD><TD>                                        .showConfirmDialog(</TD></TR><TR><TD CLASS="l">2752</TD><TD>                                                        null,</TD></TR><TR><TD CLASS="l">2753</TD><TD>                                                        &#34;According to BCMP theorem hypothesis each station must have the same queue\nstrategy for each class, but different per class queue strategy were found at &#34;</TD></TR><TR><TD CLASS="l">2754</TD><TD>                                                                        + name + &#34;.\nDo you want to edit &#34; + name + &#34; queue strategy?\n\n&#34;, &#34;Mixed queue strategy found&#34;,</TD></TR><TR><TD CLASS="l">2755</TD><TD>                                                        JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2756</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2757</TD><TD>                                StationParameterPanel tempPanel = new StationParameterPanel(model, model, relatedStation);</TD></TR><TR><TD CLASS="l">2758</TD><TD>                                // set the station parameter panel to show the queue section</TD></TR><TR CLASS="z"><TD CLASS="l">2759</TD><TD>                                tempPanel.showQueueSectionPanel();</TD></TR><TR CLASS="z"><TD CLASS="l">2760</TD><TD>                                dialogFactory.getDialog(tempPanel, &#34;Editing &#34; + name + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">2761</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2762</TD><TD>                }</TD></TR><TR><TD CLASS="l">2763</TD><TD>                // used only in JMVA conversion</TD></TR><TR CLASS="z"><TD CLASS="l">2764</TD><TD>                else if ((problemSubType == ModelChecker.BCMP_FCFS_DIFFERENT_SERVICE_TYPES_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2765</TD><TD>                        String name = this.getStationDefinition().getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2766</TD><TD>                        int k = JOptionPane.showConfirmDialog(null,</TD></TR><TR><TD CLASS="l">2767</TD><TD>                                        &#34;According to BCMP theorem hypothesis, a FCFS server must have the same service times for each class,\nbut at &#34; + name</TD></TR><TR><TD CLASS="l">2768</TD><TD>                                                        + &#34; the service strategy is mixed, i.e. both load dependent and independent were found.\nDo you want to edit &#34; + name</TD></TR><TR><TD CLASS="l">2769</TD><TD>                                                        + &#34; service parameters?\n\n&#34;, &#34;Mixed service strategies found&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2770</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2771</TD><TD>                                StationParameterPanel tempPanel = new StationParameterPanel(model, model, relatedStation);</TD></TR><TR><TD CLASS="l">2772</TD><TD>                                // set the station parameter panel to show the queue section</TD></TR><TR CLASS="z"><TD CLASS="l">2773</TD><TD>                                tempPanel.showServiceSectionPanel();</TD></TR><TR CLASS="z"><TD CLASS="l">2774</TD><TD>                                dialogFactory.getDialog(tempPanel, &#34;Editing &#34; + name + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">2775</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2776</TD><TD>                }</TD></TR><TR><TD CLASS="l">2777</TD><TD>                // used only in JMVA conversion</TD></TR><TR CLASS="z"><TD CLASS="l">2778</TD><TD>                else if ((problemSubType == ModelChecker.BCMP_FCFS_EXPONENTIAL_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2779</TD><TD>                        String name = this.getStationDefinition().getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2780</TD><TD>                        int k = JOptionPane.showConfirmDialog(null,</TD></TR><TR><TD CLASS="l">2781</TD><TD>                                        &#34;According to BCMP theorem hypothesis, in a FCFS server all the service time distribution\nmust be exponential, but at &#34; + name</TD></TR><TR><TD CLASS="l">2782</TD><TD>                                                        + &#34; at least one non exponential distribution was found.\nDo you want to edit &#34; + name + &#34; service parameters?\n\n&#34;,</TD></TR><TR><TD CLASS="l">2783</TD><TD>                                        &#34;Non exponential distribution in FCFS server&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2784</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2785</TD><TD>                                StationParameterPanel tempPanel = new StationParameterPanel(model, model, relatedStation);</TD></TR><TR><TD CLASS="l">2786</TD><TD>                                // set the station parameter panel to show the queue section</TD></TR><TR CLASS="z"><TD CLASS="l">2787</TD><TD>                                tempPanel.showServiceSectionPanel();</TD></TR><TR CLASS="z"><TD CLASS="l">2788</TD><TD>                                dialogFactory.getDialog(tempPanel, &#34;Editing &#34; + name + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">2789</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2790</TD><TD>                }</TD></TR><TR><TD CLASS="l">2791</TD><TD>                // used only in JMVA conversion</TD></TR><TR CLASS="z"><TD CLASS="l">2792</TD><TD>                else if ((problemSubType == ModelChecker.BCMP_FCFS_DIFFERENT_SERVICE_TIMES_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2793</TD><TD>                        String name = this.getStationDefinition().getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2794</TD><TD>                        int k = JOptionPane</TD></TR><TR><TD CLASS="l">2795</TD><TD>                                        .showConfirmDialog(</TD></TR><TR><TD CLASS="l">2796</TD><TD>                                                        null,</TD></TR><TR><TD CLASS="l">2797</TD><TD>                                                        &#34;According to BCMP theorem hypothesis, in a FCFS server all the per class service time mean values\nmust be the same. If the service strategies are load dependent the mean value in each range\nhas to be the same for each class.\nDo you want to edit &#34;</TD></TR><TR><TD CLASS="l">2798</TD><TD>                                                                        + name + &#34; service parameters?\n\n&#34;, &#34;Non exponential distribution in FCFS server&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2799</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2800</TD><TD>                                StationParameterPanel tempPanel = new StationParameterPanel(model, model, relatedStation);</TD></TR><TR><TD CLASS="l">2801</TD><TD>                                // set the station parameter panel to show the queue section</TD></TR><TR CLASS="z"><TD CLASS="l">2802</TD><TD>                                tempPanel.showServiceSectionPanel();</TD></TR><TR CLASS="z"><TD CLASS="l">2803</TD><TD>                                dialogFactory.getDialog(tempPanel, &#34;Editing &#34; + name + &#34; Properties...&#34;);</TD></TR><TR><TD CLASS="l">2804</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2805</TD><TD>                }</TD></TR><TR><TD CLASS="l">2806</TD><TD>                // used only for to JMVA conversion, for non Random Routing routing</TD></TR><TR><TD CLASS="l">2807</TD><TD>                // strategy errors</TD></TR><TR CLASS="z"><TD CLASS="l">2808</TD><TD>                else if ((problemType == ModelChecker.WARNING_PROBLEM) &amp;&amp; (problemSubType == ModelChecker.BCMP_NON_STATE_INDEPENDENT_ROUTING_WARNING)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2809</TD><TD>                        int k = JOptionPane</TD></TR><TR><TD CLASS="l">2810</TD><TD>                                        .showConfirmDialog(</TD></TR><TR><TD CLASS="l">2811</TD><TD>                                                        null,</TD></TR><TR><TD CLASS="l">2812</TD><TD>                                                        &#34;Convert all non state independent routing strategies to Random Routing?\n\nAccording to the BCMP theorem the routing probabilities must be independent from the state of the model.\nChoosing ok all non state independent routing strategies inside a station will be converted to Random Routing.\nDo you want to convert all non state independent routing strategies to Random Routing?\n\n&#34;,</TD></TR><TR><TD CLASS="l">2813</TD><TD>                                                        &#34;BCMP hypothesis not verified&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2814</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2815</TD><TD>                                mc.setAllStateDependentRoutingStrategyToRandomRouting();</TD></TR><TR><TD CLASS="l">2816</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2817</TD><TD>                }</TD></TR><TR><TD CLASS="l">2818</TD><TD>                // if there are more than one sink show a warning message</TD></TR><TR CLASS="z"><TD CLASS="l">2819</TD><TD>                else if ((problemSubType == ModelChecker.MORE_THAN_ONE_SINK_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2820</TD><TD>                        JOptionPane</TD></TR><TR><TD CLASS="l">2821</TD><TD>                                        .showMessageDialog(</TD></TR><TR><TD CLASS="l">2822</TD><TD>                                                        null,</TD></TR><TR><TD CLASS="l">2823</TD><TD>                                                        &#34;If more than one sink is reacheable by the same open class the computed throughput may not be accurate.\nPlease check the model before starting simulation.&#34;,</TD></TR><TR><TD CLASS="l">2824</TD><TD>                                                        &#34;Warning&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR><TD CLASS="l">2825</TD><TD>                }</TD></TR><TR><TD CLASS="l">2826</TD><TD>                // if a station (server or delay) is not backward connected show a</TD></TR><TR><TD CLASS="l">2827</TD><TD>                // warning message</TD></TR><TR CLASS="z"><TD CLASS="l">2828</TD><TD>                else if ((problemSubType == ModelChecker.NO_BACKWARD_LINK_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2829</TD><TD>                        String stationName = model.getStationName(relatedStation);</TD></TR><TR CLASS="z"><TD CLASS="l">2830</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;The station &#34; + stationName</TD></TR><TR><TD CLASS="l">2831</TD><TD>                                        + &#34; is not backward linked. Please check the model before starting simulation.&#34;, &#34;Warning&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2832</TD><TD>                } else if ((problemSubType == ModelChecker.PARAMETRIC_ANALYSIS_MODEL_MODIFIED_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2833</TD><TD>                        String message = &#34;Check parametric analysis model?\n\nThe parametric analysis model previously defined had become inconsistent with the \nsimulation model. It will be automatically modified when simulation will be started.\nDo you want to autocorrect and check parametric analysis panel?\n\n&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2834</TD><TD>                        int k = JOptionPane.showConfirmDialog(null, message, &#34;Inconsistent parametric analysis model&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2835</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2836</TD><TD>                                model.getParametricAnalysisModel().checkCorrectness(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2837</TD><TD>                                ParametricAnalysisPanel paPanel = new ParametricAnalysisPanel(model, model, model, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2838</TD><TD>                                dialogFactory.getDialog(paPanel, &#34;Edit what-if analysis parameters&#34;);</TD></TR><TR><TD CLASS="l">2839</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2840</TD><TD>                } else if ((problemSubType == ModelChecker.PARAMETRIC_ANALYSIS_NO_MORE_AVAIBLE_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2841</TD><TD>                        String message = &#34;Parametric analysis was set, but no parametric analysis is now avaible,\nsince the simulation model was changed. It is only possible to execute normal simulation.\nDo you wish to continue anyway?\n\n&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">2842</TD><TD>                        int k = JOptionPane.showConfirmDialog(null, message, &#34;Parametric analysis not avaible&#34;, JOptionPane.WARNING_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2843</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2844</TD><TD>                                model.setParametricAnalysisEnabled(false);</TD></TR><TR CLASS="z"><TD CLASS="l">2845</TD><TD>                                model.setParametricAnalysisModel(null);</TD></TR><TR><TD CLASS="l">2846</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2847</TD><TD>                } else if ((problemSubType == ModelChecker.FORK_WITHOUT_JOIN_WARNING) &amp;&amp; (problemType == ModelChecker.WARNING_PROBLEM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2848</TD><TD>                        JOptionPane.showMessageDialog(null, &#34;A fork was found but no join. Please check the topology&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2849</TD><TD>                } else if ((problemSubType == ModelChecker.EMPTY_BLOCKING_REGION)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2850</TD><TD>                        int k = JOptionPane.showConfirmDialog(null, &#34;Delete empty finite capacity regions?\n&#34;, &#34;Empty finite capacity regions found&#34;,</TD></TR><TR><TD CLASS="l">2851</TD><TD>                                        JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2852</TD><TD>                        if (k == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2853</TD><TD>                                mc.deleteEmptyBlockingRegions();</TD></TR><TR><TD CLASS="l">2854</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2855</TD><TD>                } else if (problemSubType == ModelChecker.PRELOADING_WITH_BLOCKING) {</TD></TR><TR CLASS="z"><TD CLASS="l">2856</TD><TD>                        editSimulationParameters();</TD></TR><TR><TD CLASS="l">2857</TD><TD>                }</TD></TR><TR><TD CLASS="l">2858</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2859</TD><TD>        }</TD></TR><TR><TD CLASS="l">2860</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="90">2861</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">2862</TD><TD>         * Shows the class panel</TD></TR><TR><TD CLASS="l">2863</TD><TD>         */</TD></TR><TR><TD CLASS="l">2864</TD><TD>        public void showClassPanel() {</TD></TR><TR CLASS="z"><TD CLASS="l">2865</TD><TD>                dialogFactory.getDialog(new jmodelClassesPanel(model, model), &#34;Manage User Classes&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2866</TD><TD>        }</TD></TR><TR><TD CLASS="l">2867</TD><TD> </TD></TR><TR><TD CLASS="l">2868</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2869</TD><TD>         * Used to discover if the instance can display simulation animation</TD></TR><TR><TD CLASS="l"><A NAME="67">2870</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">2871</TD><TD>         * @return true if the instance can display simulation animation</TD></TR><TR><TD CLASS="l">2872</TD><TD>         */</TD></TR><TR><TD CLASS="l">2873</TD><TD>        public boolean isAnimationDisplayable() {</TD></TR><TR CLASS="z"><TD CLASS="l">2874</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">2875</TD><TD>        }</TD></TR><TR><TD CLASS="l">2876</TD><TD> </TD></TR><TR><TD CLASS="l">2877</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2878</TD><TD>         * Gets the Dimension of a specified cell</TD></TR><TR><TD CLASS="l"><A NAME="2d">2879</A></TD><TD>         * @param cell</TD></TR><TR><TD CLASS="l">2880</TD><TD>         * @return the cell Dimension</TD></TR><TR><TD CLASS="l">2881</TD><TD>         */</TD></TR><TR><TD CLASS="l">2882</TD><TD>        public Rectangle2D getCellDimension(JmtCell cell) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="93">2883</A></TD><TD>                return GraphConstants.getBounds(cell.getAttributes());</TD></TR><TR><TD CLASS="l">2884</TD><TD>        }</TD></TR><TR><TD CLASS="l">2885</TD><TD> </TD></TR><TR><TD CLASS="l">2886</TD><TD>        public void showHelp() {</TD></TR><TR CLASS="z"><TD CLASS="l">2887</TD><TD>                JHelp helpViewer = null;</TD></TR><TR><TD CLASS="l">2888</TD><TD>                try {</TD></TR><TR><TD CLASS="l">2889</TD><TD>                        // Get the classloader of this class.</TD></TR><TR CLASS="z"><TD CLASS="l">2890</TD><TD>                        ClassLoader cl = this.getClass().getClassLoader();</TD></TR><TR><TD CLASS="l">2891</TD><TD>                        // Use the findHelpSet method of HelpSet to create a URL referencing</TD></TR><TR><TD CLASS="l">2892</TD><TD>                        // the helpset file.</TD></TR><TR CLASS="z"><TD CLASS="l">2893</TD><TD>                        URL url = HelpSet.findHelpSet(cl, &#34;help/jMODEL_en/JSIMgraph.hs&#34;);</TD></TR><TR><TD CLASS="l">2894</TD><TD>                        // Create a new JHelp object with a new HelpSet.</TD></TR><TR CLASS="z"><TD CLASS="l">2895</TD><TD>                        helpViewer = new JHelp(new HelpSet(cl, url));</TD></TR><TR><TD CLASS="l">2896</TD><TD> </TD></TR><TR><TD CLASS="l">2897</TD><TD>                        // Set the initial entry point in the table of contents.</TD></TR><TR><TD CLASS="l">2898</TD><TD>                        // helpViewer.setCurrentID(&#34;&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">2899</TD><TD>                } catch (Exception e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2900</TD><TD>                        e.printStackTrace();</TD></TR><TR CLASS="z"><TD CLASS="l">2901</TD><TD>                        JOptionPane.showMessageDialog(mainWindow, &#34;Sorry, jSIMgraph help is not available&#34;, &#34;Help not found&#34;, JOptionPane.ERROR_MESSAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2902</TD><TD>                        return;</TD></TR><TR CLASS="z"><TD CLASS="l">2903</TD><TD>                }</TD></TR><TR><TD CLASS="l">2904</TD><TD> </TD></TR><TR><TD CLASS="l">2905</TD><TD>                // Create a new frame.</TD></TR><TR CLASS="z"><TD CLASS="l">2906</TD><TD>                JMTFrame frame = new JMTFrame();</TD></TR><TR><TD CLASS="l">2907</TD><TD>                // Set it's size.</TD></TR><TR CLASS="z"><TD CLASS="l">2908</TD><TD>                frame.centerWindow(800, 600);</TD></TR><TR><TD CLASS="l">2909</TD><TD>                // Add the created helpViewer to it.</TD></TR><TR CLASS="z"><TD CLASS="l">2910</TD><TD>                frame.getContentPane().add(helpViewer);</TD></TR><TR><TD CLASS="l">2911</TD><TD>                // Make the frame visible.</TD></TR><TR CLASS="z"><TD CLASS="l">2912</TD><TD>                frame.setVisible(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2913</TD><TD>        }</TD></TR><TR><TD CLASS="l">2914</TD><TD> </TD></TR><TR><TD CLASS="l">2915</TD><TD>        // --- Methods to handle blocking regions - Bertoli Marco</TD></TR><TR><TD CLASS="l">2916</TD><TD>        // -------------------------------------</TD></TR><TR><TD CLASS="l">2917</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6">2918</A></TD><TD>         * Adds given JmtCells to a freshly created blocking station. This method will not modify</TD></TR><TR><TD CLASS="l">2919</TD><TD>         * data structure and is used during load operation</TD></TR><TR><TD CLASS="l">2920</TD><TD>         */</TD></TR><TR><TD CLASS="l">2921</TD><TD>        public void addCellsToBlockingRegion(Object[] cells, Object regionKey) {</TD></TR><TR CLASS="z"><TD CLASS="l">2922</TD><TD>                BlockingRegion bl = new BlockingRegion(this, regionKey);</TD></TR><TR CLASS="z"><TD CLASS="l">2923</TD><TD>                bl.addStations(cells);</TD></TR><TR CLASS="z"><TD CLASS="l">2924</TD><TD>        }</TD></TR><TR><TD CLASS="l">2925</TD><TD> </TD></TR><TR><TD CLASS="l">2926</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="7">2927</A></TD><TD>         * Adds a new Blocking region that contains selected cells,</TD></TR><TR><TD CLASS="l">2928</TD><TD>         * if this doesn't overlap with existing one</TD></TR><TR><TD CLASS="l">2929</TD><TD>         */</TD></TR><TR><TD CLASS="l">2930</TD><TD>        public void addSelectionToNewBlockingRegion() {</TD></TR><TR CLASS="z"><TD CLASS="l">2931</TD><TD>                Object[] cells = graph.getSelectionCells();</TD></TR><TR><TD CLASS="l">2932</TD><TD>                // Data structure to hold all selected stations and their search's key</TD></TR><TR CLASS="z"><TD CLASS="l">2933</TD><TD>                HashMap&lt;Object, Object&gt; stations = new HashMap&lt;Object, Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2934</TD><TD>                boolean canBeAdded = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2935</TD><TD>                Object regionKey = model.addBlockingRegion();</TD></TR><TR CLASS="z"><TD CLASS="l">2936</TD><TD>                for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">2937</TD><TD>                        if (cell instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">2938</TD><TD>                                Object stationKey = ((CellComponent) ((JmtCell) cell).getUserObject()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">2939</TD><TD>                                if (!model.canRegionStationBeAdded(regionKey, stationKey)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2940</TD><TD>                                        canBeAdded = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2941</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2942</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2943</TD><TD>                                        stations.put(cell, stationKey);</TD></TR><TR><TD CLASS="l">2944</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2945</TD><TD>                        } else if (cell instanceof BlockingRegion) {</TD></TR><TR><TD CLASS="l">2946</TD><TD>                                // A blocking region cannot overlap another one</TD></TR><TR CLASS="z"><TD CLASS="l">2947</TD><TD>                                canBeAdded = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2948</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">2949</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2950</TD><TD>                }</TD></TR><TR><TD CLASS="l">2951</TD><TD>                // If blocking region can be added, adds it to graph window, otherwise</TD></TR><TR><TD CLASS="l">2952</TD><TD>                // deletes it</TD></TR><TR CLASS="z"><TD CLASS="l">2953</TD><TD>                if (canBeAdded &amp;&amp; stations.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2954</TD><TD>                        BlockingRegion bl = new BlockingRegion(this, regionKey);</TD></TR><TR CLASS="z"><TD CLASS="l">2955</TD><TD>                        Object[] stationCells = stations.keySet().toArray();</TD></TR><TR CLASS="z"><TD CLASS="l">2956</TD><TD>                        bl.addStations(stationCells);</TD></TR><TR><TD CLASS="l">2957</TD><TD>                        // Adds stations to blocking region into data structure</TD></TR><TR CLASS="z"><TD CLASS="l">2958</TD><TD>                        for (Object stationCell : stationCells) {</TD></TR><TR CLASS="z"><TD CLASS="l">2959</TD><TD>                                model.addRegionStation(regionKey, stations.get(stationCell));</TD></TR><TR><TD CLASS="l">2960</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2961</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2962</TD><TD>                        model.deleteBlockingRegion(regionKey);</TD></TR><TR><TD CLASS="l">2963</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2964</TD><TD>        }</TD></TR><TR><TD CLASS="l">2965</TD><TD> </TD></TR><TR><TD CLASS="l">2966</TD><TD>        /**</TD></TR><TR><TD CLASS="l">2967</TD><TD>         * This method is used to reflect drag in and out a blocking region on data</TD></TR><TR><TD CLASS="l"><A NAME="66">2968</A></TD><TD>         * structure and to move dragged cells to background to use transparency of</TD></TR><TR><TD CLASS="l">2969</TD><TD>         * blocking region over them</TD></TR><TR><TD CLASS="l">2970</TD><TD>         */</TD></TR><TR><TD CLASS="l">2971</TD><TD>        public void handlesBlockingRegionDrag() {</TD></TR><TR CLASS="z"><TD CLASS="l">2972</TD><TD>                Object[] cells = graph.getDescendants(graph.getSelectionCells());</TD></TR><TR><TD CLASS="l">2973</TD><TD>                // Put cells not in a blocking region to back</TD></TR><TR CLASS="z"><TD CLASS="l">2974</TD><TD>                HashSet&lt;Object&gt; putBack = new HashSet&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">2975</TD><TD>                for (Object cell2 : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">2976</TD><TD>                        if (cell2 instanceof JmtCell &amp;&amp; ((JmtCell) cell2).parentChanged()) {</TD></TR><TR><TD CLASS="l">2977</TD><TD>                                // This cell was moved in, out or between blocking regions</TD></TR><TR CLASS="z"><TD CLASS="l">2978</TD><TD>                                JmtCell cell = (JmtCell) cell2;</TD></TR><TR CLASS="z"><TD CLASS="l">2979</TD><TD>                                Object key = ((CellComponent) cell.getUserObject()).getKey();</TD></TR><TR><TD CLASS="l">2980</TD><TD>                                Object oldRegionKey, newRegionKey;</TD></TR><TR CLASS="z"><TD CLASS="l">2981</TD><TD>                                if (!(cell.getParent() instanceof BlockingRegion)) {</TD></TR><TR><TD CLASS="l">2982</TD><TD>                                        // Object removed from blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">2983</TD><TD>                                        putBack.add(cell2);</TD></TR><TR CLASS="z"><TD CLASS="l">2984</TD><TD>                                        oldRegionKey = ((BlockingRegion) cell.getPrevParent()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">2985</TD><TD>                                        model.removeRegionStation(oldRegionKey, key);</TD></TR><TR><TD CLASS="l">2986</TD><TD>                                        // If region is empty, removes region too</TD></TR><TR CLASS="z"><TD CLASS="l">2987</TD><TD>                                        if (model.getBlockingRegionStations(oldRegionKey).size() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2988</TD><TD>                                                model.deleteBlockingRegion(oldRegionKey);</TD></TR><TR><TD CLASS="l">2989</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2990</TD><TD>                                        // Allow adding of removed objects to a new blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">2991</TD><TD>                                        enableAddBlockingRegion(true);</TD></TR><TR CLASS="z"><TD CLASS="l">2992</TD><TD>                                } else if (cell.getPrevParent() instanceof BlockingRegion) {</TD></TR><TR><TD CLASS="l">2993</TD><TD>                                        // Object changed blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">2994</TD><TD>                                        oldRegionKey = ((BlockingRegion) cell.getPrevParent()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">2995</TD><TD>                                        model.removeRegionStation(oldRegionKey, key);</TD></TR><TR><TD CLASS="l">2996</TD><TD>                                        // If region is empty, removes region too</TD></TR><TR CLASS="z"><TD CLASS="l">2997</TD><TD>                                        if (model.getBlockingRegionStations(oldRegionKey).size() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2998</TD><TD>                                                model.deleteBlockingRegion(oldRegionKey);</TD></TR><TR><TD CLASS="l">2999</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3000</TD><TD>                                        newRegionKey = ((BlockingRegion) cell.getParent()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">3001</TD><TD>                                        model.addRegionStation(newRegionKey, key);</TD></TR><TR><TD CLASS="l">3002</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">3003</TD><TD>                                        // Object added to a blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">3004</TD><TD>                                        newRegionKey = ((BlockingRegion) cell.getParent()).getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">3005</TD><TD>                                        if (!model.addRegionStation(newRegionKey, key)) {</TD></TR><TR><TD CLASS="l">3006</TD><TD>                                                // object cannot be added to blocking region (for</TD></TR><TR><TD CLASS="l">3007</TD><TD>                                                // example it's a source)</TD></TR><TR CLASS="z"><TD CLASS="l">3008</TD><TD>                                                cell.removeFromParent();</TD></TR><TR CLASS="z"><TD CLASS="l">3009</TD><TD>                                                graph.getModel().insert(new Object[] { cell }, null, null, null, null);</TD></TR><TR CLASS="z"><TD CLASS="l">3010</TD><TD>                                                putBack.add(cell);</TD></TR><TR><TD CLASS="l">3011</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3012</TD><TD>                                        // Doesn't allow adding of selected objects to a new</TD></TR><TR><TD CLASS="l">3013</TD><TD>                                        // blocking region</TD></TR><TR CLASS="z"><TD CLASS="l">3014</TD><TD>                                        enableAddBlockingRegion(false);</TD></TR><TR><TD CLASS="l">3015</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3016</TD><TD>                                // Resets parent for this cell</TD></TR><TR CLASS="z"><TD CLASS="l">3017</TD><TD>                                cell.resetParent();</TD></TR><TR CLASS="z"><TD CLASS="l">3018</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3019</TD><TD>                        // Avoid insertion of a blocking region in an other</TD></TR><TR CLASS="z"><TD CLASS="l">3020</TD><TD>                        else if (cell2 instanceof BlockingRegion) {</TD></TR><TR CLASS="z"><TD CLASS="l">3021</TD><TD>                                BlockingRegion region = (BlockingRegion) cell2;</TD></TR><TR CLASS="z"><TD CLASS="l">3022</TD><TD>                                if (region.getParent() != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3023</TD><TD>                                        region.removeFromParent();</TD></TR><TR CLASS="z"><TD CLASS="l">3024</TD><TD>                                        graph.getModel().insert(new Object[] { region }, null, null, null, null);</TD></TR><TR><TD CLASS="l">3025</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3026</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3027</TD><TD>                }</TD></TR><TR><TD CLASS="l">3028</TD><TD>                // Puts cells removed from blocking regiont on background</TD></TR><TR CLASS="z"><TD CLASS="l">3029</TD><TD>                graph.getModel().toBack(putBack.toArray());</TD></TR><TR CLASS="z"><TD CLASS="l">3030</TD><TD>        }</TD></TR><TR><TD CLASS="l">3031</TD><TD> </TD></TR><TR><TD CLASS="l">3032</TD><TD>        // --------------------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">3033</TD><TD>        // ___________________GIUSEPPE DE CICCO &amp; FABIO</TD></TR><TR><TD CLASS="l">3034</TD><TD>        // GRANARA____________________________</TD></TR><TR><TD CLASS="l">3035</TD><TD> </TD></TR><TR><TD CLASS="l">3036</TD><TD>        /**</TD></TR><TR><TD CLASS="l">3037</TD><TD>         * Method that rotate components</TD></TR><TR><TD CLASS="l"><A NAME="7d">3038</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">3039</TD><TD>         * author Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3040</TD><TD>         */</TD></TR><TR><TD CLASS="l">3041</TD><TD>        public void rotateComponent(Object[] cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">3042</TD><TD>                if (cells == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3043</TD><TD>                        cells = graph.getSelectionCells();</TD></TR><TR><TD CLASS="l">3044</TD><TD>                }</TD></TR><TR><TD CLASS="l">3045</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3046</TD><TD>                for (Object cell : cells) {</TD></TR><TR><TD CLASS="l">3047</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3048</TD><TD>                        if ((cell instanceof BlockingRegion) || cell instanceof JmtEdge) {</TD></TR><TR CLASS="z"><TD CLASS="l">3049</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">3050</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3051</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3052</TD><TD>                        JmtCell current = (JmtCell) cell;</TD></TR><TR><TD CLASS="l">3053</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3054</TD><TD>                        Map&lt;Object, Map&gt; nested = new Hashtable&lt;Object, Map&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">3055</TD><TD>                        Map attributeMap = new Hashtable();</TD></TR><TR><TD CLASS="l">3056</TD><TD>                        ImageIcon icon;</TD></TR><TR CLASS="z"><TD CLASS="l">3057</TD><TD>                        if (current.isLeftInputCell()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3058</TD><TD>                                icon = JMTImageLoader.loadImage(current.getIcon(), ImageLoader.MODIFIER_MIRROR);</TD></TR><TR><TD CLASS="l">3059</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3060</TD><TD>                                icon = JMTImageLoader.loadImage(current.getIcon());</TD></TR><TR><TD CLASS="l">3061</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3062</TD><TD>                        GraphConstants.setIcon(attributeMap, icon);</TD></TR><TR><TD CLASS="l">3063</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3064</TD><TD>                        nested.put(cell, attributeMap);</TD></TR><TR CLASS="z"><TD CLASS="l">3065</TD><TD>                        current.setLeftInputCell(!current.isLeftInputCell());</TD></TR><TR CLASS="z"><TD CLASS="l">3066</TD><TD>                        current.updatePortPositions(nested, icon, current.getSize(graph));</TD></TR><TR><TD CLASS="l">3067</TD><TD>                        // _____DA INSERIRE QUI L AGGIORNAMENTO DELLA DECORAZIONE DELLA</TD></TR><TR><TD CLASS="l">3068</TD><TD>                        // FRECCIA______</TD></TR><TR CLASS="z"><TD CLASS="l">3069</TD><TD>                        graph.getGraphLayoutCache().edit(nested);</TD></TR><TR><TD CLASS="l">3070</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3071</TD><TD>                avoidOverlappingCell(cells);</TD></TR><TR CLASS="z"><TD CLASS="l">3072</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="4f">3073</A></TD><TD> </TD></TR><TR><TD CLASS="l">3074</TD><TD>        // Giuseppe De Cicco and Fabio Granara</TD></TR><TR><TD CLASS="l">3075</TD><TD>        public AbstractJmodelAction getRotate() {</TD></TR><TR><TD CLASS="l">3076</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3077</TD><TD>                return actionRotate;</TD></TR><TR><TD CLASS="l"><A NAME="6e">3078</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3079</TD><TD> </TD></TR><TR><TD CLASS="l">3080</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3081</TD><TD>        public boolean isInGroup(Object cell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3082</TD><TD>                Object[] celgru = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3083</TD><TD>                Object[] celless = null;</TD></TR><TR><TD CLASS="l">3084</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3085</TD><TD>                cells = graph.getDescendants(graph.getRoots());</TD></TR><TR CLASS="z"><TD CLASS="l">3086</TD><TD>                if (cells.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3087</TD><TD>                        for (Object cell2 : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">3088</TD><TD>                                if (cell2 instanceof BlockingRegion) {</TD></TR><TR CLASS="z"><TD CLASS="l">3089</TD><TD>                                        celgru = new Object[1];</TD></TR><TR CLASS="z"><TD CLASS="l">3090</TD><TD>                                        celgru[0] = cell2;</TD></TR><TR><TD CLASS="l">3091</TD><TD>                                        // celle presenti nel blocking region incluse port e regione</TD></TR><TR><TD CLASS="l">3092</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3093</TD><TD>                                        celless = graph.getDescendants(celgru);</TD></TR><TR CLASS="z"><TD CLASS="l">3094</TD><TD>                                        for (Object celles : celless) {</TD></TR><TR CLASS="z"><TD CLASS="l">3095</TD><TD>                                                if (celles.equals(cell)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3096</TD><TD>                                                        return true;</TD></TR><TR><TD CLASS="l">3097</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3098</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3099</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3100</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3101</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3102</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3103</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="a">3104</A></TD><TD> </TD></TR><TR><TD CLASS="l">3105</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3106</TD><TD>        public void avoidOverlappingCell(Object[] cells2) {</TD></TR><TR><TD CLASS="l">3107</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3108</TD><TD>                overlapping.avoidOverlappingCell(cells2);</TD></TR><TR CLASS="z"><TD CLASS="l">3109</TD><TD>                graphRepaint();</TD></TR><TR CLASS="z"><TD CLASS="l">3110</TD><TD>                graph.getGraphLayoutCache().reload();</TD></TR><TR CLASS="z"><TD CLASS="l">3111</TD><TD>        }</TD></TR><TR><TD CLASS="l">3112</TD><TD> </TD></TR><TR><TD CLASS="l">3113</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR CLASS="z"><TD CLASS="l">3114</TD><TD>        int e = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">3115</TD><TD>        int x = 25;</TD></TR><TR CLASS="z"><TD CLASS="l">3116</TD><TD>        int y = 90;</TD></TR><TR CLASS="z"><TD CLASS="l">3117</TD><TD>        int widthMax = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3118</TD><TD>        int heightMax = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3119</TD><TD>        private boolean flag = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3120</TD><TD>        private boolean flag1 = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3121</TD><TD>        private boolean flag2 = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3122</TD><TD>        private boolean inRepositionSons = false;</TD></TR><TR><TD CLASS="l">3123</TD><TD> </TD></TR><TR><TD CLASS="l">3124</TD><TD>        public void adjustGraph() {</TD></TR><TR><TD CLASS="l">3125</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="8">3126</A></TD><TD>                Object[] cells;</TD></TR><TR><TD CLASS="l">3127</TD><TD> </TD></TR><TR><TD CLASS="l">3128</TD><TD>                // queste variabili mi servono per capire quali sono le celle che hanno</TD></TR><TR><TD CLASS="l">3129</TD><TD>                // meno link in ingresso per iniziare l'algoritmo</TD></TR><TR CLASS="z"><TD CLASS="l">3130</TD><TD>                int inMin = 100;</TD></TR><TR CLASS="z"><TD CLASS="l">3131</TD><TD>                int inMax = 0;</TD></TR><TR><TD CLASS="l">3132</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3133</TD><TD>                List&lt;Object&gt; min = new ArrayList&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">3134</TD><TD>                List&lt;Object&gt; max = new ArrayList&lt;Object&gt;();</TD></TR><TR><TD CLASS="l">3135</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3136</TD><TD>                cells = graph.getDescendants(graph.getRoots());</TD></TR><TR CLASS="z"><TD CLASS="l">3137</TD><TD>                for (int i = 0; i &lt; cells.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3138</TD><TD>                        if (cells[i] instanceof JmtCell) {</TD></TR><TR><TD CLASS="l">3139</TD><TD>                                // System.out.println(&#34;scandendo cella x cella: &#34; +</TD></TR><TR><TD CLASS="l">3140</TD><TD>                                // (JmtCell)cells[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">3141</TD><TD>                                Rectangle bounds = GraphConstants.getBounds(((JmtCell) cells[i]).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3142</TD><TD>                                if (bounds.getWidth() &gt; widthMax) {</TD></TR><TR CLASS="z"><TD CLASS="l">3143</TD><TD>                                        widthMax = (int) bounds.getWidth();</TD></TR><TR><TD CLASS="l">3144</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3145</TD><TD>                                if (bounds.getHeight() &gt; heightMax) {</TD></TR><TR CLASS="z"><TD CLASS="l">3146</TD><TD>                                        heightMax = (int) bounds.getHeight();</TD></TR><TR><TD CLASS="l">3147</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3148</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3149</TD><TD>                                if (!((JmtCell) cells[i]).isLeftInputCell()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3150</TD><TD>                                        rotateComponent(new Object[] { cells[i] });</TD></TR><TR><TD CLASS="l">3151</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3152</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3153</TD><TD>                }</TD></TR><TR><TD CLASS="l">3154</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3155</TD><TD>                boolean sourceIn = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3156</TD><TD>                for (int i = 0; i &lt; cells.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3157</TD><TD>                        if (cells[i] instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3158</TD><TD>                                ((JmtCell) cells[i]).in = (DefaultGraphModel.getIncomingEdges(graph.getModel(), cells[i])).length;</TD></TR><TR><TD CLASS="l">3159</TD><TD> </TD></TR><TR><TD CLASS="l">3160</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3161</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3162</TD><TD>                        if (cells[i] instanceof JmtCell) {</TD></TR><TR><TD CLASS="l">3163</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3164</TD><TD>                                if (((JmtCell) cells[i]).in &lt; inMin) {</TD></TR><TR CLASS="z"><TD CLASS="l">3165</TD><TD>                                        inMin = ((JmtCell) cells[i]).in;</TD></TR><TR><TD CLASS="l">3166</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3167</TD><TD>                                if (((JmtCell) cells[i]).in &gt; inMax) {</TD></TR><TR CLASS="z"><TD CLASS="l">3168</TD><TD>                                        inMax = ((JmtCell) cells[i]).in;</TD></TR><TR><TD CLASS="l">3169</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3170</TD><TD> </TD></TR><TR><TD CLASS="l">3171</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3172</TD><TD> </TD></TR><TR><TD CLASS="l">3173</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3174</TD><TD>                boolean projectClose = true;</TD></TR><TR CLASS="z"><TD CLASS="l">3175</TD><TD>                for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">3176</TD><TD>                        if (cell instanceof JmtCell &amp;&amp; !sourceIn) {</TD></TR><TR CLASS="z"><TD CLASS="l">3177</TD><TD>                                if (((JmtCell) cell).in == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3178</TD><TD>                                        projectClose = false;</TD></TR><TR><TD CLASS="l">3179</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3180</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3181</TD><TD>                }</TD></TR><TR><TD CLASS="l">3182</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3183</TD><TD>                boolean serverWithZeroIn = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3184</TD><TD>                for (int i = 0; i &lt; cells.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3185</TD><TD>                        if (cells[i] instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3186</TD><TD>                                if (((JmtCell) cells[i]).in == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3187</TD><TD>                                        serverWithZeroIn = true;</TD></TR><TR><TD CLASS="l">3188</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3189</TD><TD>                                if (!min.contains(cells[i])) {</TD></TR><TR CLASS="z"><TD CLASS="l">3190</TD><TD>                                        if (((JmtCell) cells[i]).in == inMin) {</TD></TR><TR CLASS="z"><TD CLASS="l">3191</TD><TD>                                                min.add(cells[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">3192</TD><TD>                                        } else if (((JmtCell) cells[i]).in == inMax) {</TD></TR><TR CLASS="z"><TD CLASS="l">3193</TD><TD>                                                max.add(cells[i]);</TD></TR><TR><TD CLASS="l">3194</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3195</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3196</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3197</TD><TD>                }</TD></TR><TR><TD CLASS="l">3198</TD><TD>                // Questa parte gestisce quando abbiamo un progetto close</TD></TR><TR CLASS="z"><TD CLASS="l">3199</TD><TD>                if (!sourceIn &amp;&amp; projectClose &amp;&amp; !serverWithZeroIn) {</TD></TR><TR><TD CLASS="l">3200</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3201</TD><TD>                        int tmpMax = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3202</TD><TD>                        JmtCell tmpCell = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3203</TD><TD>                        for (Object cell : cells) {</TD></TR><TR CLASS="z"><TD CLASS="l">3204</TD><TD>                                if (cell instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3205</TD><TD>                                        int tmpIn = (((JmtCell) cell).in);</TD></TR><TR CLASS="z"><TD CLASS="l">3206</TD><TD>                                        if (tmpMax &lt; tmpIn) {</TD></TR><TR CLASS="z"><TD CLASS="l">3207</TD><TD>                                                tmpMax = tmpIn;</TD></TR><TR CLASS="z"><TD CLASS="l">3208</TD><TD>                                                tmpCell = ((JmtCell) cell);</TD></TR><TR><TD CLASS="l">3209</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3210</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3211</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3212</TD><TD>                        min = new ArrayList&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">3213</TD><TD>                        min.add(tmpCell);</TD></TR><TR><TD CLASS="l">3214</TD><TD> </TD></TR><TR><TD CLASS="l">3215</TD><TD>                }</TD></TR><TR><TD CLASS="l">3216</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3217</TD><TD>                int widthMaxMin = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3218</TD><TD>                for (int w = 0; w &lt; min.size(); w++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3219</TD><TD>                        Rectangle bounds = GraphConstants.getBounds(((JmtCell) min.get(w)).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3220</TD><TD>                        if (bounds.getWidth() &gt; widthMaxMin) {</TD></TR><TR CLASS="z"><TD CLASS="l">3221</TD><TD>                                widthMaxMin = (int) bounds.getWidth();</TD></TR><TR><TD CLASS="l">3222</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3223</TD><TD>                }</TD></TR><TR><TD CLASS="l">3224</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3225</TD><TD>                for (int q = 0; q &lt; min.size(); q++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3226</TD><TD>                        Rectangle bounds = GraphConstants.getBounds(((JmtCell) min.get(q)).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3227</TD><TD>                        x = widthMaxMin / 2 + 25 - (int) (bounds.getWidth() / 2);</TD></TR><TR CLASS="z"><TD CLASS="l">3228</TD><TD>                        searchNext((JmtCell) min.get(q));</TD></TR><TR><TD CLASS="l">3229</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3230</TD><TD>                        e += ((JmtCell) min.get(q)).sons;</TD></TR><TR><TD CLASS="l">3231</TD><TD> </TD></TR><TR><TD CLASS="l">3232</TD><TD>                        // x = 4 + widthMax/2;</TD></TR><TR><TD CLASS="l">3233</TD><TD>                        // w=w+10;</TD></TR><TR CLASS="z"><TD CLASS="l">3234</TD><TD>                        flag1 = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3235</TD><TD>                        flag2 = false;</TD></TR><TR><TD CLASS="l">3236</TD><TD>                }</TD></TR><TR><TD CLASS="l">3237</TD><TD> </TD></TR><TR><TD CLASS="l">3238</TD><TD>                // controllo</TD></TR><TR CLASS="z"><TD CLASS="l">3239</TD><TD>                min = new ArrayList&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">3240</TD><TD>                for (int w2 = 0; w2 &lt; cells.length; w2++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3241</TD><TD>                        if (cells[w2] instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3242</TD><TD>                                if (!((JmtCell) cells[w2]).seen) {</TD></TR><TR><TD CLASS="l">3243</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3244</TD><TD>                                        min.add(cells[w2]);</TD></TR><TR><TD CLASS="l">3245</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3246</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3247</TD><TD> </TD></TR><TR><TD CLASS="l">3248</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3249</TD><TD>                flag1 = false;</TD></TR><TR><TD CLASS="l">3250</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3251</TD><TD>                for (int q = 0; q &lt; min.size(); q++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3252</TD><TD>                        searchNext((JmtCell) min.get(q));</TD></TR><TR CLASS="z"><TD CLASS="l">3253</TD><TD>                        flag1 = false;</TD></TR><TR><TD CLASS="l">3254</TD><TD> </TD></TR><TR><TD CLASS="l">3255</TD><TD>                }</TD></TR><TR><TD CLASS="l">3256</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3257</TD><TD>                flag1 = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3258</TD><TD>                flag2 = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3259</TD><TD>                e = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">3260</TD><TD>                x = 25;</TD></TR><TR CLASS="z"><TD CLASS="l">3261</TD><TD>                y = 90;</TD></TR><TR CLASS="z"><TD CLASS="l">3262</TD><TD>                widthMax = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3263</TD><TD>                heightMax = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3264</TD><TD>                for (int z = 0; z &lt; cells.length; z++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3265</TD><TD>                        if (cells[z] instanceof JmtCell) {</TD></TR><TR CLASS="z"><TD CLASS="l">3266</TD><TD>                                ((JmtCell) cells[z]).sons = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">3267</TD><TD>                                ((JmtCell) cells[z]).seen = false;</TD></TR><TR><TD CLASS="l">3268</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3269</TD><TD>                }</TD></TR><TR><TD CLASS="l">3270</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3271</TD><TD>                graphRepaint();</TD></TR><TR CLASS="z"><TD CLASS="l">3272</TD><TD>                graph.getGraphLayoutCache().reload();</TD></TR><TR CLASS="z"><TD CLASS="l">3273</TD><TD>                avoidOverlappingCell(cells);</TD></TR><TR><TD CLASS="l">3274</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="80">3275</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3276</TD><TD> </TD></TR><TR><TD CLASS="l">3277</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3278</TD><TD>        private int searchNext(JmtCell prev) {</TD></TR><TR CLASS="z"><TD CLASS="l">3279</TD><TD>                Rectangle boundspadre = GraphConstants.getBounds((prev).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3280</TD><TD>                Object[] listEdges = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3281</TD><TD>                GraphModel graphmodel = graph.getModel();</TD></TR><TR CLASS="z"><TD CLASS="l">3282</TD><TD>                List&lt;Object&gt; next = new ArrayList&lt;Object&gt;();</TD></TR><TR><TD CLASS="l">3283</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3284</TD><TD>                if (flag1 == false &amp;&amp; prev.seen == false) {</TD></TR><TR><TD CLASS="l">3285</TD><TD> </TD></TR><TR><TD CLASS="l">3286</TD><TD>                        // Rectangle bounds =</TD></TR><TR><TD CLASS="l">3287</TD><TD>                        // GraphConstants.getBounds(((JmtCell)prev).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3288</TD><TD>                        if (!flag2) {</TD></TR><TR CLASS="z"><TD CLASS="l">3289</TD><TD>                                boundspadre.setLocation(x, y + ((e + 1) * (42 + heightMax)) - (int) (boundspadre.getHeight() / 2) + 30);</TD></TR><TR><TD CLASS="l">3290</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3291</TD><TD>                                boundspadre.setLocation(x - (int) (boundspadre.getWidth() / 2), y + ((e + 1) * (42 + heightMax))</TD></TR><TR><TD CLASS="l">3292</TD><TD>                                                - (int) (boundspadre.getHeight() / 2) + 30);</TD></TR><TR><TD CLASS="l">3293</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3294</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3295</TD><TD>                        GraphConstants.setBounds(prev.getAttributes(), boundspadre);</TD></TR><TR CLASS="z"><TD CLASS="l">3296</TD><TD>                        x = (int) boundspadre.getCenterX() + widthMax + 50;</TD></TR><TR CLASS="z"><TD CLASS="l">3297</TD><TD>                        prev.seen = true;</TD></TR><TR CLASS="z"><TD CLASS="l">3298</TD><TD>                        flag2 = true;</TD></TR><TR><TD CLASS="l">3299</TD><TD>                }</TD></TR><TR><TD CLASS="l">3300</TD><TD> </TD></TR><TR><TD CLASS="l">3301</TD><TD>                // inserisco tutti gli archi uscenti e entranti di min.get(j) in</TD></TR><TR><TD CLASS="l">3302</TD><TD>                // listEdges</TD></TR><TR CLASS="z"><TD CLASS="l">3303</TD><TD>                listEdges = DefaultGraphModel.getOutgoingEdges(graphmodel, prev);</TD></TR><TR CLASS="z"><TD CLASS="l">3304</TD><TD>                Vector&lt;Object&gt; listEdgestmp = new Vector&lt;Object&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">3305</TD><TD>                for (Object listEdge : listEdges) {</TD></TR><TR CLASS="z"><TD CLASS="l">3306</TD><TD>                        JmtCell qq = (JmtCell) (graphmodel.getParent(graphmodel.getTarget(listEdge)));</TD></TR><TR CLASS="z"><TD CLASS="l">3307</TD><TD>                        if (!(qq).seen) {</TD></TR><TR CLASS="z"><TD CLASS="l">3308</TD><TD>                                listEdgestmp.add(listEdge);</TD></TR><TR><TD CLASS="l">3309</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3310</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3311</TD><TD>                listEdges = listEdgestmp.toArray();</TD></TR><TR><TD CLASS="l">3312</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3313</TD><TD>                int numTarget = listEdges.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3314</TD><TD>                if (numTarget == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3315</TD><TD>                        return 1;</TD></TR><TR><TD CLASS="l">3316</TD><TD>                }</TD></TR><TR><TD CLASS="l">3317</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3318</TD><TD>                for (int k = 0; k &lt; numTarget; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3319</TD><TD>                        next.add((graphmodel.getParent(graphmodel.getTarget(listEdges[k]))));</TD></TR><TR><TD CLASS="l">3320</TD><TD>                }</TD></TR><TR><TD CLASS="l">3321</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3322</TD><TD>                int j = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">3323</TD><TD>                if (inRepositionSons == false &amp;&amp; ((JmtCell) next.get(0)).seen == false) {</TD></TR><TR CLASS="z"><TD CLASS="l">3324</TD><TD>                        j = searchNext((JmtCell) next.get(0));</TD></TR><TR CLASS="z"><TD CLASS="l">3325</TD><TD>                } else if (inRepositionSons == true &amp;&amp; ((JmtCell) next.get(0)).seen == false) {</TD></TR><TR><TD CLASS="l">3326</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3327</TD><TD>                        Rectangle bounds = GraphConstants.getBounds(((JmtCell) next.get(0)).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3328</TD><TD>                        bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2), (int) boundspadre.getCenterY()</TD></TR><TR><TD CLASS="l">3329</TD><TD>                                        - (int) (bounds.getHeight() / 2));</TD></TR><TR CLASS="z"><TD CLASS="l">3330</TD><TD>                        GraphConstants.setBounds(((JmtCell) next.get(0)).getAttributes(), bounds);</TD></TR><TR><TD CLASS="l">3331</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3332</TD><TD>                        ((JmtCell) next.get(0)).seen = true;</TD></TR><TR CLASS="z"><TD CLASS="l">3333</TD><TD>                        j = searchNext((JmtCell) next.get(0));</TD></TR><TR><TD CLASS="l">3334</TD><TD>                }</TD></TR><TR><TD CLASS="l">3335</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3336</TD><TD>                if (numTarget &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3337</TD><TD>                        if (!flag) {</TD></TR><TR CLASS="z"><TD CLASS="l">3338</TD><TD>                                repositionSons(prev, next, j - 1, 1);</TD></TR><TR><TD CLASS="l">3339</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3340</TD><TD>                                repositionSons(prev, next, -1, 0);</TD></TR><TR><TD CLASS="l">3341</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3342</TD><TD>                        flag = false;</TD></TR><TR><TD CLASS="l">3343</TD><TD>                }</TD></TR><TR><TD CLASS="l">3344</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3345</TD><TD>                (prev).sons = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3346</TD><TD>                for (int w = 0; w &lt; numTarget; w++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3347</TD><TD>                        prev.sons += ((JmtCell) next.get(w)).sons;</TD></TR><TR><TD CLASS="l">3348</TD><TD>                }</TD></TR><TR><TD CLASS="l">3349</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3350</TD><TD>                return prev.sons;</TD></TR><TR><TD CLASS="l"><A NAME="7b">3351</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3352</TD><TD> </TD></TR><TR><TD CLASS="l">3353</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3354</TD><TD>        private void repositionSons(JmtCell padre, List&lt;Object&gt; sons, int numero, int cont) {</TD></TR><TR CLASS="z"><TD CLASS="l">3355</TD><TD>                inRepositionSons = true;</TD></TR><TR CLASS="z"><TD CLASS="l">3356</TD><TD>                Object[] listEdges = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3357</TD><TD>                GraphModel graphmodel = graph.getModel();</TD></TR><TR><TD CLASS="l">3358</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3359</TD><TD>                flag1 = true;</TD></TR><TR><TD CLASS="l">3360</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3361</TD><TD>                int j = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3362</TD><TD>                Rectangle boundspadre = GraphConstants.getBounds(padre.getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3363</TD><TD>                int w = boundspadre.y + ((heightMax + 35) * (numero + 1)) - 38;</TD></TR><TR><TD CLASS="l">3364</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3365</TD><TD>                for (int i = cont; i &lt; sons.size(); i++) {</TD></TR><TR><TD CLASS="l">3366</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3367</TD><TD>                        if (((JmtCell) sons.get(i)).seen == false) {</TD></TR><TR><TD CLASS="l">3368</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3369</TD><TD>                                Rectangle bounds = GraphConstants.getBounds(((JmtCell) sons.get(i)).getAttributes()).getBounds();</TD></TR><TR CLASS="z"><TD CLASS="l">3370</TD><TD>                                bounds.setLocation((int) (boundspadre.getCenterX()) + widthMax + 50 - (int) (bounds.getWidth() / 2), w</TD></TR><TR><TD CLASS="l">3371</TD><TD>                                                - (int) (bounds.getHeight() / 2) + 80);</TD></TR><TR><TD CLASS="l">3372</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3373</TD><TD>                                GraphConstants.setBounds(((JmtCell) sons.get(i)).getAttributes(), bounds);</TD></TR><TR CLASS="z"><TD CLASS="l">3374</TD><TD>                                ((JmtCell) sons.get(i)).seen = true;</TD></TR><TR><TD CLASS="l">3375</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3376</TD><TD>                                listEdges = DefaultGraphModel.getOutgoingEdges(graphmodel, sons.get(i));</TD></TR><TR><TD CLASS="l">3377</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3378</TD><TD>                                if (listEdges.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3379</TD><TD>                                        flag = true;</TD></TR><TR><TD CLASS="l">3380</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3381</TD><TD>                                        j = searchNext((JmtCell) sons.get(i));</TD></TR><TR CLASS="z"><TD CLASS="l">3382</TD><TD>                                        inRepositionSons = true;</TD></TR><TR><TD CLASS="l">3383</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3384</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3385</TD><TD>                                if (j &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3386</TD><TD>                                        j = j - 1;</TD></TR><TR><TD CLASS="l">3387</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3388</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3389</TD><TD>                                listEdges = null;</TD></TR><TR><TD CLASS="l">3390</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3391</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3392</TD><TD>                        w = w + (heightMax + ((heightMax + 15) * j) + 30);</TD></TR><TR CLASS="z"><TD CLASS="l">3393</TD><TD>                        j = 0;</TD></TR><TR><TD CLASS="l">3394</TD><TD>                }</TD></TR><TR><TD CLASS="l">3395</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8a">3396</A></TD><TD>                inRepositionSons = false;</TD></TR><TR CLASS="z"><TD CLASS="l">3397</TD><TD>        }</TD></TR><TR><TD CLASS="l">3398</TD><TD> </TD></TR><TR><TD CLASS="l">3399</TD><TD>        public void setIsReleased(boolean state) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="42">3400</A></TD><TD>                isReleased = state;</TD></TR><TR CLASS="z"><TD CLASS="l">3401</TD><TD>        }</TD></TR><TR><TD CLASS="l">3402</TD><TD> </TD></TR><TR><TD CLASS="l">3403</TD><TD>        public boolean getIsReleased() {</TD></TR><TR CLASS="z"><TD CLASS="l">3404</TD><TD>                return isReleased;</TD></TR><TR><TD CLASS="l"><A NAME="a1">3405</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3406</TD><TD> </TD></TR><TR><TD CLASS="l">3407</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3408</TD><TD>        public void zoomIn() {</TD></TR><TR CLASS="z"><TD CLASS="l">3409</TD><TD>                graph.setScale(graph.getScale() * 1.25);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a2">3410</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3411</TD><TD> </TD></TR><TR><TD CLASS="l">3412</TD><TD>        // Giuseppe De Cicco &amp; Fabio Granara</TD></TR><TR><TD CLASS="l">3413</TD><TD>        public void zoomOut() {</TD></TR><TR CLASS="z"><TD CLASS="l">3414</TD><TD>                graph.setScale(graph.getScale() / 1.25);</TD></TR><TR CLASS="z"><TD CLASS="l">3415</TD><TD>        }</TD></TR><TR><TD CLASS="l">3416</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="4d.html">jmt.gui.jmodel.controller</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>