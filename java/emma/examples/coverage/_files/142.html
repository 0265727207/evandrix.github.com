<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Nov 08 17:03:51 GMT 2011)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1f.html">jmt.engine.math</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Sfun.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Sfun.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/2028)</TD><TD CLASS="h">0%   (0/234)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Sfun</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/2028)</TD><TD CLASS="h">0%   (0/234)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/834)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">Sfun (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#3">acosh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">asinh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#5">atanh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">cosh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#7">cot (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/181)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">csevl (double, double []): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#9">dlnrel (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">erf (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#b">erfc (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/119)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">fact (int): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#d">gamma (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/162)</TD><TD CLASS="h">0%   (0/35)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">log10 (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#f">logBeta (double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/116)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">logGamma (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/70)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#11">r9lgmc (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">sign (double, double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#13">sinh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">tanh (double): double</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/12)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>package jmt.engine.math;</TD></TR><TR><TD CLASS="l">2</TD><TD> </TD></TR><TR><TD CLASS="l">3</TD><TD>/*</TD></TR><TR><TD CLASS="l">4</TD><TD> * -------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">5</TD><TD> *        $Id: Sfun.java,v 1.1.1.1 2005/06/06 07:43:35 Administrator Exp $</TD></TR><TR><TD CLASS="l">6</TD><TD> * -------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">7</TD><TD> * Copyright (c) 1997 - 1998 by Visual Numerics, Inc. All rights reserved.</TD></TR><TR><TD CLASS="l">8</TD><TD> *</TD></TR><TR><TD CLASS="l">9</TD><TD> * Permission to use, copy, modify, and distribute this software is freely</TD></TR><TR><TD CLASS="l">10</TD><TD> * granted by Visual Numerics, Inc., provided that the copyright notice</TD></TR><TR><TD CLASS="l">11</TD><TD> * above and the following warranty disclaimer are preserved in human</TD></TR><TR><TD CLASS="l">12</TD><TD> * readable form.</TD></TR><TR><TD CLASS="l">13</TD><TD> *</TD></TR><TR><TD CLASS="l">14</TD><TD> * Because this software is licenses free of charge, it is provided</TD></TR><TR><TD CLASS="l">15</TD><TD> * &#34;AS IS&#34;, with NO WARRANTY.  TO THE EXTENT PERMITTED BY LAW, VNI</TD></TR><TR><TD CLASS="l">16</TD><TD> * DISCLAIMS LEVEL_ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED</TD></TR><TR><TD CLASS="l">17</TD><TD> * TO ITS PERFORMANCE, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</TD></TR><TR><TD CLASS="l">18</TD><TD> * VNI WILL NOT BE LIABLE FOR ANY DAMAGES WHATSOEVER ARISING OUT OF THE USE</TD></TR><TR><TD CLASS="l">19</TD><TD> * OF OR INABILITY TO USE THIS SOFTWARE, INCLUDING BUT NOT LIMITED TO DIRECT,</TD></TR><TR><TD CLASS="l">20</TD><TD> * INDIRECT, SPECIAL, CONSEQUENTIAL, PUNITIVE, AND EXEMPLARY DAMAGES, EVEN</TD></TR><TR><TD CLASS="l">21</TD><TD> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</TD></TR><TR><TD CLASS="l">22</TD><TD> *</TD></TR><TR><TD CLASS="l">23</TD><TD> * -------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">24</TD><TD> */</TD></TR><TR><TD CLASS="l">25</TD><TD> </TD></TR><TR><TD CLASS="l">26</TD><TD>/**</TD></TR><TR><TD CLASS="l">27</TD><TD> *        Collection of special functions.</TD></TR><TR><TD CLASS="l">28</TD><TD> */</TD></TR><TR><TD CLASS="l">29</TD><TD>public class Sfun {</TD></TR><TR><TD CLASS="l">30</TD><TD>        /** The smallest relative spacing for doubles.*/</TD></TR><TR><TD CLASS="l">31</TD><TD>        public final static double EPSILON_SMALL = 1.1102230246252e-16;</TD></TR><TR><TD CLASS="l">32</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="0">33</A></TD><TD>        /** The largest relative spacing for doubles. */</TD></TR><TR><TD CLASS="l">34</TD><TD>        public final static double EPSILON_LARGE = 2.2204460492503e-16;</TD></TR><TR><TD CLASS="l">35</TD><TD> </TD></TR><TR><TD CLASS="l">36</TD><TD>        // Series on [0,0.0625]</TD></TR><TR CLASS="z"><TD CLASS="l">37</TD><TD>        private static final double COT_COEF[] = { .240259160982956302509553617744970e+0, -.165330316015002278454746025255758e-1,</TD></TR><TR><TD CLASS="l">38</TD><TD>                        -.429983919317240189356476228239895e-4, -.159283223327541046023490851122445e-6, -.619109313512934872588620579343187e-9,</TD></TR><TR><TD CLASS="l">39</TD><TD>                        -.243019741507264604331702590579575e-11, -.956093675880008098427062083100000e-14, -.376353798194580580416291539706666e-16,</TD></TR><TR><TD CLASS="l">40</TD><TD>                        -.148166574646746578852176794666666e-18 };</TD></TR><TR><TD CLASS="l">41</TD><TD> </TD></TR><TR><TD CLASS="l">42</TD><TD>        // Series on the interval [0,1]</TD></TR><TR CLASS="z"><TD CLASS="l">43</TD><TD>        private static final double SINH_COEF[] = { 0.1730421940471796, 0.08759422192276048, 0.00107947777456713, 0.00000637484926075,</TD></TR><TR><TD CLASS="l">44</TD><TD>                        0.00000002202366404, 0.00000000004987940, 0.00000000000007973, 0.00000000000000009 };</TD></TR><TR><TD CLASS="l">45</TD><TD> </TD></TR><TR><TD CLASS="l">46</TD><TD>        // Series on [0,1]</TD></TR><TR CLASS="z"><TD CLASS="l">47</TD><TD>        private static final double TANH_COEF[] = { -.25828756643634710, -.11836106330053497, .009869442648006398, -.000835798662344582,</TD></TR><TR><TD CLASS="l">48</TD><TD>                        .000070904321198943, -.000006016424318120, .000000510524190800, -.000000043320729077, .000000003675999055, -.000000000311928496,</TD></TR><TR><TD CLASS="l">49</TD><TD>                        .000000000026468828, -.000000000002246023, .000000000000190587, -.000000000000016172, .000000000000001372, -.000000000000000116,</TD></TR><TR><TD CLASS="l">50</TD><TD>                        .000000000000000009 };</TD></TR><TR><TD CLASS="l">51</TD><TD> </TD></TR><TR><TD CLASS="l">52</TD><TD>        // Series on the interval [0,1]</TD></TR><TR CLASS="z"><TD CLASS="l">53</TD><TD>        private static final double ASINH_COEF[] = { -.12820039911738186343372127359268e+0, -.58811761189951767565211757138362e-1,</TD></TR><TR><TD CLASS="l">54</TD><TD>                        .47274654322124815640725249756029e-2, -.49383631626536172101360174790273e-3, .58506207058557412287494835259321e-4,</TD></TR><TR><TD CLASS="l">55</TD><TD>                        -.74669983289313681354755069217188e-5, .10011693583558199265966192015812e-5, -.13903543858708333608616472258886e-6,</TD></TR><TR><TD CLASS="l">56</TD><TD>                        .19823169483172793547317360237148e-7, -.28847468417848843612747272800317e-8, .42672965467159937953457514995907e-9,</TD></TR><TR><TD CLASS="l">57</TD><TD>                        -.63976084654366357868752632309681e-10, .96991686089064704147878293131179e-11, -.14844276972043770830246658365696e-11,</TD></TR><TR><TD CLASS="l">58</TD><TD>                        .22903737939027447988040184378983e-12, -.35588395132732645159978942651310e-13, .55639694080056789953374539088554e-14,</TD></TR><TR><TD CLASS="l">59</TD><TD>                        -.87462509599624678045666593520162e-15, .13815248844526692155868802298129e-15, -.21916688282900363984955142264149e-16,</TD></TR><TR><TD CLASS="l">60</TD><TD>                        .34904658524827565638313923706880e-17 };</TD></TR><TR><TD CLASS="l">61</TD><TD> </TD></TR><TR><TD CLASS="l">62</TD><TD>        // Series on the interval [0,0.25]</TD></TR><TR CLASS="z"><TD CLASS="l">63</TD><TD>        private static final double ATANH_COEF[] = { .9439510239319549230842892218633e-1, .4919843705578615947200034576668e-1,</TD></TR><TR><TD CLASS="l">64</TD><TD>                        .2102593522455432763479327331752e-2, .1073554449776116584640731045276e-3, .5978267249293031478642787517872e-5,</TD></TR><TR><TD CLASS="l">65</TD><TD>                        .3505062030889134845966834886200e-6, .2126374343765340350896219314431e-7, .1321694535715527192129801723055e-8,</TD></TR><TR><TD CLASS="l">66</TD><TD>                        .8365875501178070364623604052959e-10, .5370503749311002163881434587772e-11, .3486659470157107922971245784290e-12,</TD></TR><TR><TD CLASS="l">67</TD><TD>                        .2284549509603433015524024119722e-13, .1508407105944793044874229067558e-14, .1002418816804109126136995722837e-15,</TD></TR><TR><TD CLASS="l">68</TD><TD>                        .6698674738165069539715526882986e-17, .4497954546494931083083327624533e-18 };</TD></TR><TR><TD CLASS="l">69</TD><TD> </TD></TR><TR><TD CLASS="l">70</TD><TD>        // Series on the interval [0,1]</TD></TR><TR CLASS="z"><TD CLASS="l">71</TD><TD>        private static final double GAMMA_COEF[] = { .8571195590989331421920062399942e-2, .4415381324841006757191315771652e-2,</TD></TR><TR><TD CLASS="l">72</TD><TD>                        .5685043681599363378632664588789e-1, -.4219835396418560501012500186624e-2, .1326808181212460220584006796352e-2,</TD></TR><TR><TD CLASS="l">73</TD><TD>                        -.1893024529798880432523947023886e-3, .3606925327441245256578082217225e-4, -.6056761904460864218485548290365e-5,</TD></TR><TR><TD CLASS="l">74</TD><TD>                        .1055829546302283344731823509093e-5, -.1811967365542384048291855891166e-6, .3117724964715322277790254593169e-7,</TD></TR><TR><TD CLASS="l">75</TD><TD>                        -.5354219639019687140874081024347e-8, .9193275519859588946887786825940e-9, -.1577941280288339761767423273953e-9,</TD></TR><TR><TD CLASS="l">76</TD><TD>                        .2707980622934954543266540433089e-10, -.4646818653825730144081661058933e-11, .7973350192007419656460767175359e-12,</TD></TR><TR><TD CLASS="l">77</TD><TD>                        -.1368078209830916025799499172309e-12, .2347319486563800657233471771688e-13, -.4027432614949066932766570534699e-14,</TD></TR><TR><TD CLASS="l">78</TD><TD>                        .6910051747372100912138336975257e-15, -.1185584500221992907052387126192e-15, .2034148542496373955201026051932e-16,</TD></TR><TR><TD CLASS="l">79</TD><TD>                        -.3490054341717405849274012949108e-17, .5987993856485305567135051066026e-18, -.1027378057872228074490069778431e-18 };</TD></TR><TR><TD CLASS="l">80</TD><TD> </TD></TR><TR><TD CLASS="l">81</TD><TD>        //        Series for the interval [0,0.01]</TD></TR><TR CLASS="z"><TD CLASS="l">82</TD><TD>        private static final double R9LGMC_COEF[] = { .166638948045186324720572965082e0, -.138494817606756384073298605914e-4,</TD></TR><TR><TD CLASS="l">83</TD><TD>                        .981082564692472942615717154749e-8, -.180912947557249419426330626672e-10, .622109804189260522712601554342e-13,</TD></TR><TR><TD CLASS="l">84</TD><TD>                        -.339961500541772194430333059967e-15, .268318199848269874895753884667e-17 };</TD></TR><TR><TD CLASS="l">85</TD><TD> </TD></TR><TR><TD CLASS="l">86</TD><TD>        // Series on [-0.375,0.375]</TD></TR><TR CLASS="z"><TD CLASS="l">87</TD><TD>        final private static double ALNRCS_COEF[] = { .103786935627437698006862677191e1, -.133643015049089180987660415531,</TD></TR><TR><TD CLASS="l">88</TD><TD>                        .194082491355205633579261993748e-1, -.301075511275357776903765377766e-2, .486946147971548500904563665091e-3,</TD></TR><TR><TD CLASS="l">89</TD><TD>                        -.810548818931753560668099430086e-4, .137788477995595247829382514961e-4, -.238022108943589702513699929149e-5,</TD></TR><TR><TD CLASS="l">90</TD><TD>                        .41640416213865183476391859902e-6, -.73595828378075994984266837032e-7, .13117611876241674949152294345e-7,</TD></TR><TR><TD CLASS="l">91</TD><TD>                        -.235467093177424251366960923302e-8, .425227732760349977756380529626e-9, -.771908941348407968261081074933e-10,</TD></TR><TR><TD CLASS="l">92</TD><TD>                        .140757464813590699092153564722e-10, -.257690720580246806275370786276e-11, .473424066662944218491543950059e-12,</TD></TR><TR><TD CLASS="l">93</TD><TD>                        -.872490126747426417453012632927e-13, .161246149027405514657398331191e-13, -.298756520156657730067107924168e-14,</TD></TR><TR><TD CLASS="l">94</TD><TD>                        .554807012090828879830413216973e-15, -.103246191582715695951413339619e-15, .192502392030498511778785032449e-16,</TD></TR><TR><TD CLASS="l">95</TD><TD>                        -.359550734652651500111897078443e-17, .672645425378768578921945742268e-18, -.126026241687352192520824256376e-18 };</TD></TR><TR><TD CLASS="l">96</TD><TD> </TD></TR><TR><TD CLASS="l">97</TD><TD>        // Series on [0,1]</TD></TR><TR CLASS="z"><TD CLASS="l">98</TD><TD>        private static final double ERFC_COEF[] = { -.490461212346918080399845440334e-1, -.142261205103713642378247418996e0,</TD></TR><TR><TD CLASS="l">99</TD><TD>                        .100355821875997955757546767129e-1, -.576876469976748476508270255092e-3, .274199312521960610344221607915e-4,</TD></TR><TR><TD CLASS="l">100</TD><TD>                        -.110431755073445076041353812959e-5, .384887554203450369499613114982e-7, -.118085825338754669696317518016e-8,</TD></TR><TR><TD CLASS="l">101</TD><TD>                        .323342158260509096464029309534e-10, -.799101594700454875816073747086e-12, .179907251139614556119672454866e-13,</TD></TR><TR><TD CLASS="l">102</TD><TD>                        -.371863548781869263823168282095e-15, .710359900371425297116899083947e-17, -.126124551191552258324954248533e-18 };</TD></TR><TR><TD CLASS="l">103</TD><TD> </TD></TR><TR><TD CLASS="l">104</TD><TD>        // Series on [0.25,1.00]</TD></TR><TR CLASS="z"><TD CLASS="l">105</TD><TD>        private static final double ERFC2_COEF[] = { -.69601346602309501127391508262e-1, -.411013393626208934898221208467e-1,</TD></TR><TR><TD CLASS="l">106</TD><TD>                        .391449586668962688156114370524e-2, -.490639565054897916128093545077e-3, .715747900137703638076089414183e-4,</TD></TR><TR><TD CLASS="l">107</TD><TD>                        -.115307163413123283380823284791e-4, .199467059020199763505231486771e-5, -.364266647159922287393611843071e-6,</TD></TR><TR><TD CLASS="l">108</TD><TD>                        .694437261000501258993127721463e-7, -.137122090210436601953460514121e-7, .278838966100713713196386034809e-8,</TD></TR><TR><TD CLASS="l">109</TD><TD>                        -.581416472433116155186479105032e-9, .123892049175275318118016881795e-9, -.269063914530674343239042493789e-10,</TD></TR><TR><TD CLASS="l">110</TD><TD>                        .594261435084791098244470968384e-11, -.133238673575811957928775442057e-11, .30280468061771320171736972433e-12,</TD></TR><TR><TD CLASS="l">111</TD><TD>                        -.696664881494103258879586758895e-13, .162085454105392296981289322763e-13, -.380993446525049199987691305773e-14,</TD></TR><TR><TD CLASS="l">112</TD><TD>                        .904048781597883114936897101298e-15, -.2164006195089607347809812047e-15, .522210223399585498460798024417e-16,</TD></TR><TR><TD CLASS="l">113</TD><TD>                        -.126972960236455533637241552778e-16, .310914550427619758383622741295e-17, -.766376292032038552400956671481e-18,</TD></TR><TR><TD CLASS="l">114</TD><TD>                        .190081925136274520253692973329e-18 };</TD></TR><TR><TD CLASS="l">115</TD><TD> </TD></TR><TR><TD CLASS="l">116</TD><TD>        // Series on [0,0.25]</TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>        private static final double ERFCC_COEF[] = { .715179310202924774503697709496e-1, -.265324343376067157558893386681e-1,</TD></TR><TR><TD CLASS="l">118</TD><TD>                        .171115397792085588332699194606e-2, -.163751663458517884163746404749e-3, .198712935005520364995974806758e-4,</TD></TR><TR><TD CLASS="l">119</TD><TD>                        -.284371241276655508750175183152e-5, .460616130896313036969379968464e-6, -.822775302587920842057766536366e-7,</TD></TR><TR><TD CLASS="l">120</TD><TD>                        .159214187277090112989358340826e-7, -.329507136225284321486631665072e-8, .72234397604005554658126115389e-9,</TD></TR><TR><TD CLASS="l">121</TD><TD>                        -.166485581339872959344695966886e-9, .401039258823766482077671768814e-10, -.100481621442573113272170176283e-10,</TD></TR><TR><TD CLASS="l">122</TD><TD>                        .260827591330033380859341009439e-11, -.699111056040402486557697812476e-12, .192949233326170708624205749803e-12,</TD></TR><TR><TD CLASS="l">123</TD><TD>                        -.547013118875433106490125085271e-13, .158966330976269744839084032762e-13, -.47268939801975548392036958429e-14,</TD></TR><TR><TD CLASS="l">124</TD><TD>                        .14358733767849847867287399784e-14, -.444951056181735839417250062829e-15, .140481088476823343737305537466e-15,</TD></TR><TR><TD CLASS="l">125</TD><TD>                        -.451381838776421089625963281623e-16, .147452154104513307787018713262e-16, -.489262140694577615436841552532e-17,</TD></TR><TR><TD CLASS="l">126</TD><TD>                        .164761214141064673895301522827e-17, -.562681717632940809299928521323e-18, .194744338223207851429197867821e-18 };</TD></TR><TR><TD CLASS="l"><A NAME="2">127</A></TD><TD> </TD></TR><TR><TD CLASS="l">128</TD><TD>        /**</TD></TR><TR><TD CLASS="l">129</TD><TD>         *        Private contructor, so nobody can make an instance of this class.</TD></TR><TR><TD CLASS="l">130</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">131</TD><TD>        private Sfun() {</TD></TR><TR CLASS="z"><TD CLASS="l">132</TD><TD>        }</TD></TR><TR><TD CLASS="l">133</TD><TD> </TD></TR><TR><TD CLASS="l">134</TD><TD>        /**</TD></TR><TR><TD CLASS="l">135</TD><TD>         *        Returns the inverse (arc) hyperbolic cosine of a double.</TD></TR><TR><TD CLASS="l">136</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">137</TD><TD>         *        @return  The arc hyperbolic cosine of x.</TD></TR><TR><TD CLASS="l">138</TD><TD>         *        If x is NaN or less than one, the result is NaN.</TD></TR><TR><TD CLASS="l"><A NAME="3">139</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">140</TD><TD>        static public double acosh(double x) {</TD></TR><TR><TD CLASS="l">141</TD><TD>                double ans;</TD></TR><TR><TD CLASS="l">142</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>                if (Double.isNaN(x) || x &lt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">144</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>                } else if (x &lt; 94906265.62) {</TD></TR><TR><TD CLASS="l">146</TD><TD>                        // 94906265.62 = 1.0/Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">147</TD><TD>                        ans = Math.log(x + Math.sqrt(x * x - 1.0));</TD></TR><TR><TD CLASS="l">148</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">149</TD><TD>                        ans = 0.69314718055994530941723212145818 + Math.log(x);</TD></TR><TR><TD CLASS="l">150</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">151</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">152</TD><TD>        }</TD></TR><TR><TD CLASS="l">153</TD><TD> </TD></TR><TR><TD CLASS="l">154</TD><TD>        /**</TD></TR><TR><TD CLASS="l">155</TD><TD>         *        Returns the inverse (arc) hyperbolic sine of a double.</TD></TR><TR><TD CLASS="l">156</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">157</TD><TD>         *        @return  The arc hyperbolic sine of x.</TD></TR><TR><TD CLASS="l"><A NAME="4">158</A></TD><TD>         *        If x is NaN, the result is NaN.</TD></TR><TR><TD CLASS="l">159</TD><TD>         */</TD></TR><TR><TD CLASS="l">160</TD><TD>        static public double asinh(double x) {</TD></TR><TR><TD CLASS="l">161</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">163</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>                if (Double.isNaN(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">165</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>                } else if (y &lt;= 1.05367e-08) {</TD></TR><TR><TD CLASS="l">167</TD><TD>                        // 1.05367e-08 = Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">168</TD><TD>                        ans = x;</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>                } else if (y &lt;= 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">170</TD><TD>                        ans = x * (1.0 + csevl(2.0 * x * x - 1.0, ASINH_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">171</TD><TD>                } else if (y &lt; 94906265.62) {</TD></TR><TR><TD CLASS="l">172</TD><TD>                        // 94906265.62 = 1/Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">173</TD><TD>                        ans = Math.log(y + Math.sqrt(y * y + 1.0));</TD></TR><TR><TD CLASS="l">174</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                        ans = 0.69314718055994530941723212145818 + Math.log(y);</TD></TR><TR><TD CLASS="l">176</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                if (x &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                        ans = -ans;</TD></TR><TR><TD CLASS="l">179</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">181</TD><TD>        }</TD></TR><TR><TD CLASS="l">182</TD><TD> </TD></TR><TR><TD CLASS="l">183</TD><TD>        /**</TD></TR><TR><TD CLASS="l">184</TD><TD>         *        Returns the inverse (arc) hyperbolic tangent of a double.</TD></TR><TR><TD CLASS="l">185</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="5">186</A></TD><TD>         *        @return  The arc hyperbolic tangent of x.</TD></TR><TR><TD CLASS="l">187</TD><TD>         *        If x is NaN or |x|&gt;1, the result is NaN.</TD></TR><TR><TD CLASS="l">188</TD><TD>         */</TD></TR><TR><TD CLASS="l">189</TD><TD>        static public double atanh(double x) {</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">191</TD><TD>                double ans;</TD></TR><TR><TD CLASS="l">192</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">193</TD><TD>                if (Double.isNaN(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>                } else if (y &lt; 1.82501e-08) {</TD></TR><TR><TD CLASS="l">196</TD><TD>                        // 1.82501e-08 = Math.sqrt(3.0*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                        ans = x;</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                } else if (y &lt;= 0.5) {</TD></TR><TR CLASS="z"><TD CLASS="l">199</TD><TD>                        ans = x * (1.0 + csevl(8.0 * x * x - 1.0, ATANH_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                } else if (y &lt; 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                        ans = 0.5 * Math.log((1.0 + x) / (1.0 - x));</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>                } else if (y == 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">203</TD><TD>                        ans = x * Double.POSITIVE_INFINITY;</TD></TR><TR><TD CLASS="l">204</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>                        ans = Double.NaN;</TD></TR><TR><TD CLASS="l">206</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">208</TD><TD>        }</TD></TR><TR><TD CLASS="l">209</TD><TD> </TD></TR><TR><TD CLASS="l">210</TD><TD>        /**</TD></TR><TR><TD CLASS="l">211</TD><TD>         *        Returns the hyperbolic cosine of a double.</TD></TR><TR><TD CLASS="l">212</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">213</TD><TD>         *        @return  The hyperbolic cosine of x.</TD></TR><TR><TD CLASS="l"><A NAME="6">214</A></TD><TD>         *        If x is NaN, the result is NaN.</TD></TR><TR><TD CLASS="l">215</TD><TD>         */</TD></TR><TR><TD CLASS="l">216</TD><TD>        static public double cosh(double x) {</TD></TR><TR><TD CLASS="l">217</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                double y = Math.exp(Math.abs(x));</TD></TR><TR><TD CLASS="l">219</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">220</TD><TD>                if (Double.isNaN(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                } else if (Double.isInfinite(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                        ans = x;</TD></TR><TR CLASS="z"><TD CLASS="l">224</TD><TD>                } else if (y &lt; 94906265.62) {</TD></TR><TR><TD CLASS="l">225</TD><TD>                        // 94906265.62 = 1.0/Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>                        ans = 0.5 * (y + 1.0 / y);</TD></TR><TR><TD CLASS="l">227</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">228</TD><TD>                        ans = 0.5 * y;</TD></TR><TR><TD CLASS="l">229</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">231</TD><TD>        }</TD></TR><TR><TD CLASS="l">232</TD><TD> </TD></TR><TR><TD CLASS="l">233</TD><TD>        /**</TD></TR><TR><TD CLASS="l">234</TD><TD>         *        Returns the cotangent of a double.</TD></TR><TR><TD CLASS="l">235</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">236</TD><TD>         *        @return  The cotangent of x.</TD></TR><TR><TD CLASS="l"><A NAME="7">237</A></TD><TD>         *        If x is NaN, the result is NaN.</TD></TR><TR><TD CLASS="l">238</TD><TD>         */</TD></TR><TR><TD CLASS="l">239</TD><TD>        static public double cot(double x) {</TD></TR><TR><TD CLASS="l">240</TD><TD>                double ans, ainty, ainty2, prodbg, y, yrem;</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                double pi2rec = 0.011619772367581343075535053490057; //  2/PI - 0.625</TD></TR><TR><TD CLASS="l">242</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>                y = Math.abs(x);</TD></TR><TR><TD CLASS="l">244</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                if (y &gt; 4.5036e+15) {</TD></TR><TR><TD CLASS="l">246</TD><TD>                        // 4.5036e+15 = 1.0/EPSILON_LARGE</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>                        return Double.NaN;</TD></TR><TR><TD CLASS="l">248</TD><TD>                }</TD></TR><TR><TD CLASS="l">249</TD><TD> </TD></TR><TR><TD CLASS="l">250</TD><TD>                // Carefully compute</TD></TR><TR><TD CLASS="l">251</TD><TD>                // Y * (2/PI) = (AINT(Y) + REM(Y)) * (.625 + PI2REC)</TD></TR><TR><TD CLASS="l">252</TD><TD>                //                = AINT(.625*Y) + REM(.625*Y) + Y*PI2REC  =  AINT(.625*Y) + Z</TD></TR><TR><TD CLASS="l">253</TD><TD>                //                = AINT(.625*Y) + AINT(Z) + REM(Z)</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                ainty = (int) y;</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                yrem = y - ainty;</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                prodbg = 0.625 * ainty;</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                ainty = (int) prodbg;</TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                y = (prodbg - ainty) + 0.625 * yrem + y * pi2rec;</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                ainty2 = (int) y;</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                ainty = ainty + ainty2;</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>                y = y - ainty2;</TD></TR><TR><TD CLASS="l">262</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                int ifn = (int) (ainty % 2.0);</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>                if (ifn == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>                        y = 1.0 - y;</TD></TR><TR><TD CLASS="l">266</TD><TD>                }</TD></TR><TR><TD CLASS="l">267</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                if (y == 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                        ans = Double.POSITIVE_INFINITY;</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                } else if (y &lt;= 1.82501e-08) {</TD></TR><TR><TD CLASS="l">271</TD><TD>                        // 1.82501e-08 = Math.sqrt(3.0*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                        ans = 1.0 / y;</TD></TR><TR CLASS="z"><TD CLASS="l">273</TD><TD>                } else if (y &lt;= 0.25) {</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                        ans = (0.5 + csevl(32.0 * y * y - 1.0, COT_COEF)) / y;</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                } else if (y &lt;= 0.5) {</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                        ans = (0.5 + csevl(8.0 * y * y - 1.0, COT_COEF)) / (0.5 * y);</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                        ans = (ans * ans - 1.0) * 0.5 / ans;</TD></TR><TR><TD CLASS="l">278</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                        ans = (0.5 + csevl(2.0 * y * y - 1.0, COT_COEF)) / (0.25 * y);</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                        ans = (ans * ans - 1.0) * 0.5 / ans;</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                        ans = (ans * ans - 1.0) * 0.5 / ans;</TD></TR><TR><TD CLASS="l">282</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>                if (x != 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>                        ans = sign(ans, x);</TD></TR><TR><TD CLASS="l">285</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>                if (ifn == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                        ans = -ans;</TD></TR><TR><TD CLASS="l">288</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">290</TD><TD>        }</TD></TR><TR><TD CLASS="l">291</TD><TD> </TD></TR><TR><TD CLASS="l">292</TD><TD>        /*</TD></TR><TR><TD CLASS="l">293</TD><TD>         *        Evaluate a Chebyschev series</TD></TR><TR><TD CLASS="l"><A NAME="8">294</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">295</TD><TD>        static double csevl(double x, double coef[]) {</TD></TR><TR><TD CLASS="l">296</TD><TD>                double b0, b1, b2, twox;</TD></TR><TR><TD CLASS="l">297</TD><TD>                int i;</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                b1 = 0.0;</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                b0 = 0.0;</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>                b2 = 0.0;</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>                twox = 2.0 * x;</TD></TR><TR CLASS="z"><TD CLASS="l">302</TD><TD>                for (i = coef.length - 1; i &gt;= 0; i--) {</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                        b2 = b1;</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                        b1 = b0;</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>                        b0 = twox * b1 - b2 + coef[i];</TD></TR><TR><TD CLASS="l">306</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>                return 0.5 * (b0 - b2);</TD></TR><TR><TD CLASS="l">308</TD><TD>        }</TD></TR><TR><TD CLASS="l">309</TD><TD> </TD></TR><TR><TD CLASS="l">310</TD><TD>        /*</TD></TR><TR><TD CLASS="l">311</TD><TD>         *        Correction term used by logBeta.</TD></TR><TR><TD CLASS="l"><A NAME="9">312</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">313</TD><TD>        private static double dlnrel(double x) {</TD></TR><TR><TD CLASS="l">314</TD><TD>                double ans;</TD></TR><TR><TD CLASS="l">315</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>                if (x &lt;= -1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>                } else if (Math.abs(x) &lt;= 0.375) {</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                        ans = x * (1.0 - x * Sfun.csevl(x / .375, ALNRCS_COEF));</TD></TR><TR><TD CLASS="l">320</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                        ans = Math.log(1.0 + x);</TD></TR><TR><TD CLASS="l">322</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">324</TD><TD>        }</TD></TR><TR><TD CLASS="l">325</TD><TD> </TD></TR><TR><TD CLASS="l">326</TD><TD>        /**</TD></TR><TR><TD CLASS="l">327</TD><TD>         *        Returns the error function of a double.</TD></TR><TR><TD CLASS="l">328</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="a">329</A></TD><TD>         *        @return  The error function of x.</TD></TR><TR><TD CLASS="l">330</TD><TD>         */</TD></TR><TR><TD CLASS="l">331</TD><TD>        static public double erf(double x) {</TD></TR><TR><TD CLASS="l">332</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">334</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>                if (y &lt;= 1.49012e-08) {</TD></TR><TR><TD CLASS="l">336</TD><TD>                        // 1.49012e-08 = Math.sqrt(2*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                        ans = 2 * x / 1.77245385090551602729816748334;</TD></TR><TR CLASS="z"><TD CLASS="l">338</TD><TD>                } else if (y &lt;= 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>                        ans = x * (1 + csevl(2 * x * x - 1, ERFC_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                } else if (y &lt; 6.013687357) {</TD></TR><TR><TD CLASS="l">341</TD><TD>                        // 6.013687357 = Math.sqrt(-Math.getLog(1.77245385090551602729816748334 * EPSILON_SMALL))</TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                        ans = sign(1 - erfc(y), x);</TD></TR><TR><TD CLASS="l">343</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                        ans = sign(1, x);</TD></TR><TR><TD CLASS="l">345</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">346</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">347</TD><TD>        }</TD></TR><TR><TD CLASS="l">348</TD><TD> </TD></TR><TR><TD CLASS="l">349</TD><TD>        /**</TD></TR><TR><TD CLASS="l">350</TD><TD>         *        Returns the complementary error function of a double.</TD></TR><TR><TD CLASS="l">351</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="b">352</A></TD><TD>         *        @return  The complementary error function of x.</TD></TR><TR><TD CLASS="l">353</TD><TD>         */</TD></TR><TR><TD CLASS="l">354</TD><TD>        static public double erfc(double x) {</TD></TR><TR><TD CLASS="l">355</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">357</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                if (x &lt;= -6.013687357) {</TD></TR><TR><TD CLASS="l">359</TD><TD>                        // -6.013687357 = -Math.sqrt(-Math.getLog(1.77245385090551602729816748334 * EPSILON_SMALL))</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>                        ans = 2;</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                } else if (y &lt; 1.49012e-08) {</TD></TR><TR><TD CLASS="l">362</TD><TD>                        // 1.49012e-08 = Math.sqrt(2*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                        ans = 1 - 2 * x / 1.77245385090551602729816748334;</TD></TR><TR><TD CLASS="l">364</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>                        double ysq = y * y;</TD></TR><TR CLASS="z"><TD CLASS="l">366</TD><TD>                        if (y &lt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>                                ans = 1 - x * (1 + csevl(2 * ysq - 1, ERFC_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                        } else if (y &lt;= 4.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>                                ans = Math.exp(-ysq) / y * (0.5 + csevl((8.0 / ysq - 5.0) / 3.0, ERFC2_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                                if (x &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                                        ans = 2.0 - ans;</TD></TR><TR><TD CLASS="l">372</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">373</TD><TD>                                if (x &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">374</TD><TD>                                        ans = 2.0 - ans;</TD></TR><TR><TD CLASS="l">375</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                                if (x &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                                        ans = 2.0 - ans;</TD></TR><TR><TD CLASS="l">378</TD><TD>                                }</TD></TR><TR><TD CLASS="l">379</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                                ans = Math.exp(-ysq) / y * (0.5 + csevl(8.0 / ysq - 1, ERFCC_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>                                if (x &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                                        ans = 2.0 - ans;</TD></TR><TR><TD CLASS="l">383</TD><TD>                                }</TD></TR><TR><TD CLASS="l">384</TD><TD>                        }</TD></TR><TR><TD CLASS="l">385</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">387</TD><TD>        }</TD></TR><TR><TD CLASS="l">388</TD><TD> </TD></TR><TR><TD CLASS="l">389</TD><TD>        /**</TD></TR><TR><TD CLASS="l">390</TD><TD>         *        Returns the factorial of an integer.</TD></TR><TR><TD CLASS="l">391</TD><TD>         *        @param        n        An integer value.</TD></TR><TR><TD CLASS="l"><A NAME="c">392</A></TD><TD>         *        @return  The factorial of n, n!.</TD></TR><TR><TD CLASS="l">393</TD><TD>         *        If x is negative, the result is NaN.</TD></TR><TR><TD CLASS="l">394</TD><TD>         */</TD></TR><TR><TD CLASS="l">395</TD><TD>        static public double fact(int n) {</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>                double ans = 1;</TD></TR><TR><TD CLASS="l">397</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">398</TD><TD>                if (Double.isNaN(n) || n &lt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">399</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                } else if (n &gt; 170) {</TD></TR><TR><TD CLASS="l">401</TD><TD>                        // The 171! is too large to fit in a double.</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>                        ans = Double.POSITIVE_INFINITY;</TD></TR><TR><TD CLASS="l">403</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>                        for (int k = 2; k &lt;= n; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">405</TD><TD>                                ans *= k;</TD></TR><TR><TD CLASS="l">406</TD><TD>                        }</TD></TR><TR><TD CLASS="l">407</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">408</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">409</TD><TD>        }</TD></TR><TR><TD CLASS="l">410</TD><TD> </TD></TR><TR><TD CLASS="l">411</TD><TD>        /**</TD></TR><TR><TD CLASS="l">412</TD><TD>         *        Returns the Gamma function of a double.</TD></TR><TR><TD CLASS="l">413</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">414</TD><TD>         *        @return  The Gamma function of x.</TD></TR><TR><TD CLASS="l"><A NAME="d">415</A></TD><TD>         *        If x is a negative integer, the result is NaN.</TD></TR><TR><TD CLASS="l">416</TD><TD>         */</TD></TR><TR><TD CLASS="l">417</TD><TD>        static public double gamma(double x) {</TD></TR><TR><TD CLASS="l">418</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">420</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                if (y &lt;= 10.0) {</TD></TR><TR><TD CLASS="l">422</TD><TD>                        /*</TD></TR><TR><TD CLASS="l">423</TD><TD>                         * Compute gamma(x) for |x|&lt;=10.</TD></TR><TR><TD CLASS="l">424</TD><TD>                         * First reduce the interval and  find gamma(1+y) for 0 &lt;= y &lt; 1.</TD></TR><TR><TD CLASS="l">425</TD><TD>                         */</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                        int n = (int) x;</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>                        if (x &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>                                n--;</TD></TR><TR><TD CLASS="l">429</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>                        y = x - n;</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                        n--;</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                        ans = 0.9375 + csevl(2.0 * y - 1.0, GAMMA_COEF);</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                        if (n == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                        } else if (n &lt; 0) {</TD></TR><TR><TD CLASS="l">435</TD><TD>                                // Compute gamma(x) for x &lt; 1</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>                                n = -n;</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                                if (x == 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>                                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                                } else if (y &lt; 1.0 / Double.MAX_VALUE) {</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                                        ans = Double.POSITIVE_INFINITY;</TD></TR><TR><TD CLASS="l">441</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">442</TD><TD>                                        double xn = n - 2;</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>                                        if (x &lt; 0.0 &amp;&amp; x + xn == 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                                                ans = Double.NaN;</TD></TR><TR><TD CLASS="l">445</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                                                for (int i = 0; i &lt; n; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                                                        ans /= x + i;</TD></TR><TR><TD CLASS="l">448</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">449</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                                }</TD></TR><TR><TD CLASS="l">451</TD><TD>                        } else { // gamma(x) for x &gt;= 2.0</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                                for (int i = 1; i &lt;= n; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>                                        ans *= y + i;</TD></TR><TR><TD CLASS="l">454</TD><TD>                                }</TD></TR><TR><TD CLASS="l">455</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>                } else { // gamma(x) for |x| &gt; 10</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                        if (x &gt; 171.614) {</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                                ans = Double.POSITIVE_INFINITY;</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                        } else if (x &lt; -170.56) {</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                                ans = 0.0; // underflows</TD></TR><TR><TD CLASS="l">461</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">462</TD><TD>                                // 0.9189385332046727 = 0.5*getLog(2*PI)</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                                ans = Math.exp((y - 0.5) * Math.log(y) - y + 0.9189385332046727 + r9lgmc(y));</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                                if (x &lt; 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">465</TD><TD>                                        double sinpiy = Math.sin(Math.PI * y);</TD></TR><TR CLASS="z"><TD CLASS="l">466</TD><TD>                                        if (sinpiy == 0 || Math.round(y) == y) {</TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>                                                ans = Double.NaN;</TD></TR><TR><TD CLASS="l">468</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">469</TD><TD>                                                ans = -Math.PI / (y * sinpiy * ans);</TD></TR><TR><TD CLASS="l">470</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">471</TD><TD>                                }</TD></TR><TR><TD CLASS="l">472</TD><TD>                        }</TD></TR><TR><TD CLASS="l">473</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">474</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">475</TD><TD>        }</TD></TR><TR><TD CLASS="l">476</TD><TD> </TD></TR><TR><TD CLASS="l">477</TD><TD>        /**</TD></TR><TR><TD CLASS="l">478</TD><TD>         *        Returns the common (base 10) logarithm of a double.</TD></TR><TR><TD CLASS="l">479</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="e">480</A></TD><TD>         *        @return  The common logarithm of x.</TD></TR><TR><TD CLASS="l">481</TD><TD>         */</TD></TR><TR><TD CLASS="l">482</TD><TD>        static public double log10(double x) {</TD></TR><TR><TD CLASS="l">483</TD><TD>                //if (Double.isNaN(x)) return Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>                return 0.43429448190325182765 * Math.log(x);</TD></TR><TR><TD CLASS="l">485</TD><TD>        }</TD></TR><TR><TD CLASS="l">486</TD><TD> </TD></TR><TR><TD CLASS="l">487</TD><TD>        /**</TD></TR><TR><TD CLASS="l">488</TD><TD>         *        Returns the logarithm of the Beta function.</TD></TR><TR><TD CLASS="l">489</TD><TD>         *        @param        a        A double value.</TD></TR><TR><TD CLASS="l">490</TD><TD>         *        @param        b        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="f">491</A></TD><TD>         *        @return  The natural logarithm of the Beta function.</TD></TR><TR><TD CLASS="l">492</TD><TD>         */</TD></TR><TR><TD CLASS="l">493</TD><TD>        static public double logBeta(double a, double b) {</TD></TR><TR><TD CLASS="l">494</TD><TD>                double corr, ans;</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                double p = Math.min(a, b);</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                double q = Math.max(a, b);</TD></TR><TR><TD CLASS="l">497</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>                if (p &lt;= 0.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>                } else if (p &gt;= 10.0) {</TD></TR><TR><TD CLASS="l">501</TD><TD>                        // P and Q are large;</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>                        corr = r9lgmc(p) + r9lgmc(q) - r9lgmc(p + q);</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                        double temp = dlnrel(-p / (p + q));</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>                        ans = -0.5 * Math.log(q) + 0.918938533204672741780329736406 + corr + (p - 0.5) * Math.log(p / (p + q)) + q * temp;</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>                } else if (q &gt;= 10.0) {</TD></TR><TR><TD CLASS="l">506</TD><TD>                        // P is small, but Q is large</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                        corr = Sfun.r9lgmc(q) - r9lgmc(p + q);</TD></TR><TR><TD CLASS="l">508</TD><TD>                        //  Check from underflow from r9lgmc</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>                        ans = logGamma(p) + corr + p - p * Math.log(p + q) + (q - 0.5) * dlnrel(-p / (p + q));</TD></TR><TR><TD CLASS="l">510</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">511</TD><TD>                        // P and Q are small;</TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                        ans = Math.log(gamma(p) * (gamma(q) / gamma(p + q)));</TD></TR><TR><TD CLASS="l">513</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">515</TD><TD>        }</TD></TR><TR><TD CLASS="l">516</TD><TD> </TD></TR><TR><TD CLASS="l">517</TD><TD>        /**</TD></TR><TR><TD CLASS="l">518</TD><TD>         *        Returns the logarithm of the Gamma function of a double.</TD></TR><TR><TD CLASS="l">519</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">520</TD><TD>         *        @return  The natural logarithm of the Gamma function of x.</TD></TR><TR><TD CLASS="l">521</TD><TD>         *        If x is a negative integer, the result is NaN.</TD></TR><TR><TD CLASS="l"><A NAME="10">522</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">523</TD><TD>        static public double logGamma(double x) {</TD></TR><TR><TD CLASS="l">524</TD><TD>                double ans, sinpiy, y;</TD></TR><TR><TD CLASS="l">525</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>                y = Math.abs(x);</TD></TR><TR><TD CLASS="l">527</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">528</TD><TD>                if (y &lt;= 10) {</TD></TR><TR CLASS="z"><TD CLASS="l">529</TD><TD>                        ans = Math.log(Math.abs(gamma(x)));</TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>                } else if (x &gt; 0) {</TD></TR><TR><TD CLASS="l">531</TD><TD>                        // A&amp;S 6.1.40</TD></TR><TR><TD CLASS="l">532</TD><TD>                        // 0.9189385332046727 = 0.5*getLog(2*PI)</TD></TR><TR CLASS="z"><TD CLASS="l">533</TD><TD>                        ans = 0.9189385332046727 + (x - 0.5) * Math.log(x) - x + r9lgmc(y);</TD></TR><TR><TD CLASS="l">534</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">535</TD><TD>                        sinpiy = Math.abs(Math.sin(Math.PI * y));</TD></TR><TR CLASS="z"><TD CLASS="l">536</TD><TD>                        if (sinpiy == 0 || Math.round(y) == y) {</TD></TR><TR><TD CLASS="l">537</TD><TD>                                // The argument for the function can not be a negative integer.</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>                                ans = Double.NaN;</TD></TR><TR><TD CLASS="l">539</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                                ans = 0.22579135264472743236 + (x - 0.5) * Math.log(y) - x - Math.log(sinpiy) - r9lgmc(y);</TD></TR><TR><TD CLASS="l">541</TD><TD>                        }</TD></TR><TR><TD CLASS="l">542</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">544</TD><TD>        }</TD></TR><TR><TD CLASS="l">545</TD><TD> </TD></TR><TR><TD CLASS="l">546</TD><TD>        /*</TD></TR><TR><TD CLASS="l">547</TD><TD>         *        Returns the getLog gamma correction term for argument</TD></TR><TR><TD CLASS="l">548</TD><TD>         *        values greater than or equal to 10.0.</TD></TR><TR><TD CLASS="l"><A NAME="11">549</A></TD><TD>         */</TD></TR><TR><TD CLASS="l">550</TD><TD>        static double r9lgmc(double x) {</TD></TR><TR><TD CLASS="l">551</TD><TD>                double ans;</TD></TR><TR><TD CLASS="l">552</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                if (x &lt; 10.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                } else if (x &lt; 9.490626562e+07) {</TD></TR><TR><TD CLASS="l">556</TD><TD>                        // 9.490626562e+07 = 1/Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>                        double y = 10.0 / x;</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>                        ans = csevl(2.0 * y * y - 1.0, R9LGMC_COEF) / x;</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>                } else if (x &lt; 1.39118e+11) {</TD></TR><TR><TD CLASS="l">560</TD><TD>                        // 1.39118e+11 = exp(min(getLog(amach(2) / 12.0), -getLog(12.0 * amach(1))));</TD></TR><TR><TD CLASS="l">561</TD><TD>                        // See A&amp;S 6.1.41</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                        ans = 1.0 / (12.0 * x);</TD></TR><TR><TD CLASS="l">563</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>                        ans = 0.0; // underflows</TD></TR><TR><TD CLASS="l">565</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">566</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">567</TD><TD>        }</TD></TR><TR><TD CLASS="l">568</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="12">569</A></TD><TD>        /*</TD></TR><TR><TD CLASS="l">570</TD><TD>         *        Returns the value of x with the sign of y.</TD></TR><TR><TD CLASS="l">571</TD><TD>         */</TD></TR><TR><TD CLASS="l">572</TD><TD>        static private double sign(double x, double y) {</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>                double abs_x = ((x &lt; 0) ? -x : x);</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>                return (y &lt; 0.0) ? -abs_x : abs_x;</TD></TR><TR><TD CLASS="l">575</TD><TD>        }</TD></TR><TR><TD CLASS="l">576</TD><TD> </TD></TR><TR><TD CLASS="l">577</TD><TD>        /**</TD></TR><TR><TD CLASS="l">578</TD><TD>         *        Returns the inverse (arc) hyperbolic sine of a double.</TD></TR><TR><TD CLASS="l">579</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l">580</TD><TD>         *        @return  The arc hyperbolic sine of x.</TD></TR><TR><TD CLASS="l"><A NAME="13">581</A></TD><TD>         *        If x is NaN or less than one, the result is NaN.</TD></TR><TR><TD CLASS="l">582</TD><TD>         */</TD></TR><TR><TD CLASS="l">583</TD><TD>        static public double sinh(double x) {</TD></TR><TR><TD CLASS="l">584</TD><TD>                double ans;</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>                double y = Math.abs(x);</TD></TR><TR><TD CLASS="l">586</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>                if (Double.isNaN(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>                } else if (Double.isInfinite(y)) {</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>                        return x;</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>                } else if (y &lt; 2.58096e-08) {</TD></TR><TR><TD CLASS="l">592</TD><TD>                        // 2.58096e-08 = Math.sqrt(6.0*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">593</TD><TD>                        ans = x;</TD></TR><TR CLASS="z"><TD CLASS="l">594</TD><TD>                } else if (y &lt;= 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">595</TD><TD>                        ans = x * (1.0 + csevl(2.0 * x * x - 1.0, SINH_COEF));</TD></TR><TR><TD CLASS="l">596</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">597</TD><TD>                        y = Math.exp(y);</TD></TR><TR CLASS="z"><TD CLASS="l">598</TD><TD>                        if (y &gt;= 94906265.62) {</TD></TR><TR><TD CLASS="l">599</TD><TD>                                // 94906265.62 = 1.0/Math.sqrt(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">600</TD><TD>                                ans = sign(0.5 * y, x);</TD></TR><TR><TD CLASS="l">601</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">602</TD><TD>                                ans = sign(0.5 * (y - 1.0 / y), x);</TD></TR><TR><TD CLASS="l">603</TD><TD>                        }</TD></TR><TR><TD CLASS="l">604</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">606</TD><TD>        }</TD></TR><TR><TD CLASS="l">607</TD><TD> </TD></TR><TR><TD CLASS="l">608</TD><TD>        /**</TD></TR><TR><TD CLASS="l">609</TD><TD>         *        Returns the hyperbolic tangent of a double.</TD></TR><TR><TD CLASS="l">610</TD><TD>         *        @param        x        A double value.</TD></TR><TR><TD CLASS="l"><A NAME="14">611</A></TD><TD>         *        @return  The hyperbolic tangent of x.</TD></TR><TR><TD CLASS="l">612</TD><TD>         */</TD></TR><TR><TD CLASS="l">613</TD><TD>        static public double tanh(double x) {</TD></TR><TR><TD CLASS="l">614</TD><TD>                double ans, y;</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>                y = Math.abs(x);</TD></TR><TR><TD CLASS="l">616</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">617</TD><TD>                if (Double.isNaN(x)) {</TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>                        ans = Double.NaN;</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>                } else if (y &lt; 1.82501e-08) {</TD></TR><TR><TD CLASS="l">620</TD><TD>                        // 1.82501e-08 = Math.sqrt(3.0*EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>                        ans = x;</TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>                } else if (y &lt;= 1.0) {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>                        ans = x * (1.0 + csevl(2.0 * x * x - 1.0, TANH_COEF));</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>                } else if (y &lt; 7.977294885) {</TD></TR><TR><TD CLASS="l">625</TD><TD>                        // 7.977294885 = -0.5*Math.getLog(EPSILON_SMALL)</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                        y = Math.exp(y);</TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>                        ans = sign((y - 1.0 / y) / (y + 1.0 / y), x);</TD></TR><TR><TD CLASS="l">628</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">629</TD><TD>                        ans = sign(1.0, x);</TD></TR><TR><TD CLASS="l">630</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">631</TD><TD>                return ans;</TD></TR><TR><TD CLASS="l">632</TD><TD>        }</TD></TR><TR><TD CLASS="l">633</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="1f.html">jmt.engine.math</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>